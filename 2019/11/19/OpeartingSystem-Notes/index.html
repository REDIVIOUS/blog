<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Waylon Ding's blog."><meta name="keywords" content="计算机系统结构, 外语, 音乐"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/blog/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/blog/favicon.ico"><link rel="bookmark" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/blog/atom.xml"><title>OpeartingSystem Notes | REDIVIOUS‘s Blog</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">OpeartingSystem Notes</h1><a id="logo" href="/blog/.">REDIVIOUS‘s Blog</a><p class="description">世界那么大，我想去看看</p></div><div id="nav-menu"><a href="/blog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">OpeartingSystem Notes</h1><div class="post-meta"><a href="/blog/2019/11/19/OpeartingSystem-Notes/#comments" class="comment-count"></a><p><span class="date">Nov 19, 2019</span><span><a href="/blog/categories/CS-Courses/" class="category">CS Courses</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="计算机操作系统学习-amp-复习笔记"><a href="#计算机操作系统学习-amp-复习笔记" class="headerlink" title="计算机操作系统学习&amp;复习笔记"></a>计算机操作系统学习&amp;复习笔记</h2><p>参考书目：计算机操作系统（人民邮电出版社）</p>
<h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-1-操作系统在计算机中的地位"><a href="#1-1-操作系统在计算机中的地位" class="headerlink" title="1.1 操作系统在计算机中的地位 *"></a>1.1 操作系统在计算机中的地位 *</h4><ul>
<li>操作系统是什么；<ul>
<li>是核心软件</li>
<li>负责软件硬件资源分配与调用</li>
<li>控制、协调并发活动</li>
<li>提供用户接口、为用户良好工作环境</li>
</ul>
</li>
<li>操作系统特点<br>位置：从里到往外裸机-&gt;操作系统-&gt;应用软件<ul>
<li>内容庞杂、涉及面广<ul>
<li>控制管理硬件、软件；控制程序进行</li>
<li>为用户提供良好接口</li>
</ul>
</li>
<li>实践性强</li>
<li>技术发展快<br>Unix和linux采取优先调度。<br>linux调度方法：140队列，140位位图，扫描位图（不怎么需要时间），高优先级入列</li>
</ul>
</li>
<li>OS和各层次的关系<ul>
<li>硬件：控制CPU、访问存储、驱动设备、中断</li>
<li>软件：控制管理、提供界面和服务</li>
</ul>
</li>
<li>各层次对OS的影响<ul>
<li>硬件约束：用串行（CPU）实现并行（操作系统）</li>
<li>上层用户需求：实时和分时，界面友好</li>
</ul>
</li>
</ul>
<h4 id="1-2-操作系统的形成和发展（多道程序、分时技术）"><a href="#1-2-操作系统的形成和发展（多道程序、分时技术）" class="headerlink" title="1.2 操作系统的形成和发展（多道程序、分时技术）"></a>1.2 操作系统的形成和发展（多道程序、分时技术）</h4><h4 id="1-3-操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）"><a href="#1-3-操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）" class="headerlink" title="1.3 操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）"></a>1.3 操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）</h4><h4 id="1-4-操作系统的基本类型"><a href="#1-4-操作系统的基本类型" class="headerlink" title="1.4 操作系统的基本类型"></a>1.4 操作系统的基本类型</h4><ul>
<li>批量操作系统</li>
<li>分时操作系统</li>
<li>实时操作系统</li>
<li>个人计算机操作系统</li>
<li>网络操作系统</li>
<li>分布式系统</li>
</ul>
<h4 id="1-5-操作系统采用的技术"><a href="#1-5-操作系统采用的技术" class="headerlink" title="1.5 操作系统采用的技术 *"></a>1.5 操作系统采用的技术 *</h4><ul>
<li>并行处理技术<ul>
<li>并行处理：多个部件、为整体任务同时执行。</li>
<li>多用户、多任务同时执行。<br>为描述任务，引入进程的概念。进程的状态及控制（任务状态）、进程同步与互斥（多任务协调）、进程调度（CPU控制权的分配等等）</li>
<li>系统资源共享<br>处理机共享（处理机分配调度）、存储器共享（存储分配、保护、虚拟存储与地址映射）、设备共享（设备分配驱动以及中断）、信息共享（文件结构、共享以及存取方法）</li>
</ul>
</li>
<li>虚拟技术<ul>
<li>用户：逻辑视图。操作系统：物理视图。</li>
<li>物理（硬件）资源（系统）：CPU、主存、打印机、磁盘等。</li>
<li>逻辑（软件）资源（用户）：CPU1、CPU2（CPU分时）；虚拟主存1、虚拟主存2（主存的主存管理）；打印机1、打印机2（虚拟打印技术）（网络上有很多资源需要打印机）</li>
</ul>
</li>
</ul>
<h3 id="第二章-操作系统的结构和硬件支持"><a href="#第二章-操作系统的结构和硬件支持" class="headerlink" title="第二章 操作系统的结构和硬件支持"></a>第二章 操作系统的结构和硬件支持</h3><h4 id="2-1-操作系统虚拟机"><a href="#2-1-操作系统虚拟机" class="headerlink" title="2.1 操作系统虚拟机"></a>2.1 操作系统虚拟机</h4><h4 id="2-2-操作系统组织结构"><a href="#2-2-操作系统组织结构" class="headerlink" title="2.2 操作系统组织结构"></a>2.2 操作系统组织结构</h4><ul>
<li>操作系统的结构</li>
<li>运行时的组织结构</li>
<li>操作系统与计算机层次的接口</li>
</ul>
<h4 id="2-3-处理机的态"><a href="#2-3-处理机的态" class="headerlink" title="2.3 处理机的态 *"></a>2.3 处理机的态 *</h4><ul>
<li>系统中两类程序：管理程序和用户程序：<ul>
<li>管理程序：管理系统资源、控制程序运行</li>
<li>用户程序: 使用资源、提出申请；被控制</li>
</ul>
</li>
<li>区分处理机状态的目的是为了保护操作系统。不保护就有可能瘫痪。</li>
<li>处理机的态：中央处理机的工作状态（取决于当前处理机运行的程序）<ul>
<li>管态：管理程序执行的态。称特权级。使用全部指令和资源。<ul>
<li>有的细分为核心态和管态</li>
</ul>
</li>
<li>用户态：用户程序执行的态。只允许访问自己的存储区域，禁止特权指令，不能直接取用资源与改变机器的态。</li>
</ul>
</li>
<li>管态和用户态区别：<ul>
<li>管态<ul>
<li>操作系统程序执行</li>
<li>使用全部指令</li>
<li>使用全部系统资源（包括整个存储空间）</li>
</ul>
</li>
<li>用户态<ul>
<li>用户程序执行</li>
<li>禁用特权指令</li>
<li>只允许用户程序访问自己的存储区域</li>
</ul>
</li>
<li>特权指令集<ul>
<li>涉及到外部设备的输入/输出命令</li>
<li>修改特殊寄存器的指令</li>
<li>改变机器状态的指令</li>
</ul>
</li>
</ul>
</li>
<li>实现处理机分态的硬件支持<ul>
<li>在状态寄存器中设置状态位：<ul>
<li>一位：用户态、管态</li>
<li>两位：核态、管态、用户态<ul>
<li>核态和管态都是操作系统程序执行时处理机的状态。核态：操作系统核心程序执行时的状态，权限比管态高，可以执行所有机器指令（改变机器状态）。</li>
</ul>
</li>
<li>Unix（linux）系统中状态的分类<ul>
<li>00-核态；01-管态；11-用户态</li>
</ul>
</li>
<li>80x86微处理器中状态位：（CPU特权级）DPL=0（核态）；DPL=3（用户态）</li>
</ul>
</li>
<li>程序性中断<ul>
<li>程序有越权操作时候发生的中断称为程序性中断。</li>
<li>中断机制负责使其陷入操作系统，用户态转换为管态，操作系统管理程序获得控制权开始执行。</li>
</ul>
</li>
<li>什么时候中断<br>用户态下超出了权限时保护操作系统：<ul>
<li>当用户执行了一条特权指令</li>
<li>当用户程序试图访问<code>操作系统数据区</code>或<code>其他程序占用的区域</code>时。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-中断及其处理"><a href="#2-4-中断及其处理" class="headerlink" title="2.4 中断及其处理 *"></a>2.4 中断及其处理 *</h4><ul>
<li>中断：某个事件（掉电、定点加法溢出，I/O结束）发生时，停止现行程序执行，转而处理该事件的程序对事件进行处理，处理完毕返回执行原来程序。</li>
<li>中断类型：<ul>
<li>I/O中断</li>
<li>外中断：时钟、操作员控制台中断、通信中断</li>
<li>机器故障中断：电源、主存取指错等。</li>
<li>程序性中断：定点溢出、用户态下使用核态指令、非法操作</li>
<li>访管中断：对操作系统提出某种需求的时所发出的中断。</li>
</ul>
</li>
<li>中断方式：<ul>
<li>强迫性中断：除了访管中断</li>
<li>自愿中断：访管中断</li>
</ul>
</li>
<li>中断来源<ul>
<li>中断：由处理机外部事件引起的中断：时钟、磁盘、终端</li>
<li>俘获：由处理机内部事件引起的中断：非法指令、地址越界、浮点溢出、trap指令</li>
</ul>
</li>
<li>中断响应及硬件支持：<ul>
<li>保护现场、恢复现场<ul>
<li>现场： 后继指令所在主存的单元号、程序运行所处的状态、指令执行情况、程序执行的中间结果</li>
<li>保护现场：现场存入主存。</li>
<li>恢复现场：把保护的现场重新送到各个特殊寄存器</li>
</ul>
</li>
<li>中断响应：中央处理器发出请求-&gt;中止现有程序执行-&gt;引出中断处理程序的过程<ul>
<li>系统堆栈：存入指令计数器(PC)、处理机状态寄存器(PS) 的内容 (一般先PS后PC？)（硬件层面）</li>
<li>中断向量表：存入中断程序地址（地址内存从0开始）</li>
<li>中断响应实质：交换指令地址及处理机的状态信息</li>
</ul>
</li>
</ul>
</li>
<li>软件的中断处理过程<ul>
<li>中断进入</li>
<li>step1 保护中断程序的现场（没有保存的寄存器）</li>
<li>step2 进入相应的中断服务例程。</li>
<li>step3 恢复中断程序的现场。</li>
</ul>
</li>
</ul>
<h3 id="第三章-操作系统的用户接口"><a href="#第三章-操作系统的用户接口" class="headerlink" title="第三章 操作系统的用户接口"></a>第三章 操作系统的用户接口</h3><h4 id="3-1-用户工作环境"><a href="#3-1-用户工作环境" class="headerlink" title="3.1 用户工作环境"></a>3.1 用户工作环境</h4><ul>
<li>操作系统提供的环境</li>
<li>操作系统的生成和系统初启</li>
<li>应用程序的处理</li>
</ul>
<h4 id="3-2-操作系统的用户接口及分类"><a href="#3-2-操作系统的用户接口及分类" class="headerlink" title="3.2 操作系统的用户接口及分类"></a>3.2 操作系统的用户接口及分类</h4><ul>
<li>用户接口/用户界面：用户控制计算机的手段<ul>
<li>操作接口/命令界面：键盘命令（分时操作系统）（MS-DOS、unix/linux）、图形界面（windows）、作业控制语言（批处理系统）<br>组织工作流程，控制程序运行（C语言编写编译链接等）</li>
<li>程序接口：系统功能调用<br>程序运行时，使用系统功能调用来请求操作系统的服务。</li>
</ul>
</li>
</ul>
<h4 id="3-3-系统功能调用及其实现技术"><a href="#3-3-系统功能调用及其实现技术" class="headerlink" title="3.3 系统功能调用及其实现技术"></a>3.3 系统功能调用及其实现技术</h4><ul>
<li>硬件支持：由用户态到管态<ul>
<li>访管指令/自愿进管指令：svc n（功能号）</li>
<li>访管中断：正在运行的程序对于操作系统的某种需求。</li>
<li>系统功能调用：借助访管指令，取值n（特定功能），硬件进入，软件方法完成。</li>
</ul>
</li>
<li>系统调用实现<br>用户程序（svc i）、访管中断处理程序（按照i转移）、例行子程序入口地址表、例行自程序</li>
</ul>
<h4 id="3-5-linux系统调用功能的实现"><a href="#3-5-linux系统调用功能的实现" class="headerlink" title="3.5 linux系统调用功能的实现"></a>3.5 linux系统调用功能的实现</h4><ul>
<li>linux系统功能调用的进入<ul>
<li>异常处理（系统调用通过异常类型实现）、软中断（int 0x80）、状态转换（从用户态到核心态，执行自陷处理程序（防管中断处理程序））</li>
</ul>
</li>
<li>getuid系统调用过程<br>  用户程序(getuid())-&gt;标准C库(内含int0x80)-&gt;系统调用处理程序-&gt;内核例程（系统服务例程）</li>
<li>linux系统调用的进入和返回<ul>
<li>软中断（自陷指令/访管指令）int 0x80</li>
<li>发生中断（自陷/访管中断）</li>
<li>处理机用户态-&gt;内核态（内核状态的改变）</li>
<li>system_call()开始执行系统调用处理程序（系统功能调用的执行）</li>
<li>处理完毕后，iret返回到用户态</li>
</ul>
</li>
<li>Linux系统功能调用的实现机制<ul>
<li>硬件支持： 增加一个软中断指令、自陷</li>
<li>软件：系统调用号、系统调用表、系统服务例程、系统调用处理程序</li>
</ul>
</li>
<li>增加一个新的系统调用<ul>
<li>增加一个新的系统服务例程</li>
<li>增加一个新的系统调用号</li>
<li>在系统调用表中增加一项（新例程的地址）</li>
<li>将新的系统服务例程加入到系统中（系统重构）</li>
</ul>
</li>
<li>系统调用号<ul>
<li>linux中每个系统调用被赋予一个唯一的系统调用号<br>格式：#define _NR_fork 2</li>
</ul>
</li>
<li>系统调用表：记录了内核中所有已经注册过的系统调用、系统调用的函数指针（函数指针数组）（保存所有系统调用的函数指针）</li>
<li>系统调用的处理过程<ul>
<li>宏SAVE_ALL保护现场</li>
<li>正确性检查</li>
<li>eax中包含系统调用号，调用对应的服务例程</li>
<li>服务流程结束时，RESTORE_ALL恢复寄存器</li>
<li>iret返回</li>
</ul>
</li>
</ul>
<h3 id="第四章-进程及进程管理"><a href="#第四章-进程及进程管理" class="headerlink" title="第四章 进程及进程管理"></a>第四章 进程及进程管理</h3><h4 id="4-1-并发进程及其特点"><a href="#4-1-并发进程及其特点" class="headerlink" title="4.1 并发进程及其特点"></a>4.1 并发进程及其特点</h4><ul>
<li>程序的顺序执行：一个程序的一次执行过程称为一个计算，一个计算的若干操作必须按照严格的先后顺序来执行。<ul>
<li>顺序性：按照严格顺序执行</li>
<li>封闭性：一旦开始执行，不受外界因素影响</li>
<li>可再现性：执行的结果与他的执行速度无关（时间无关），与初始条件有关。</li>
</ul>
</li>
<li>并发程序<ul>
<li>定义：若干个程序同时在系统中运行，程序在时间上时重叠的（一个没做完，另外一个已经开始）</li>
<li>并行语句记号<br>cobegin<br>  S1，S2，S3…<br>coend</li>
</ul>
</li>
<li>并发程序的特点<ul>
<li>失去了封闭性和可再现性<br>一个程序的执行可以改变另一个程序的变量，后者的输出依赖于各程序执行的相对速度，失去了程序的封闭性的特点。</li>
<li>解决进程的同步问题（与时间有关的错误）</li>
<li>程序与计算不再一一对应：一个程序对应多个计算</li>
<li>程序并发执行的相互制约：间接的相互制约：资源共享、直接的相互制约：公共变量</li>
</ul>
</li>
</ul>
<h4 id="4-2-1-进程定义"><a href="#4-2-1-进程定义" class="headerlink" title="4.2.1 进程定义"></a>4.2.1 进程定义</h4><ul>
<li>运行（获得cpu）-&gt;暂停（保留状态）-&gt;运行（获得cpu）</li>
<li>定义：在给定的活动空间和初始环境下，在一个处理机上的执行过程。</li>
<li>与程序的区别<ul>
<li>程序静态（C语言代码不变）、进程动态（一次执行过程）</li>
<li>进程是一个独立运行的活动单位</li>
<li>竞争系统资源的基本单位（cpu，I/O）</li>
<li>一个程序可以对应多个进程，一个进程至少包含一个程序。</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-进程状态及其变迁"><a href="#4-2-2-进程状态及其变迁" class="headerlink" title="4.2.2 进程状态及其变迁"></a>4.2.2 进程状态及其变迁</h4><ul>
<li>进程的基本状态<ul>
<li>运行状态（占用cpu）：已经获得运行所必须的资源，程序正在处理机上执行 （单cpu运行状态只能有一个）</li>
<li>等待状态（输入输出）：程序等待某一事件等待发生（等待外部传输完成等等）而暂时停止执行（这时即使给它cpu的控制权也无法执行）</li>
<li>就绪状态：进程已经获得除了CPU之外的运行所必须的资源，一旦获得了CPU控制权，就可以立即运行。</li>
</ul>
</li>
<li>进程状态的变迁：（基本状态变迁只有前三个）<ul>
<li>运行-&gt;等待：服务请求（I/O）</li>
<li>等待-&gt;就绪：（I/O是完成）服务完成，事件来到</li>
<li>就绪-&gt;运行：进程调度（CPU空出）</li>
<li>等待-&gt;运行：不可能</li>
<li>运行-&gt;就绪：时间片到了（分时系统中）</li>
<li>就绪-&gt;等待：有需求的系统提供（一般没有）</li>
</ul>
</li>
<li>linux系统状态变迁<ul>
<li>新进程-&gt;就绪：创建</li>
<li>就绪-&gt;运行：进程调度</li>
<li>运行-&gt;就绪：被抢占</li>
<li>等待-&gt;就绪：等待的事情发生</li>
<li>运行-&gt;等待：等待某事件</li>
<li>运行-&gt;终止：进程完成</li>
</ul>
</li>
<li>进程状态变迁的驱动及条件<br>见作业习题</li>
</ul>
<h4 id="4-2-3-进程控制块及进程队列"><a href="#4-2-3-进程控制块及进程队列" class="headerlink" title="4.2.3 进程控制块及进程队列"></a>4.2.3 进程控制块及进程队列</h4><ul>
<li>进程控制块：描述：1、进程与其他进程；2、系统资源的关系；以及3、进程在各个不同时期所处状态；的数据结构。称为进程控制块PCB。</li>
<li>程序与数据：描述进程“本身”所应该完成的功能</li>
<li>PCB：进程的动态特征，该进程与“其他进程”和“系统资源”的关系。</li>
<li>进程控制块（内容）：<ul>
<li>进程标识符：进程符号或者内部id号</li>
<li>进程当前状态：本进程目前处于何种状态。</li>
<li>当前队列指针：登记了处于同一状态的“下一个进程的PCB地址”。</li>
<li>进程优先级：进程提要求CPU的紧迫程度。</li>
<li>通信信息：进程间通信记录的有关信息。</li>
<li>家族联系：本进程和家族的联系（子进程、父进程等等）</li>
</ul>
</li>
<li>进程控制块的组织————进程队列结构<ul>
<li>就绪状态队列：ready_q_start —— 一个或者（最多140个）</li>
<li>等待打印机队列：wait_lpt_q_start —— 多个（等待打印机、磁盘、键盘等）</li>
<li>运行指针：running ——一个</li>
</ul>
</li>
<li>进程控制块的作用：<ul>
<li>修改PCB表项<br>  系统通过修改PCB表项的内容，‘动态记录’该进程‘当前的状态’和‘占有资源’的情况，以便实施有效的管理。</li>
<li>在进程队列中移动PCB结构<br>  进程控制和进程调度的功能实现，是在相应的进程队列中移动相关的PCB结构。 </li>
</ul>
</li>
</ul>
<h4 id="4-3-进程控制"><a href="#4-3-进程控制" class="headerlink" title="4.3 进程控制"></a>4.3 进程控制</h4><ul>
<li>进程状态的变化<ul>
<li>无 -（创建）- 有 -（撤销）- 消亡</li>
<li>运行 -（等待）- 等待</li>
<li>就绪 -（唤醒）- 等待</li>
<li>创建原语、撤销原语、等待原语、唤醒原语 （原语：原子操作（系统功能调用））</li>
</ul>
</li>
<li>进程创建<ul>
<li>进程创建原语——create（fork）</li>
<li>进程创建原语的功能：创建一个具有指定标识符的过程，建立进程的PCB结构</li>
<li>进程创建原语的实现：PCB池</li>
</ul>
</li>
<li>进程创建原语——create（fork）<ul>
<li>申请一个空的PCB结构</li>
<li>无空位报错，有则将入口信息填入PCB的对应项。</li>
<li>将PCB入就绪队列。</li>
<li>返回进程pid（PCB池中的位置）。</li>
</ul>
</li>
<li>进程撤销——kill/exit（退出自己）（一个，一组，自己）<ul>
<li>运行指针获得当前进程的pid</li>
<li>释放本进程所占用的资源给父进程</li>
<li>释放PCB结构</li>
<li>转进程调度</li>
</ul>
</li>
<li>进程等待原语——susp<ul>
<li>保护CPU现场到PCB结构中</li>
<li>置该进程为“等待”状态</li>
<li>将其PCB结构插入到相应等待队列</li>
<li>转进程调度</li>
</ul>
</li>
<li>进程唤醒原语——wakeup<ul>
<li>找到该等待队列</li>
<li>将该结构移出等待队列</li>
<li>将该进程置为就绪状态，PCB插入就绪队列</li>
<li>返回刚刚被打断的进程</li>
</ul>
</li>
<li>进程控制功能及其在进程队列上的操作</li>
</ul>
<h4 id="4-4-2-进程互斥的概念"><a href="#4-4-2-进程互斥的概念" class="headerlink" title="4.4.2 进程互斥的概念"></a>4.4.2 进程互斥的概念</h4><ul>
<li>临界资源：系统中有多个进程，共享各种资源，然而有些资源一次只能为一个进程所用。<ul>
<li>系统资源打印机，A、B共享一台打印机。若任意使用，两进程的输出结果交织在一起。解决方法：A使用之前先提出申请，然后独占，B只有在A释放之后系统才能分给B。</li>
<li>进程共享公共变量。</li>
</ul>
</li>
<li>临界区：</li>
<li>互斥：操作系统中。某一进程正在访问某一存储区域时，就不允许其他进程“读出来”或者“修改”该存储区的内容。</li>
</ul>
<h4 id="4-4-3-进程同步的概念"><a href="#4-4-3-进程同步的概念" class="headerlink" title="4.4.3 进程同步的概念"></a>4.4.3 进程同步的概念</h4><ul>
<li>并发进程在一些关键点上可能需要相互等待与互通消息，这种相互制约的等待与互通消息称为进程同步</li>
<li>共享缓冲区的计算进程与打印进程的同步<ul>
<li>计算进程cp和打印进程iop公用一个单缓冲</li>
<li>计算的速度快，输出的速度慢。丢失信息</li>
<li>计算的速度慢，输出的速度快。重复打印</li>
</ul>
</li>
</ul>
<h4 id="4-5-同步机构"><a href="#4-5-同步机构" class="headerlink" title="4.5 同步机构"></a>4.5 同步机构</h4><h4 id="4-5-1-锁、上锁、开锁"><a href="#4-5-1-锁、上锁、开锁" class="headerlink" title="4.5.1 锁、上锁、开锁"></a>4.5.1 锁、上锁、开锁</h4><ul>
<li>每一个共享的临界资源：一个锁单位：0可用，1不可用。</li>
<li>上锁操作：<ul>
<li>检测锁位的值（0or1）</li>
<li>若0变为1（占用）</li>
<li>若1（占用），返回第一步</li>
</ul>
</li>
<li>开锁操作：使用完之后，锁位变为0。</li>
<li>上锁原语：保护cpu、当前进程变为等待，插入w的等待队列，转进程调度、w=1</li>
<li>开锁原语：移除等待队列的首元素，插入到就绪队列、该进程就绪、w=0<br>上锁原语-&gt;临界区-&gt;开锁原语</li>
</ul>
<h4 id="4-5-2-信号等的PV操作"><a href="#4-5-2-信号等的PV操作" class="headerlink" title="4.5.2 信号等的PV操作"></a>4.5.2 信号等的PV操作</h4><ul>
<li>2元组：(s.q)。<ul>
<li>s&gt;0,表示有可用资源，进程执行，绿灯。</li>
<li>s&lt;=0，表示没有可用资源，停止执行，红灯。</li>
</ul>
</li>
<li>P操作：P(s)；s减1（大于等于0返回，小于0（进程被阻）入信号灯等待队列，置为“等待状态”，转进程调度）</li>
<li>V操作：V(s)：S加一。大于0返回，小于等于0唤醒（从信号灯的等待队列中取出首元素、入就绪队列、置“就绪状态”、返回）</li>
</ul>
<h4 id="4-6-进程互斥与同步的实现"><a href="#4-6-进程互斥与同步的实现" class="headerlink" title="4.6 进程互斥与同步的实现"></a>4.6 进程互斥与同步的实现</h4><h4 id="4-6-1-用上锁原语和开锁原语实现进程互斥"><a href="#4-6-1-用上锁原语和开锁原语实现进程互斥" class="headerlink" title="4.6.1 用上锁原语和开锁原语实现进程互斥"></a>4.6.1 用上锁原语和开锁原语实现进程互斥</h4><p>上锁原语-&gt;进入临界区cs-&gt;开锁原语 （main函数中设置w=1）</p>
<h4 id="4-6-2-用信号灯的P、V操作实现互斥"><a href="#4-6-2-用信号灯的P、V操作实现互斥" class="headerlink" title="4.6.2 用信号灯的P、V操作实现互斥"></a>4.6.2 用信号灯的P、V操作实现互斥</h4><ul>
<li>mutex:互斥信号灯  </li>
<li>p(mutex)-&gt;临界区cs-&gt;v(mutex)</li>
<li>若有两个并发进程<ul>
<li>mutex=1:没有程序进入临界区</li>
<li>mutex=0:有一个程序进入临界区</li>
<li>mutex=-1:一个程序进入临界区，另一个程序等待进入</li>
</ul>
</li>
<li>若有n个并发进程，则可能有1,0,-1,…,-(n-1)取值</li>
<li>信号灯s为正值：挂起进程前还可以使用的P操作数，等于s还可以使用的物理资源数。</li>
<li>s为负值：在信号灯s队列中等待的进程个数。</li>
<li>P操作：请求一个资源/挂起进程，V操作：释放一个资源/唤醒进程。<br>化验单-&gt;化验进程-》开始工作<br>化验进程-》化验结果-》看病进程-》医疗方案。</li>
</ul>
<h4 id="4-6-3-进程同步的实现"><a href="#4-6-3-进程同步的实现" class="headerlink" title="4.6.3 进程同步的实现"></a>4.6.3 进程同步的实现</h4><ul>
<li>合作进程的执行次序</li>
<li>共享缓冲区的合作进程的同步的解法  </li>
<li>考虑4.4.3节中提到的问题<ol>
<li>sa表示缓冲区中是否有可供打印的计算结果，初值为0。</li>
<li>sb表示缓冲区有无空位置存放新的信息，其初值为1。</li>
</ol>
</li>
</ul>
<h4 id="4-6-4-生产者和消费者"><a href="#4-6-4-生产者和消费者" class="headerlink" title="4.6.4 生产者和消费者"></a>4.6.4 生产者和消费者</h4><ul>
<li>计算进程和打印进程<ul>
<li>多个计算进程cp不断产生数据，生产者</li>
<li>多个打印进程iop不断打印数据，消费者</li>
<li>有多个缓冲区</li>
</ul>
</li>
<li>通信问题<ul>
<li>发消息进程send不断产生消息，生产者</li>
<li>受消息recieve不断接收消息，消费者</li>
</ul>
</li>
<li>生产者和消费者的同步关系<ul>
<li>生产者：有界缓冲区无空位，等待；放入物品，发消息</li>
<li>消费者：无物品，等待；取物品，发消息</li>
</ul>
</li>
<li>信号灯的设置<ul>
<li>两个同步信号灯<ul>
<li>sb：缓冲区的数目，初值=n</li>
<li>sa：信息数目，初值=0</li>
</ul>
</li>
<li>一个互斥信号灯<ul>
<li>mutex：有界缓冲区是否被占用，初值=1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-7-进程通信-IPC"><a href="#4-7-进程通信-IPC" class="headerlink" title="4.7 进程通信(IPC)"></a>4.7 进程通信(IPC)</h4><ul>
<li>概念：进程之间直接以<code>较高的效率</code>传递<code>较多数据</code>的信息交互方式。也是两个不同的进程<code>共享数据</code>的方式。</li>
<li>实现：消息缓冲器、发送操作、接收操作</li>
<li>发送进程和接受进程的同步：发送等待、接受等待。</li>
</ul>
<h4 id="4-7-2-进程通信的方式"><a href="#4-7-2-进程通信的方式" class="headerlink" title="4.7.2 进程通信的方式"></a>4.7.2 进程通信的方式</h4><ul>
<li>消息缓冲通信<ul>
<li>信息头：发送进程的标识符、接受进程的标识符、传送信息的字节数。</li>
<li>消息缓冲、发送原语、接受原语：每一次想要发送消息，形成一个消息缓冲区，消息原语将消息发出；接受进程在本进程主存空间形成一个接受区，接受原语接受消息。</li>
</ul>
</li>
<li>信箱通信<ul>
<li>定义信箱结构</li>
<li>消息发送模块、功能接受模块：提供发送原语和接受原语</li>
<li>所使用的信箱可以用于用户空间中（接受进程地址空间的一部分）、也可以用于操作系统空间中。</li>
</ul>
</li>
<li>下面两个？？</li>
<li>sys V进程通信方式<ul>
<li>信号量</li>
<li>共享内存</li>
<li>消息队列</li>
</ul>
</li>
<li>posix进程间通信方式<ul>
<li>共享内存</li>
<li>信号量</li>
</ul>
</li>
</ul>
<h4 id="4-8-线程的概念及特点"><a href="#4-8-线程的概念及特点" class="headerlink" title="4.8 线程的概念及特点"></a>4.8 线程的概念及特点</h4><ul>
<li>概念：比进程更小的活动单位，进程中的一个执行路径。</li>
<li>描述：进程中的一条执行路径、有自己私用的运行栈和处理机执行环境、与其他线程“共享”分配给进程的“内存和文件”、单个进程是创建的多个同时存在的线程中的一个。线程是一个动态概念。</li>
<li>线程调用实例</li>
</ul>
<h4 id="4-9-操作系统的并发机制实例"><a href="#4-9-操作系统的并发机制实例" class="headerlink" title="4.9 操作系统的并发机制实例"></a>4.9 操作系统的并发机制实例</h4><ul>
<li>创建进程及应用实例</li>
<li>创建线程及应用实例</li>
<li>等待进程、线程的终止及应用</li>
<li>信号量与使用方法</li>
<li>共享内存及应用实例</li>
</ul>
<h4 id="4-10-进程调度"><a href="#4-10-进程调度" class="headerlink" title="4.10 进程调度"></a>4.10 进程调度</h4><ul>
<li>调度/分派结构：多个就绪状态的进程对处理机的竞争是由进程调度程序来协调的。<ul>
<li>调度：就绪状态的进程排序。将一个进程插入到就绪队列，按照一定策略排序。</li>
<li>分派：调度时机，就绪队列第一个进程移出，建立其在处理机上执行环境，在处理机执行。</li>
</ul>
</li>
<li>调度的功能<ul>
<li>记录进程的状态变化</li>
<li>决定调度策略：1.优先调度、2.FIFO</li>
<li>实施处理机的分配和回收</li>
</ul>
</li>
<li>调度时机<ul>
<li>运行-》等待（阻塞）</li>
<li>运行-》就绪（时间片到）</li>
<li>等待-》就绪（唤醒）</li>
<li>任务完成，终止</li>
<li>异常出错</li>
<li>可剥夺调度，出现更高优先级的就绪进程。</li>
</ul>
</li>
<li>调度方式：“重要而紧迫”的进程怎么处理<ul>
<li>剥夺方式：暂停current，处理机给“重要而紧迫”</li>
<li>非剥夺方式：继续current，直到该进程完成或发生某事件到“完成”、“阻塞”，才给“重要而紧迫”</li>
</ul>
</li>
<li>调度算法<ul>
<li>进程优先数调度算法<ul>
<li>优先数的分类和确定<ol>
<li>静态优先数：根据所需资源来计算、基于程序运行时间估计、基于进程类型。</li>
<li>动态优先数：CPU超过一定时间降低、I/O增加，等待时间超过一定时间增加。</li>
</ol>
</li>
</ul>
</li>
<li>循环轮转调度算法<ul>
<li>时间片的计算：q=t/n （t为用户能接受的响应时间，n为进入系统的进程数目）</li>
<li>时间片的选取：太小，系统切换很频繁（切换时间不可忽略），从系统角度来看，时间片取大比较好。太大，轮转一次的总时间增大，对进程的响应速度放慢了。  </li>
<li>可变时间片轮转调度：根据系统当前的进程树来确定时间片的大小。</li>
<li>多级时间片循环调度<ul>
<li>多个就绪队列</li>
<li>先进入高优先级队列，高优先级队列的时间片较小。</li>
<li>用完后，进入下一级队列，优先级降低，但时间片增大一倍。</li>
<li>这个算法，较小时间片处理完较短进程，避免较长进程被频繁中断。</li>
</ul>
</li>
<li>时间片与优先级混合调度算法<ul>
<li>I/O后进入因I/O而等待队列，完成后进入高优先就绪。</li>
<li>运行时间片到了，进入低优先就绪队列。</li>
<li>CPU空闲时，若高优先就绪队列非空，则从高优先就绪队列中选择一个进程运行，分配时间片100ms。</li>
<li>CPU空闲时，若高优先就绪队列为空，则从低优先就绪队列中选择一个程序运行，分配时间片为500ms。</li>
<li>照顾I/O量大的进程，适当照顾计算量大的进程，提高系统资源利用率。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第五章-资源分配与调度"><a href="#第五章-资源分配与调度" class="headerlink" title="第五章 资源分配与调度"></a>第五章 资源分配与调度</h3><h4 id="5-1-资源管理概述"><a href="#5-1-资源管理概述" class="headerlink" title="5.1 资源管理概述"></a>5.1 资源管理概述</h4><ul>
<li>资源管理的目的和任务</li>
<li>虚拟资源</li>
</ul>
<h4 id="5-2-资源管理的机制和策略"><a href="#5-2-资源管理的机制和策略" class="headerlink" title="5.2 资源管理的机制和策略"></a>5.2 资源管理的机制和策略</h4><ul>
<li>资源分配机制</li>
<li>资源分配策略</li>
</ul>
<h4 id="5-3-死锁"><a href="#5-3-死锁" class="headerlink" title="5.3 死锁"></a>5.3 死锁</h4><ul>
<li>定义与示例</li>
<li>原因和必要条件</li>
<li>系统模型和死锁的处理</li>
</ul>
<h3 id="第六章-主存管理"><a href="#第六章-主存管理" class="headerlink" title="第六章 主存管理"></a>第六章 主存管理</h3><p>实际的存储体系是三级存储体系：即CPU-&gt;cache-&gt;内存(主存)、辅存</p>
<ul>
<li>虚拟内存：较大程序较小内存运行（局部性）——页式、段式、段页式 <ul>
<li>进程虚拟页（页）、内存物理页（页框）——页（小段1k，2k，4k）</li>
<li>VA虚拟地址、页号P、页内偏移w、页大小（2^n）（除法、求余）（右移n位、与操作）</li>
<li>页面映射表（页表）页-页框、页式地址映射（虚拟地址、物理地址、MA=P’*大小+W）</li>
<li>快表（cache放页表）、慢表是内存：提高快表命中率</li>
<li>页面的共享：dll（进程代码段共享）（共享区域有：相同页框号）</li>
<li>缺页（从辅存获取）、页面扩充（带中断位，1不在内存0在；辅存地址）、（访问位，0没有1有；和修改位，0没有1有）、缺页中断（访问位页不在内存）、缺页中断处理程序（调入、重写、选页淘汰、更新页表、更新中断位）、缺页（中断）率=缺页次数/访问页面总次数；命中率=1-缺页率 </li>
<li>页面抖动（页面在内存和辅存间频繁交换，系统效率下降）、缺页淘汰策略（完成高命中率和少抖动率）。<ul>
<li>OPT——淘汰最有可能不需要的页面：目前内存中，最远的将来要用到的页面（或者根本就不需要用的）；理论最佳，实际无法实现（无法得知以后会访问什么页面）</li>
<li>FIFO——淘汰停留时间最长的页面；对于特定序列十分不友好（刚挤出去哪一个下面马上来哪一个，强抖动）有的页面虽然持续时间很长，但是频繁访问，不应该被挤出去，所以有LRU算法</li>
<li>LRU——淘汰最长时间未被使用的页面：硬件实现：每一个页面设置一个移位寄存器R；访问置1，不访问左移一位；淘汰R最大的页；R位数越多越精确。软件实现（近似算法）：被访问的时候访问位置1，周期性T地置访问位全0；访问位为1，则保留，为0则淘汰。（周期T难以确定，太少0过多，太多1过多）</li>
<li>LFU——淘汰访问最少的页面。访问计数器，淘汰计数器最小值</li>
</ul>
</li>
<li>缺页因素（淘汰算法、页框数（少容易缺页）、页面大小选择（大浪费内存，小浪费页表（内存）、换页频繁）（典型4k，越小越容易缺页（数据太少））、程序编制方法（循环的方式，逐行分配，逐列分配，局部性好，跳转少））</li>
<li>页式系统的不足：页面强行划分（无逻辑）、共享不灵活（要共享整个页）、页内碎片（页没占满页框）</li>
<li>段式（逻辑意义（功能）、段名、长度不定、进程多段组成）（段为单位，段内连续地址，段之间不相邻）。虚拟地址（VA、S、W）。段表SMT（S、L、B）。查询段表由S获取B，MA=B+W。检查越界（W &lt; L）。段的共享</li>
<li>段式系统的不足：连续空间、段的大小受内存限制、可变长的段难以管理</li>
<li>页式系统：一维空间；段式系统：二维空间。（区别：长度、意义、共享、可见性、溢出性）</li>
<li>段页式存储管理：段中划分页。地址构成（段号+段内地址（页号+页偏移））S+P+W。内存按页划分、按页装入。</li>
<li>段页式的映射机构：每一个进程一个段表、每一个段一个页表、段表给出页表的B和L，页表给出页框p’</li>
</ul>
</li>
<li>Intel CPU的内存结构<ul>
<li>实模式：20位（1M存储空间）、16位段地址（4位对齐）、16位偏移地址</li>
<li>保护模式：32位（4G）、支持多任务和任务切换和上下文保护、进程隔离、进程隔离（4g独立封闭空间（保护内核和其他进程））、支持分段机制和分页机制、增加寄存器（段寄存器没有扩展）<ul>
<li>CR0控制寄存器：PE——0实际模式、1保护模式；PG允许分页（一尾一头）</li>
<li>CR2控制寄存器：引发缺页的线性地址</li>
<li>CR3:页目录基址（记录高20位，4K对齐，低12位为0）</li>
</ul>
</li>
<li>逻辑地址（段:偏移）、线性地址（逻辑地址转换得到）、物理地址（未分页=线性地址；分页=页式地址转化）</li>
<li>段机制：逻辑-&gt;线性、分页机制：线性-&gt;物理。由MMU执行地址映射过程</li>
</ul>
</li>
<li>Intel CPU的段机制</li>
</ul>
<h4 id="6-1-主存管理概述"><a href="#6-1-主存管理概述" class="headerlink" title="6.1 主存管理概述"></a>6.1 主存管理概述</h4><ul>
<li>主存分片共享</li>
<li>程序的逻辑组织（一维地址和二维地址）</li>
</ul>
<h4 id="6-2-主存管理功能"><a href="#6-2-主存管理功能" class="headerlink" title="6.2 主存管理功能"></a>6.2 主存管理功能</h4><ul>
<li>虚拟存储器</li>
<li>地址映射</li>
<li>主存分配</li>
<li>存储保护</li>
</ul>
<h4 id="6-3-分区存储管理"><a href="#6-3-分区存储管理" class="headerlink" title="6.3 分区存储管理"></a>6.3 分区存储管理</h4><ul>
<li>动态分区存储管理技术</li>
<li>分区分配机构/</li>
<li>分区分配与安置策略（安置策略的算法首次适应、最佳适应、最坏适应）</li>
<li>碎片问题及拼接技术/</li>
</ul>
<h4 id="6-4-页式存储管理"><a href="#6-4-页式存储管理" class="headerlink" title="6.4 页式存储管理"></a>6.4 页式存储管理</h4><ul>
<li>页式系统应解决的问题<ul>
<li>页式系统的地址映射</li>
<li>请调策略</li>
<li>放置策略</li>
<li>淘汰策略</li>
</ul>
</li>
<li>页式地址变换</li>
<li>请调页面的机制</li>
<li>淘汰机制与策略</li>
<li>几种置换算法（OPT、FIFO、LRU、LFU）</li>
</ul>
<h4 id="6-5-段式及段页式存储管理"><a href="#6-5-段式及段页式存储管理" class="headerlink" title="6.5 段式及段页式存储管理"></a>6.5 段式及段页式存储管理</h4><ul>
<li>段式地址结构</li>
<li>段式地址变换</li>
<li>扩充段表功能</li>
<li>段页式存储管理</li>
</ul>
<h3 id="第七章-设备管理（I-O管理）"><a href="#第七章-设备管理（I-O管理）" class="headerlink" title="第七章 设备管理（I/O管理）"></a>第七章 设备管理（I/O管理）</h3><ul>
<li>缓冲（不同速度，平滑过渡）。硬件缓冲（存储装置）和软件缓冲（临时I/Os护具的一块存储区域）。</li>
<li>输入缓存（请求、送数据、请求数据（后两者同步）、buf空调用，重新填满）、输出缓存（请求、送数据、写满输出（后两者同步）、来不及腾出就输出等待）。共享缓存（get、put、copy）。</li>
<li>缓冲意义（生产者与消费者的差异、协调传输数据大小不一样的设备（分组报文）、数据中间拷贝的缓存、提高并行度）。</li>
<li>双缓冲（双缓冲输入、双缓冲输出、双缓冲同时用于输入输出）、环形缓冲（若干缓冲连接起来变成一个环、in、out、start（输入，判断in、out是否相同，不相同则送入in缓冲区）（输出，判断in、out是否相等，不相同则送入输出out缓冲区，将out移到下一个out））、缓冲池（UNIX系统的缓冲管理）<ul>
<li>UNIX系统的缓冲区管理（缓冲池）<ul>
<li>加快系统响应、增强系统吞吐量、减少对磁盘的I/O操作次数</li>
<li>尽可能多的利用保存在缓冲区中的数据；预先缓存、延迟发送<ul>
<li>先读cache，后调用主存，缓存cache</li>
<li>先写cache、延迟写磁盘到非写不可</li>
</ul>
</li>
<li>缓冲数组+缓冲首部=一个缓冲区；一个缓冲区的数据与辅存上一个磁盘块中的数据对应<ul>
<li>首部=设备号dev+块号blkno（相对于第0块的块号）+状态flag（busy忙、ave有效位、delwr延迟写、write写标志、read读标志、wait等待位）</li>
</ul>
</li>
<li>空闲缓冲队列（av链、双向链表、busy=1）、设备缓冲队列（多个设备多个缓冲队列、b类指针）。实际上av链应该就对应cache</li>
<li>缓冲算法（一个buf被分配用于读/写某设备上的块的时候：busy=1，进入对应b链，不在av链，读写结束后，busy=0，进入av链的队尾，且delwr=1；需要一个空闲缓冲区，LRU算法；有一个标有延迟写的缓冲区到空闲队头的时候：提出I/O，写到对应磁盘块上，空闲队列移除，留在设备缓冲队列，写完后再次进入空闲队列头）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-1-设备管理概述"><a href="#7-1-设备管理概述" class="headerlink" title="7.1 设备管理概述"></a>7.1 设备管理概述</h4><ul>
<li>设备管理的功能</li>
<li>设备的独立性</li>
<li>设备控制块</li>
</ul>
<h4 id="7-2-缓冲技术"><a href="#7-2-缓冲技术" class="headerlink" title="7.2 缓冲技术"></a>7.2 缓冲技术</h4><ul>
<li>缓冲概述</li>
<li>常用的缓冲技术</li>
<li>UNIX系统的缓冲区管理</li>
</ul>
<h4 id="7-3-设备分配"><a href="#7-3-设备分配" class="headerlink" title="7.3 设备分配"></a>7.3 设备分配</h4><p>（为计算机所有的用户程序、活动的进程分配它们所需的外部设备）</p>
<ul>
<li>设备分配概述</li>
<li>独享分配</li>
<li>共享分配</li>
<li>虚拟分配</li>
</ul>
<h4 id="7-4-输入-输出控制"><a href="#7-4-输入-输出控制" class="headerlink" title="7.4 输入/输出控制"></a>7.4 输入/输出控制</h4><p>（软件控制硬件：端口、总线、控制器）</p>
<ul>
<li>输入/输出硬件</li>
<li>输入/输出控制方式</li>
<li>输入/输出子系统</li>
<li>输入/输出控制的例子<br>（以设备处理进程方式为例讨论I/O的控制过程）</li>
</ul>
<h3 id="第八章-文件系统"><a href="#第八章-文件系统" class="headerlink" title="第八章 文件系统"></a>第八章 文件系统</h3><ul>
<li>信息存取的一种的重要组织形式<ul>
<li>若干个信息项（字节、结构化数据）、读写指针；通过文件名存储文件</li>
<li>系统文件、库文件、用户文件</li>
<li>只读文件、读写文件、不保护文件</li>
<li>普通文件、目录文件（记录目录里面的文件列表信息）（文件名、文件存放地址、文件属性）、设备文件（设备当文件管理和使用）</li>
</ul>
</li>
<li>文件的属性：文件类型、操作特性、存取保护等一组信息（存放在目录文件中）<ul>
<li>MS-DOS中，文件属性占目录项的一个字节（最后一位为1只读，倒是第二位为1隐藏）</li>
</ul>
</li>
<li>文件系统：负责管理文件的机构<ul>
<li>功能：文件的创立、撤销、读写、修改、复制、存取控制；管理存放文件的存储设备（空间分配，存取）</li>
<li>目的：让用户以文件名来存取文件</li>
</ul>
</li>
<li>文件结构<ul>
<li>逻辑结构：用户观点<ul>
<li>为用户提供逻辑清晰、使用方便的文件；强调文件信息项的构成方式和用户存取方式</li>
<li>记录式文件：结构化数据——文件中保存记录长度、数量等说明信息，浪费存储空间</li>
<li>流式文件——信息项是字节，文件长度是字节的数量<ul>
<li>无需额外说明信息或者控制信息，节省存储空间</li>
</ul>
</li>
</ul>
</li>
<li>物理结构：系统的观点<ul>
<li>文件在存储设备上或者硬盘上的存储结构，强调合理利用存储空间，缩短I/O存取时间。</li>
</ul>
</li>
</ul>
</li>
<li>文件存取方法<ul>
<li>顺序存取：按照信息项排列一次存取（读写指针）</li>
<li>随机存取：直接存取（指定位置）<ul>
<li>对流式文件或记录为定长的记录式文件容易确定存取位置</li>
<li>记录不定长的记录式文件定位麻烦（从第一条记录开始查询，直到找到要存取的记录为止、建立索引）</li>
</ul>
</li>
</ul>
</li>
<li>文件的物理结构——文件在存储设备上的存储方式（合理利用存储空间，缩短I/O存取时间）<ul>
<li>连续文件<ul>
<li>按照逻辑块连续地放在物理块</li>
<li>文件目录记录文件名、文件长度（块数）、第一个存储的物理块号</li>
<li>特点：建立时候给出文件的最大长度（块数）并登记起始位置（第一个块号）<ul>
<li>简单、支持顺序和随机、顺序存取速度快</li>
<li>文件不易动态增长，预留空间产生浪费（需要重新分配和移动）、不利于文件插入和删除、有外部碎片的问题</li>
</ul>
</li>
</ul>
</li>
<li>索引结构<ul>
<li>文件存放在不连续的存储块中</li>
<li>索引表：逻辑块-&gt;物理存储块</li>
<li>文件目录：文件名-&gt;索引块</li>
<li>特点<ul>
<li>文件=索引区+数据区；</li>
<li>先访问索引再访问数据</li>
<li>支持顺序存取和随机存取</li>
<li>支持文件动态增长、插入、删除 </li>
</ul>
</li>
</ul>
</li>
<li>串联文件<ul>
<li>存放在不连续的储存块中</li>
<li>每个存储块有一个指针，下一个存储块</li>
<li>文件目录：文件名、第一个存储块的块号</li>
<li>特点：适合顺序存取（随机存取困难）、提高磁盘利用率（不存在外部碎片）、利于动态扩充插入和删除。<ul>
<li>缺点：速度慢、不适合随机存取、next指针出错、next之战占用空间</li>
<li>应用：FAT文件系用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>FAT文件系统(文件分配表)<ul>
<li>指针为FFFF代表结束</li>
<li>FAT表：将next的有序集放在FAT表中</li>
<li>文件访问过程<ul>
<li>访问文件目录：<ul>
<li>找首块</li>
<li>访问FAT寻找下一块的块号FAT(i)。i是当前块的块号。</li>
<li>FAT(i)=FFFF文件结束</li>
</ul>
</li>
</ul>
</li>
<li>缺点：<ul>
<li>读文件的时候先读FAT表，影响使用效率</li>
<li>FAT表要占用存储空间：存储块有2^n块，FAT表有2^n个元素，每一项至少需要N位的位宽。</li>
</ul>
</li>
<li>扇区——磁盘上最小的可寻址单元(512B)</li>
<li>簇(cluster)=存储块——最小存取单元，有固定数量的扇区（硬盘容量越大，一个簇的扇区越多）</li>
<li>FAT表中元素数目和簇的数目一样多<ul>
<li>FAT8：N=8，标识2^8=256个簇</li>
<li>FAT12：N=12，标识2^12=4096个簇</li>
<li>FAT16：N=16，标识2^16=64K个簇</li>
<li>FAT32：N=32，标识2^32=4g个簇</li>
</ul>
</li>
<li>磁盘容量=FAT长度<em>簇容量=FAT长度</em>簇扇区数*512B</li>
<li>FAT16系统：以簇为段位管理磁盘，簇是扇区的倍数，是2的次幂，最大64扇区<ul>
<li>扇区512B，簇32KB（64扇区）</li>
<li>FAT表元素宽度2字节</li>
<li>每簇最大64扇区，磁盘分区最大2g。</li>
<li>FAT16格式化的磁盘：启动扇区、FAT1、FAT2、根目录、其他目录和文件</li>
</ul>
</li>
</ul>
</li>
<li>文件存储管理<ul>
<li>功能：记录磁盘使用情况、管理和分撇、回收存储空间<ul>
<li>记录磁盘空闲块——连续空闲区看成一个特殊文件，由多个连续空闲块组成<ul>
<li>空闲文件目录——第一个空闲块号+空闲块个数</li>
<li>空闲块链<ul>
<li>所有空闲块连接在一起</li>
<li>申请时候，链头开始搜索所需空闲块</li>
<li>回收空闲块时，释放的空闲块逐个加在链尾。</li>
</ul>
</li>
<li>位示图——1可用、0占用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>文件目录——文件名、存放地址、文件属性<ul>
<li>目录文件：文件目录以文件的形式存于外存，叫做目录文件</li>
</ul>
</li>
<li>文件的保护（权限）</li>
<li>文件目录操作</li>
<li>典型文件系统</li>
</ul>
<h4 id="8-1-文件系统概述"><a href="#8-1-文件系统概述" class="headerlink" title="8.1 文件系统概述"></a>8.1 文件系统概述</h4><ul>
<li>文件</li>
<li>文件系统</li>
<li>文件的组织</li>
</ul>
<h4 id="8-2-文件的逻辑结构和存取方法"><a href="#8-2-文件的逻辑结构和存取方法" class="headerlink" title="8.2 文件的逻辑结构和存取方法"></a>8.2 文件的逻辑结构和存取方法</h4><ul>
<li>文件的逻辑结构</li>
<li>文件的存取方法</li>
</ul>
<h4 id="8-3-文件的物理结构"><a href="#8-3-文件的物理结构" class="headerlink" title="8.3 文件的物理结构"></a>8.3 文件的物理结构</h4><ul>
<li>连续文件</li>
<li>串联文件</li>
<li>索引文件</li>
<li>文件物理结构比较（连续、串联、索引）</li>
</ul>
<h4 id="8-4-文件存储空间的管理"><a href="#8-4-文件存储空间的管理" class="headerlink" title="8.4 文件存储空间的管理"></a>8.4 文件存储空间的管理</h4><ul>
<li>空闲文件目录</li>
<li>空闲块链</li>
<li>位示图</li>
<li>分配策略</li>
</ul>
<h4 id="8-5-文件目录"><a href="#8-5-文件目录" class="headerlink" title="8.5 文件目录"></a>8.5 文件目录</h4><ul>
<li>文件目录及其内容</li>
<li>一级文件目录及缺点</li>
<li>多级文件目录</li>
</ul>
<h4 id="8-6-共享与安全"><a href="#8-6-共享与安全" class="headerlink" title="8.6 共享与安全"></a>8.6 共享与安全</h4><ul>
<li>文件共享与安全性的关系</li>
<li>存取权限的类型及其验证</li>
<li>用文件路径名加快文件的查找</li>
</ul>
<h4 id="8-7-文件操作与文件备份"><a href="#8-7-文件操作与文件备份" class="headerlink" title="8.7 文件操作与文件备份"></a>8.7 文件操作与文件备份</h4><ul>
<li>文件操作</li>
<li>文件备份</li>
</ul>
<h4 id="8。8-UNIX文件系统的主要结构及实现"><a href="#8。8-UNIX文件系统的主要结构及实现" class="headerlink" title="8。8 UNIX文件系统的主要结构及实现"></a>8。8 UNIX文件系统的主要结构及实现</h4><ul>
<li>UNIX文件系统的特点</li>
<li>UNIX系统的索引文件结构</li>
<li>UNIX系统文件目录结构</li>
<li>UNIX系统的打开文件机构</li>
<li>文件存储器空闲块的管理</li>
<li>UNIX文件系统调用</li>
</ul>
<h3 id="计算机组成原理：总线和I-O"><a href="#计算机组成原理：总线和I-O" class="headerlink" title="计算机组成原理：总线和I/O"></a>计算机组成原理：总线和I/O</h3><h4 id="第七章-系统总线"><a href="#第七章-系统总线" class="headerlink" title="第七章 系统总线"></a>第七章 系统总线</h4><ul>
<li>总线分类<ul>
<li>数量：并行传输总线、串行传输总线</li>
<li>方向：单向、双向</li>
<li>速度：高速、低速</li>
<li>时序：同步、异步</li>
<li>连接部分：片内总线、外部总线、系统总线、I/O总线、处理器总线</li>
</ul>
</li>
<li>按照连接部件分：存储总线（短距离高速总线）、系统总线（最重要、连接存储和I/O）、I/O总线（慢）</li>
<li>总线组成：地址总线（双向）、数据总线（单向）、控制总线（可能双向）、电源和地线</li>
<li>总线性能评价：总线带宽（总线本身能达到的最高传输速率B/s）= 总线宽度*总线传输频率（不是时钟频率）<br><img src="https://s2.ax1x.com/2019/12/11/Qrfmmq.png" alt="Qrfmmq.png"></li>
<li>总线事物：从请求总线到完成总线使用的操作序列<ul>
<li>请求事物、裁决操作、地址传输、数据传输、总线释放</li>
<li>总线传输周期：总线上完成一次总线事物的时间，包括申请、寻址、传输、结束</li>
<li>突发（Brust）传送事物（成组传送）：多个数据阶段，传输过程不释放总线</li>
</ul>
</li>
<li>总线的连接方式：单、双、三<br><img src="https://s2.ax1x.com/2019/12/11/QrfHun.png" alt="QrfHun.png"><ul>
<li>总线结构和系统性能的关系：最大存储容量（单总线内存要为外设保留一些地址）、指令系统（单总线无I/O指令，双总线有）、吞吐量（三总线大于单总线）</li>
</ul>
</li>
<li>信息传送方式<ul>
<li>串行传送、并行传送、分时传送<br><img src="https://s2.ax1x.com/2019/12/11/QrhZCD.png" alt="QrhZCD.png">  </li>
<li>发展趋势：并行传输（距离受限、线间串绕严重）、串行传输（传输距离长、无串扰现象）、随着总线品；v的增加，逐渐转向串行</li>
<li>分时传送：总线复用、连在总线上的部件分时使用总线</li>
</ul>
</li>
<li>总线仲裁（总线使用进行合理分配与管理，部件向控制器发信号、优先级决定顺序）与定时 <ul>
<li>集中式总线仲裁、分布式仲裁<br><img src="https://s2.ax1x.com/2019/12/11/Qr4Yo6.png" alt="Qr4Yo6.png"><br>（计数器定时方式中的log2n指的是地址计数线要用log2n根线）  </li>
<li>传输过程：总线申请（总线仲裁）（设备提出请求，总控确定将下一个使用权分配给谁）、地址阶段（总线寻址）（相关命令，启动相应部件）、数据阶段（数据传输）、结束阶段（撤销总线请求有关信息、让出总线、控制器重新获得使用权）</li>
<li>总线定时<ul>
<li>同步方式（快速设备）：无应答定时，事件在时钟信号前沿，大多数时间只占用一个时钟周期（按照最慢设备定时，适合总线长度短、各功能模块存取时间相差不大情况）<br>给出读控制信号，给出有效数据，时钟来临的时候给出事件</li>
<li>异步方式（慢速设备）：应答定时，后一事件时刻取决于前一事件的出现，应答和互锁机制（总周期长可变，快慢连接在同一总线上）<br>给出读控制信号，存在有效数据，马上给出响应信号</li>
<li>半同步方式（结合同步和异步的特点，同步时钟的控制下进行采样和应答）<br>各操作间的时间间隔可以变化，但是仅允许为公共周期的整数倍</li>
</ul>
</li>
<li>习题<br><img src="https://s2.ax1x.com/2019/12/11/QroJwn.png" alt="QroJwn.png">  </li>
</ul>
</li>
<li>常见总线：ISA、PCI（不受CPU和结构的限制、同步时序、集中式仲裁、兼容性好）、AGP（为了消除外围设备的连接瓶颈、高速图形接口）<ul>
<li>当今的PC（）</li>
<li>下一代技术：PCI-X局部总线（总线瓶颈问题）、Compact PCI局部总线（无源总线底板）、NGIO（下一代总线、I/O总线、处理器和I/O分离）、PCI-EXPRESS（设备间的点对点的串行连接，独占占用）、IndiniBand</li>
<li>USB（通用串行总线）：即插即用、四线电缆，两根用来传输数据的串行通道、两根为下游设备提供电源。采用级联星型拓扑：主机、HUB、功能设备</li>
</ul>
</li>
<li>数据传输方式<ul>
<li>控制传输类型、等时传输类型、中断传输类型（数据量小对时间响应敏感，要求马上响应）、数据块传输类型（外设（打印机、扫描仪、数码相机）和主机间的数据量巨大，USB在满足带宽的情况下才进行块数据的传输）<h4 id="第八章-输入输出原理"><a href="#第八章-输入输出原理" class="headerlink" title="第八章 输入输出原理"></a>第八章 输入输出原理</h4></li>
</ul>
</li>
<li>I/O系统=外部设备+接口部件+总线+管理软件</li>
<li>输入输出过程<ul>
<li>输入过程（地址放置在总线选择设备、等待输入设备数据变为有效、从数据总线读入数据）</li>
<li>输出过程（地址放置在总线选择设备、数据放置在总线上、输出设备认为有效取走数据）</li>
</ul>
</li>
<li>设备定时：直接输入输出（速度极慢或简单的外围设备）、异步定时（慢速或者中速的外围设备）、同步定时（高速外围设备）</li>
<li>输入输出方式：无条件I/O(输入输出时刻准备着)、程序控制I/O、中断I/O、DMA、通道方式、I/O处理机<ul>
<li>程序控制I/O（程序查询方式）：启动设备、反复询问查询设备状态、传输单个数据、重复上述步骤直到传输完毕。（反复查询设别状态占用较多CPU时间，系统效率低，CPU占用率取决于查询频率）</li>
<li>程序I/O（程序中断过程）：启动设备、挂起当前进程、调度主程序运行，外设准备数据、数据准备完成，外设以中断方式主动告知CPU、COU中断主程序，转向设备中断服务子程序、中断服务（一般传输一个字），唤醒等待进程、返回主程序。（提高CPU的使用效率：主动告知避免反复查询，CPU占用：中断服务子程序运行时间+中断开销、适合随机出现的服务、需要专门的硬件）</li>
</ul>
</li>
<li>直接访问DMA方式<ul>
<li>中断不足：一次中断少量数据，CPU开销较大、不适合成组交换。</li>
<li>使用硬件执行I/O交换：准备阶段和结束阶段要占用CPU、传输阶段DMAC从CPU接管总线，数据交换无需CPU干预，内存和外设交换，节约了中断开销。（这也需要更多的硬件）</li>
</ul>
</li>
<li>通道访问：DMA的进一步发展——数据的传输方向、内存起始地址、传送的数据块长度都由独立于CPU的通道进行控制：有特殊处理功能的处理器IOP、外设统一管理和DMA操作、更多硬件代价、提高CPU的工作效率（通道执行通道程序完成I/O，由通道指令组成）</li>
<li>中断<ul>
<li>目的：避免重复查询外设状态，主机和外设并行工作、工作效率提高</li>
<li>内中断（自愿中断——指令中断、强迫中断——硬件故障，软件出错）、外中断（强迫中断）——可屏蔽中断、不可屏蔽中断</li>
<li>子程序和中断服务子程序——子程序在特定位置显式调用、后者随机调用、现场不同</li>
<li>中断优先级问题、中断仲裁、中断嵌套（注意：执行某设备中断服务子程序，CPU的优先级集就和该设备的优先级一样）（仲裁方式：链式查询、独立请求、分组链式结构）（二维优先级）</li>
<li>中断屏蔽：响应优先级（硬件线路已经规定设备优先级）、处理优先级（实际处理的先后次序，如果不使用屏蔽，响应次序=处理次序）、中断屏蔽技术动态改变各个设备所处于的优先级<ul>
<li>中断请求寄存器IR（1表示响应外设发出了中断请求）</li>
<li>中断屏蔽寄存器INM（1为屏蔽，每个设备都有自己的中断屏蔽字，不可屏蔽中断不受INM的控制）</li>
<li>中断允许触发器IE</li>
<li>屏蔽码：控制设备接口的屏蔽触发器，改变处理次序（运行某个设备的时候载入对应的屏蔽码）：<br><img src="https://s2.ax1x.com/2019/12/11/Qr659A.png" alt="Qr659A.png"></li>
<li>单级中断与多级中断<ul>
<li>单级中断：所有一个级，离CPU近的优先级高，CPU处理某个中断时候，不响应其他中断。</li>
<li>多级中断：中断嵌套+优先级高的中断可以打断优先级低的</li>
</ul>
</li>
<li>中断识别<ul>
<li>向量中断：硬件，查地址表获得服务程序入口。中断向量法：（向量表中记录A的入口AA，地址为AA，PUSH，执行中断处理程序，执行完后IRET）</li>
<li>非向量中断：查询程序。（保护寄存器，查询是否R=1，执行服务程序，恢复寄存器，中断返回）<br><img src="https://s2.ax1x.com/2019/12/11/Qrg6oD.png" alt="Qrg6oD.png"></li>
</ul>
</li>
<li>习题<br><img src="https://s2.ax1x.com/2019/12/11/Qrc4VU.png" alt="Qrc4VU.png"><br><img src="https://s2.ax1x.com/2019/12/11/QrcWrV.png" alt="QrcWrV.png"></li>
<li>中断响应的条件：IE允许，INM=0，无更高优先级的DMA请求，指令已经执行完最后一个机器周期</li>
<li>保护现场，恢复现场（寄存器，EPC，屏蔽字，缺页中的断点）、中断过程由软硬件结合完成。</li>
</ul>
</li>
</ul>
</li>
<li>DMA方式<ul>
<li>处理DMA控制的时候的CPU冲突和资源冲突<ul>
<li>停用CPU使用内存：DMA传输CPU停止使用内存、数据结束DMA交还使用权、DMA传输CPU等待（外设传输两个数据的时间间隔大于存储周期，内存未被充分使用）</li>
<li>DMA和CPU交替使用主存：CPU工作周期分为DMA访问内存、CPU访问内存两部分（省去了主存使用权的移交过程）</li>
<li>周期挪用法：DMA访内的时候，CPU暂停一个或者多个存储周期，一个数据传送结束后，CPU继续运行。CPU现场没有变动，仅延缓了指令的执行，如果发生了内存冲突，则DMA优先访问。</li>
</ul>
</li>
<li>操作过程：CPU向DMA发送必要的参数、传送一批数据（每传送一个数据，一个DMA请求）（数据缓冲地址指针加一、计数器减一）、正常结束（数据传送完毕），非正常结束（DMA传输故障），结束阶段DMA向主机发出中断请求，CPU执行中断服务程序（查询DMA接口状态，根据状态进行不同处理）一个数据块的传递过程如下：<br><a href="https://imgse.com/i/QrapdI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/11/QrapdI.md.png" alt="QrapdI.md.png"></a></li>
<li>有关于DMA的习题如下：<br><img src="https://s2.ax1x.com/2019/12/11/QraZLj.png" alt="QraZLj.png"><br><img src="https://s2.ax1x.com/2019/12/11/QraQYV.png" alt="QraQYV.png"></li>
</ul>
</li>
<li>通道方式<ul>
<li>找出一种技术，使DMA技术被更多设备共享（节省DMA初始化的时间）</li>
<li>设置专用的输入输出处理机（通道），分担输入输出管理的全部或者大部分工作。</li>
<li>层次性的I/O：一个主机可以连接多个通道、一个通道可以管理多个设备控制器、一个设备控制器可以控制多个设备<ul>
<li>字节多路通道（以字节为段位进行传输、宏观上并行）<br><img src="https://s2.ax1x.com/2019/12/11/Qrd84P.png" alt="Qrd84P.png">  <ul>
<li>适合慢速设备不适合高速设备，高速设备传输两个字节间的空闲很短</li>
</ul>
</li>
<li>选择通道（能连接多个设备但是不能同时工作，只有一个自通道适合大批量数据的高速传送，制定数据传输玩采薇其他设备服务）<br><img src="https://s2.ax1x.com/2019/12/11/QrdTC6.png" alt="QrdTC6.png"></li>
<li>数组多路通道（硬盘启动后的磁盘等待时间很长，利用这段时间，将字节多路和选择通道折中，称为数组多路通道）（多个设备以数据组（快）为单位交叉使用通道，设备占用通道时，连续传送一组数据没然后让出通道使用权）（一次只能与和一个设备进行传输型工作，轮转使用）<ul>
<li>传输率高，硬件复杂度高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: Waylon Ding</p><p>原文链接: <a href="/blog/www.waylonding.cn/blog/2019/11/19/OpeartingSystem-Notes/">www.waylonding.cn/blog/2019/11/19/OpeartingSystem-Notes/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/blog/tags/Operating-System/">Operating System</a><a href="/blog/tags/System-Network/">System &amp; Network</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/blog/2019/11/19/ComputerNetwork-Review-Notes/" class="next">ComputerNetwork Notes</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机操作系统学习-amp-复习笔记"><span class="toc-text">计算机操作系统学习&amp;复习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一章-绪论"><span class="toc-text">第一章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-操作系统在计算机中的地位"><span class="toc-text">1.1 操作系统在计算机中的地位 *</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-操作系统的形成和发展（多道程序、分时技术）"><span class="toc-text">1.2 操作系统的形成和发展（多道程序、分时技术）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）"><span class="toc-text">1.3 操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-操作系统的基本类型"><span class="toc-text">1.4 操作系统的基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-操作系统采用的技术"><span class="toc-text">1.5 操作系统采用的技术 *</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二章-操作系统的结构和硬件支持"><span class="toc-text">第二章 操作系统的结构和硬件支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-操作系统虚拟机"><span class="toc-text">2.1 操作系统虚拟机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-操作系统组织结构"><span class="toc-text">2.2 操作系统组织结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-处理机的态"><span class="toc-text">2.3 处理机的态 *</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-中断及其处理"><span class="toc-text">2.4 中断及其处理 *</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三章-操作系统的用户接口"><span class="toc-text">第三章 操作系统的用户接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-用户工作环境"><span class="toc-text">3.1 用户工作环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-操作系统的用户接口及分类"><span class="toc-text">3.2 操作系统的用户接口及分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-系统功能调用及其实现技术"><span class="toc-text">3.3 系统功能调用及其实现技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-linux系统调用功能的实现"><span class="toc-text">3.5 linux系统调用功能的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第四章-进程及进程管理"><span class="toc-text">第四章 进程及进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-并发进程及其特点"><span class="toc-text">4.1 并发进程及其特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-进程定义"><span class="toc-text">4.2.1 进程定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-进程状态及其变迁"><span class="toc-text">4.2.2 进程状态及其变迁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-进程控制块及进程队列"><span class="toc-text">4.2.3 进程控制块及进程队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-进程控制"><span class="toc-text">4.3 进程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-进程互斥的概念"><span class="toc-text">4.4.2 进程互斥的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-进程同步的概念"><span class="toc-text">4.4.3 进程同步的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-同步机构"><span class="toc-text">4.5 同步机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-锁、上锁、开锁"><span class="toc-text">4.5.1 锁、上锁、开锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-信号等的PV操作"><span class="toc-text">4.5.2 信号等的PV操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-进程互斥与同步的实现"><span class="toc-text">4.6 进程互斥与同步的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-用上锁原语和开锁原语实现进程互斥"><span class="toc-text">4.6.1 用上锁原语和开锁原语实现进程互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-2-用信号灯的P、V操作实现互斥"><span class="toc-text">4.6.2 用信号灯的P、V操作实现互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-3-进程同步的实现"><span class="toc-text">4.6.3 进程同步的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-4-生产者和消费者"><span class="toc-text">4.6.4 生产者和消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-进程通信-IPC"><span class="toc-text">4.7 进程通信(IPC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-2-进程通信的方式"><span class="toc-text">4.7.2 进程通信的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-线程的概念及特点"><span class="toc-text">4.8 线程的概念及特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-操作系统的并发机制实例"><span class="toc-text">4.9 操作系统的并发机制实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-10-进程调度"><span class="toc-text">4.10 进程调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第五章-资源分配与调度"><span class="toc-text">第五章 资源分配与调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-资源管理概述"><span class="toc-text">5.1 资源管理概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-资源管理的机制和策略"><span class="toc-text">5.2 资源管理的机制和策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-死锁"><span class="toc-text">5.3 死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第六章-主存管理"><span class="toc-text">第六章 主存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-主存管理概述"><span class="toc-text">6.1 主存管理概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-主存管理功能"><span class="toc-text">6.2 主存管理功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-分区存储管理"><span class="toc-text">6.3 分区存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-页式存储管理"><span class="toc-text">6.4 页式存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-段式及段页式存储管理"><span class="toc-text">6.5 段式及段页式存储管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第七章-设备管理（I-O管理）"><span class="toc-text">第七章 设备管理（I/O管理）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-设备管理概述"><span class="toc-text">7.1 设备管理概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-缓冲技术"><span class="toc-text">7.2 缓冲技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-设备分配"><span class="toc-text">7.3 设备分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-输入-输出控制"><span class="toc-text">7.4 输入/输出控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第八章-文件系统"><span class="toc-text">第八章 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-文件系统概述"><span class="toc-text">8.1 文件系统概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-文件的逻辑结构和存取方法"><span class="toc-text">8.2 文件的逻辑结构和存取方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-文件的物理结构"><span class="toc-text">8.3 文件的物理结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-文件存储空间的管理"><span class="toc-text">8.4 文件存储空间的管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-文件目录"><span class="toc-text">8.5 文件目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-共享与安全"><span class="toc-text">8.6 共享与安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-文件操作与文件备份"><span class="toc-text">8.7 文件操作与文件备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8。8-UNIX文件系统的主要结构及实现"><span class="toc-text">8。8 UNIX文件系统的主要结构及实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算机组成原理：总线和I-O"><span class="toc-text">计算机组成原理：总线和I/O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第七章-系统总线"><span class="toc-text">第七章 系统总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第八章-输入输出原理"><span class="toc-text">第八章 输入输出原理</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2019/11/19/OpeartingSystem-Notes/">OpeartingSystem Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/11/19/ComputerNetwork-Review-Notes/">ComputerNetwork Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/11/18/hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%A9%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0/">Build My Personal Blog with Github and Hexo</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/CS-Courses/">CS Courses</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/">hexo搭建属于自己的博客</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/hexo%E6%8A%80%E6%9C%AF/">hexo技术</a><span class="category-list-count">1</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/hexo%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF-markdown%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">hexo相关技术 - markdown的使用</a> <a href="/blog/tags/Operating-System/" style="font-size: 15px;">Operating System</a> <a href="/blog/tags/System-Network/" style="font-size: 15px;">System & Network</a> <a href="/blog/tags/Computer-Network/" style="font-size: 15px;">Computer Network</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/">2019</a><span class="archive-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/blog/baidusitemap.xml">网站地图</a> |  <a href="/blog/atom.xml">订阅本站</a> |  <a href="/blog/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/blog/." rel="nofollow">Waylon Ding.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/blog/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/blog/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/blog/share/css/share.css"><script type="text/javascript" src="/blog/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/blog/share/js/qrcode.js" charset="utf-8"></script></body></html>