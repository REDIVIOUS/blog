<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Waylon Ding's blog."><meta name="keywords" content="计算机系统结构, 外语, 音乐"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/blog/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/blog/favicon.ico"><link rel="bookmark" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/blog/atom.xml"><title>OpeartingSystem Notes | REDIVIOUS‘s Blog</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">OpeartingSystem Notes</h1><a id="logo" href="/blog/.">REDIVIOUS‘s Blog</a><p class="description">世界那么大，我想去看看</p></div><div id="nav-menu"><a href="/blog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">OpeartingSystem Notes</h1><div class="post-meta"><a href="/blog/2019/11/19/OpeartingSystem-Notes/#comments" class="comment-count"></a><p><span class="date">Nov 19, 2019</span><span><a href="/blog/categories/CS-Courses/" class="category">CS Courses</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="计算机操作系统学习-amp-复习笔记"><a href="#计算机操作系统学习-amp-复习笔记" class="headerlink" title="计算机操作系统学习&amp;复习笔记"></a>计算机操作系统学习&amp;复习笔记</h2><p>参考书目：计算机操作系统（人民邮电出版社）</p>
<h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-1-操作系统在计算机中的地位"><a href="#1-1-操作系统在计算机中的地位" class="headerlink" title="1.1 操作系统在计算机中的地位 *"></a>1.1 操作系统在计算机中的地位 *</h4><ul>
<li>操作系统是什么；<ul>
<li>是核心软件</li>
<li>负责软件硬件资源分配与调用</li>
<li>控制、协调并发活动</li>
<li>提供用户接口、为用户良好工作环境</li>
</ul>
</li>
<li>操作系统特点<br>位置：从里到往外裸机-&gt;操作系统-&gt;应用软件<ul>
<li>内容庞杂、涉及面广<ul>
<li>控制管理硬件、软件；控制程序进行</li>
<li>为用户提供良好接口</li>
</ul>
</li>
<li>实践性强</li>
<li>技术发展快<br>Unix和linux采取优先调度。<br>linux调度方法：140队列，140位位图，扫描位图（不怎么需要时间），高优先级入列</li>
</ul>
</li>
<li>OS和各层次的关系<ul>
<li>硬件：控制CPU、访问存储、驱动设备、中断</li>
<li>软件：控制管理、提供界面和服务</li>
</ul>
</li>
<li>各层次对OS的影响<ul>
<li>硬件约束：用串行（CPU）实现并行（操作系统）</li>
<li>上层用户需求：实时和分时，界面友好</li>
</ul>
</li>
</ul>
<h4 id="1-5-操作系统采用的技术"><a href="#1-5-操作系统采用的技术" class="headerlink" title="1.5 操作系统采用的技术 *"></a>1.5 操作系统采用的技术 *</h4><ul>
<li>并行处理技术<ul>
<li>并行处理：多个部件、为整体任务同时执行。</li>
<li>多用户、多任务同时执行。<br>为描述任务，引入进程的概念。进程的状态及控制（任务状态）、进程同步与互斥（多任务协调）、进程调度（CPU控制权的分配等等）</li>
<li>系统资源共享<br>处理机共享（处理机分配调度）、存储器共享（存储分配、保护、虚拟存储与地址映射）、设备共享（设备分配驱动以及中断）、信息共享（文件结构、共享以及存取方法）</li>
</ul>
</li>
<li>虚拟技术<ul>
<li>用户：逻辑视图。操作系统：物理视图。</li>
<li>物理（硬件）资源（系统）：CPU、主存、打印机、磁盘等。</li>
<li>逻辑（软件）资源（用户）：CPU1、CPU2（CPU分时）；虚拟主存1、虚拟主存2（主存的主存管理）；打印机1、打印机2（虚拟打印技术）（网络上有很多资源需要打印机）</li>
</ul>
</li>
</ul>
<h3 id="第二章-操作系统的结构和硬件支持"><a href="#第二章-操作系统的结构和硬件支持" class="headerlink" title="第二章 操作系统的结构和硬件支持"></a>第二章 操作系统的结构和硬件支持</h3><h4 id="2-3-处理机的态"><a href="#2-3-处理机的态" class="headerlink" title="2.3 处理机的态 *"></a>2.3 处理机的态 *</h4><ul>
<li>系统中两类程序：管理程序和用户程序：<ul>
<li>管理程序：管理系统资源、控制程序运行</li>
<li>用户程序: 使用资源、提出申请；被控制</li>
</ul>
</li>
<li>区分处理机状态的目的是为了保护操作系统。不保护就有可能瘫痪。</li>
<li>处理机的态：中央处理机的工作状态（取决于当前处理机运行的程序）<ul>
<li>管态：管理程序执行的态。称特权级。使用全部指令和资源。<ul>
<li>有的细分为核心态和管态</li>
</ul>
</li>
<li>用户态：用户程序执行的态。只允许访问自己的存储区域，禁止特权指令，不能直接取用资源与改变机器的态。</li>
</ul>
</li>
<li>管态和用户态区别：<ul>
<li>管态<ul>
<li>操作系统程序执行</li>
<li>使用全部指令</li>
<li>使用全部系统资源（包括整个存储空间）</li>
</ul>
</li>
<li>用户态<ul>
<li>用户程序执行</li>
<li>禁用特权指令</li>
<li>只允许用户程序访问自己的存储区域</li>
</ul>
</li>
<li>特权指令集<ul>
<li>涉及到外部设备的输入/输出命令</li>
<li>修改特殊寄存器的指令</li>
<li>改变机器状态的指令</li>
</ul>
</li>
</ul>
</li>
<li>实现处理机分态的硬件支持<ul>
<li>在状态寄存器中设置状态位：<ul>
<li>一位：用户态、管态</li>
<li>两位：核态、管态、用户态<ul>
<li>核态和管态都是操作系统程序执行时处理机的状态。核态：操作系统核心程序执行时的状态，权限比管态高，可以执行所有机器指令（改变机器状态）。</li>
</ul>
</li>
<li>Unix（linux）系统中状态的分类<ul>
<li>00-核态；01-管态；11-用户态</li>
</ul>
</li>
<li>80x86微处理器中状态位：（CPU特权级）DPL=0（核态）；DPL=3（用户态）</li>
</ul>
</li>
<li>程序性中断<ul>
<li>程序有越权操作时候发生的中断称为程序性中断。</li>
<li>中断机制负责使其陷入操作系统，用户态转换为管态，操作系统管理程序获得控制权开始执行。</li>
</ul>
</li>
<li>什么时候中断<br>用户态下超出了权限时保护操作系统：<ul>
<li>当用户执行了一条特权指令</li>
<li>当用户程序试图访问<code>操作系统数据区</code>或<code>其他程序占用的区域</code>时。<h4 id="2-4-中断及其处理"><a href="#2-4-中断及其处理" class="headerlink" title="2.4 中断及其处理 *"></a>2.4 中断及其处理 *</h4></li>
</ul>
</li>
</ul>
</li>
<li>中断：某个事件（掉电、定点加法溢出，I/O结束）发生时，停止现行程序执行，转而处理该事件的程序对事件进行处理，处理完毕返回执行原来程序。</li>
<li>中断类型：<ul>
<li>I/O中断</li>
<li>外中断：时钟、操作员控制台中断、通信中断</li>
<li>机器故障中断：电源、主存取指错等。</li>
<li>程序性中断：定点溢出、用户态下使用核态指令、非法操作</li>
<li>访管中断：对操作系统提出某种需求的时所发出的中断。</li>
</ul>
</li>
<li>中断方式：<ul>
<li>强迫性中断：除了访管中断</li>
<li>自愿中断：访管中断</li>
</ul>
</li>
<li>中断来源<ul>
<li>中断：由处理机外部事件引起的中断：时钟、磁盘、终端</li>
<li>俘获：由处理机内部事件引起的中断：非法指令、地址越界、浮点溢出、trap指令</li>
</ul>
</li>
<li>中断响应及硬件支持：<ul>
<li>保护现场、恢复现场<ul>
<li>现场： 后继指令所在主存的单元号、程序运行所处的状态、指令执行情况、程序执行的中间结果</li>
<li>保护现场：现场存入主存。</li>
<li>恢复现场：把保护的现场重新送到各个特殊寄存器</li>
</ul>
</li>
<li>中断响应：中央处理器发出请求-&gt;中止现有程序执行-&gt;引出中断处理程序的过程<ul>
<li>系统堆栈：存入指令计数器(PC)、处理机状态寄存器(PS) 的内容 (一般先PS后PC？)（硬件层面）</li>
<li>中断向量表：存入中断程序地址（地址内存从0开始）</li>
<li>中断响应实质：交换指令地址及处理机的状态信息</li>
</ul>
</li>
</ul>
</li>
<li>软件的中断处理过程<ul>
<li>中断进入</li>
<li>step1 保护中断程序的现场（没有保存的寄存器）</li>
<li>step2 进入相应的中断服务例程。</li>
<li>step3 恢复中断程序的现场。</li>
</ul>
</li>
</ul>
<h3 id="第三章-操作系统的用户接口"><a href="#第三章-操作系统的用户接口" class="headerlink" title="第三章 操作系统的用户接口"></a>第三章 操作系统的用户接口</h3><h4 id="3-2-操作系统的用户接口及分类"><a href="#3-2-操作系统的用户接口及分类" class="headerlink" title="3.2 操作系统的用户接口及分类"></a>3.2 操作系统的用户接口及分类</h4><ul>
<li>用户接口/用户界面：用户控制计算机的手段<ul>
<li>操作接口/命令界面：键盘命令（分时操作系统）（MS-DOS、unix/linux）、图形界面（windows）、作业控制语言（批处理系统）<br>组织工作流程，控制程序运行（C语言编写编译链接等）</li>
<li>程序接口：系统功能调用<br>程序运行时，使用系统功能调用来请求操作系统的服务。<h4 id="3-3-系统功能调用及其实现技术"><a href="#3-3-系统功能调用及其实现技术" class="headerlink" title="3.3 系统功能调用及其实现技术"></a>3.3 系统功能调用及其实现技术</h4></li>
</ul>
</li>
<li>硬件支持：由用户态到管态<ul>
<li>访管指令/自愿进管指令：svc n（功能号）</li>
<li>访管中断：正在运行的程序对于操作系统的某种需求。</li>
<li>系统功能调用：借助访管指令，取值n（特定功能），硬件进入，软件方法完成。</li>
</ul>
</li>
<li>系统调用实现<br>用户程序（svc i）、访管中断处理程序（按照i转移）、例行子程序入口地址表、例行自程序<h4 id="3-5-linux系统调用功能的实现"><a href="#3-5-linux系统调用功能的实现" class="headerlink" title="3.5 linux系统调用功能的实现"></a>3.5 linux系统调用功能的实现</h4></li>
<li>linux系统功能调用的进入<ul>
<li>异常处理（系统调用通过异常类型实现）、软中断（int 0x80）、状态转换（从用户态到核心态，执行自陷处理程序（防管中断处理程序））</li>
</ul>
</li>
<li>getuid系统调用过程<br>  用户程序(getuid())-&gt;标准C库(内含int0x80)-&gt;系统调用处理程序-&gt;内核例程（系统服务例程）</li>
<li>linux系统调用的进入和返回<ul>
<li>软中断（自陷指令/访管指令）int 0x80</li>
<li>发生中断（自陷/访管中断）</li>
<li>处理机用户态-&gt;内核态（内核状态的改变）</li>
<li>system_call()开始执行系统调用处理程序（系统功能调用的执行）</li>
<li>处理完毕后，iret返回到用户态</li>
</ul>
</li>
<li>Linux系统功能调用的实现机制<ul>
<li>硬件支持： 增加一个软中断指令、自陷</li>
<li>软件：系统调用号、系统调用表、系统服务例程、系统调用处理程序</li>
</ul>
</li>
<li>增加一个新的系统调用<ul>
<li>增加一个新的系统服务例程</li>
<li>增加一个新的系统调用号</li>
<li>在系统调用表中增加一项（新例程的地址）</li>
<li>将新的系统服务例程加入到系统中（系统重构）</li>
</ul>
</li>
<li>系统调用号<ul>
<li>linux中每个系统调用被赋予一个唯一的系统调用号<br>格式：#define _NR_fork 2</li>
</ul>
</li>
<li>系统调用表：记录了内核中所有已经注册过的系统调用、系统调用的函数指针（函数指针数组）（保存所有系统调用的函数指针）</li>
<li>系统调用的处理过程<ul>
<li>宏SAVE_ALL保护现场</li>
<li>正确性检查</li>
<li>eax中包含系统调用号，调用对应的服务例程</li>
<li>服务流程结束时，RESTORE_ALL恢复寄存器</li>
<li>iret返回</li>
</ul>
</li>
</ul>
<h3 id="第四章-进程及进程管理"><a href="#第四章-进程及进程管理" class="headerlink" title="第四章 进程及进程管理"></a>第四章 进程及进程管理</h3><h4 id="4-1-并发进程及其特点"><a href="#4-1-并发进程及其特点" class="headerlink" title="4.1 并发进程及其特点"></a>4.1 并发进程及其特点</h4><ul>
<li>程序的顺序执行：一个程序的一次执行过程称为一个计算，一个计算的若干操作必须按照严格的先后顺序来执行。<ul>
<li>顺序性：按照严格顺序执行</li>
<li>封闭性：一旦开始执行，不受外界因素影响</li>
<li>可再现性：执行的结果与他的执行速度无关（时间无关），与初始条件有关。</li>
</ul>
</li>
<li>并发程序<ul>
<li>定义：若干个程序同时在系统中运行，程序在时间上时重叠的（一个没做完，另外一个已经开始）</li>
<li>并行语句记号<br>cobegin<br>  S1，S2，S3…<br>coend</li>
</ul>
</li>
<li>并发程序的特点<ul>
<li>失去了封闭性和可再现性<br>一个程序的执行可以改变另一个程序的变量，后者的输出依赖于各程序执行的相对速度，失去了程序的封闭性的特点。</li>
<li>解决进程的同步问题（与时间有关的错误）</li>
<li>程序与计算不再一一对应：一个程序对应多个计算</li>
<li>程序并发执行的相互制约：间接的相互制约：资源共享、直接的相互制约：公共变量</li>
</ul>
</li>
</ul>
<h4 id="4-2-1-进程定义"><a href="#4-2-1-进程定义" class="headerlink" title="4.2.1 进程定义"></a>4.2.1 进程定义</h4><ul>
<li>运行（获得cpu）-&gt;暂停（保留状态）-&gt;运行（获得cpu）</li>
<li>定义：在给定的活动空间和初始环境下，在一个处理机上的执行过程。</li>
<li>与程序的区别<ul>
<li>程序静态（C语言代码不变）、进程动态（一次执行过程）</li>
<li>进程是一个独立运行的活动单位</li>
<li>竞争系统资源的基本单位（cpu，I/O）</li>
<li>一个程序可以对应多个进程，一个进程至少包含一个程序。<h4 id="4-2-2-进程状态及其变迁"><a href="#4-2-2-进程状态及其变迁" class="headerlink" title="4.2.2 进程状态及其变迁"></a>4.2.2 进程状态及其变迁</h4></li>
</ul>
</li>
<li>进程的基本状态<ul>
<li>运行状态（占用cpu）：已经获得运行所必须的资源，程序正在处理机上执行 （单cpu运行状态只能有一个）</li>
<li>等待状态（输入输出）：程序等待某一事件等待发生（等待外部传输完成等等）而暂时停止执行（这时即使给它cpu的控制权也无法执行）</li>
<li>就绪状态：进程已经获得除了CPU之外的运行所必须的资源，一旦获得了CPU控制权，就可以立即运行。</li>
</ul>
</li>
<li>进程状态的变迁：（基本状态变迁只有前三个）<ul>
<li>运行-&gt;等待：服务请求（I/O）</li>
<li>等待-&gt;就绪：（I/O是完成）服务完成，事件来到</li>
<li>就绪-&gt;运行：进程调度（CPU空出）</li>
<li>等待-&gt;运行：不可能</li>
<li>运行-&gt;就绪：时间片到了（分时系统中）</li>
<li>就绪-&gt;等待：有需求的系统提供（一般没有）</li>
</ul>
</li>
<li>linux系统状态变迁<ul>
<li>新进程-&gt;就绪：创建</li>
<li>就绪-&gt;运行：进程调度</li>
<li>运行-&gt;就绪：被抢占</li>
<li>等待-&gt;就绪：等待的事情发生</li>
<li>运行-&gt;等待：等待某事件</li>
<li>运行-&gt;终止：进程完成</li>
</ul>
</li>
<li>进程状态变迁的驱动及条件<br>见作业习题<h4 id="4-2-3-进程控制块及进程队列"><a href="#4-2-3-进程控制块及进程队列" class="headerlink" title="4.2.3 进程控制块及进程队列"></a>4.2.3 进程控制块及进程队列</h4></li>
<li>进程控制块：描述：1、进程与其他进程；2、系统资源的关系；以及3、进程在各个不同时期所处状态；的数据结构。称为进程控制块PCB。</li>
<li>程序与数据：描述进程“本身”所应该完成的功能</li>
<li>PCB：进程的动态特征，该进程与“其他进程”和“系统资源”的关系。</li>
<li>进程控制块（内容）：<ul>
<li>进程标识符：进程符号或者内部id号</li>
<li>进程当前状态：本进程目前处于何种状态。</li>
<li>当前队列指针：登记了处于同一状态的“下一个进程的PCB地址”。</li>
<li>进程优先级：进程提要求CPU的紧迫程度。</li>
<li>通信信息：进程间通信记录的有关信息。</li>
<li>家族联系：本进程和家族的联系（子进程、父进程等等）</li>
</ul>
</li>
<li>进程控制块的组织————进程队列结构<ul>
<li>就绪状态队列：ready_q_start —— 一个或者（最多140个）</li>
<li>等待打印机队列：wait_lpt_q_start —— 多个（等待打印机、磁盘、键盘等）</li>
<li>运行指针：running ——一个</li>
</ul>
</li>
<li>进程控制块的作用：<ul>
<li>修改PCB表项<br>  系统通过修改PCB表项的内容，‘动态记录’该进程‘当前的状态’和‘占有资源’的情况，以便实施有效的管理。</li>
<li>在进程队列中移动PCB结构<br>  进程控制和进程调度的功能实现，是在相应的进程队列中移动相关的PCB结构。 <h4 id="4-3-进程控制"><a href="#4-3-进程控制" class="headerlink" title="4.3 进程控制"></a>4.3 进程控制</h4></li>
</ul>
</li>
<li>进程状态的变化<ul>
<li>无 -（创建）- 有 -（撤销）- 消亡</li>
<li>运行 -（等待）- 等待</li>
<li>就绪 -（唤醒）- 等待</li>
<li>创建原语、撤销原语、等待原语、唤醒原语 （原语：原子操作（系统功能调用））</li>
</ul>
</li>
<li>进程创建<ul>
<li>进程创建原语——create（fork）</li>
<li>进程创建原语的功能：创建一个具有指定标识符的过程，建立进程的PCB结构</li>
<li>进程创建原语的实现：PCB池</li>
</ul>
</li>
<li>进程创建原语——create（fork）<ul>
<li>申请一个空的PCB结构</li>
<li>无空位报错，有则将入口信息填入PCB的对应项。</li>
<li>将PCB入就绪队列。</li>
<li>返回进程pid（PCB池中的位置）。</li>
</ul>
</li>
<li>进程撤销——kill/exit（退出自己）（一个，一组，自己）<ul>
<li>运行指针获得当前进程的pid</li>
<li>释放本进程所占用的资源给父进程</li>
<li>释放PCB结构</li>
<li>转进程调度</li>
</ul>
</li>
<li>进程等待原语——susp<ul>
<li>保护CPU现场到PCB结构中</li>
<li>置该进程为“等待”状态</li>
<li>将其PCB结构插入到相应等待队列</li>
<li>转进程调度</li>
</ul>
</li>
<li>进程唤醒原语——wakeup<ul>
<li>找到该等待队列</li>
<li>将该结构移出等待队列</li>
<li>将该进程置为就绪状态，PCB插入就绪队列</li>
<li>返回刚刚被打断的进程</li>
</ul>
</li>
<li>进程控制功能及其在进程队列上的操作<h4 id="4-4-2-进程互斥的概念"><a href="#4-4-2-进程互斥的概念" class="headerlink" title="4.4.2 进程互斥的概念"></a>4.4.2 进程互斥的概念</h4></li>
<li>临界资源：系统中有多个进程，共享各种资源，然而有些资源一次只能为一个进程所用。<ul>
<li>系统资源打印机，A、B共享一台打印机。若任意使用，两进程的输出结果交织在一起。解决方法：A使用之前先提出申请，然后独占，B只有在A释放之后系统才能分给B。</li>
<li>进程共享公共变量。</li>
</ul>
</li>
<li>临界区：</li>
<li>互斥：操作系统中。某一进程正在访问某一存储区域时，就不允许其他进程“读出来”或者“修改”该存储区的内容。<h4 id="4-4-3-进程同步的概念"><a href="#4-4-3-进程同步的概念" class="headerlink" title="4.4.3 进程同步的概念"></a>4.4.3 进程同步的概念</h4></li>
<li>并发进程在一些关键点上可能需要相互等待与互通消息，这种相互制约的等待与互通消息称为进程同步</li>
<li>共享缓冲区的计算进程与打印进程的同步<ul>
<li>计算进程cp和打印进程iop公用一个单缓冲</li>
<li>计算的速度快，输出的速度慢。丢失信息</li>
<li>计算的速度慢，输出的速度快。重复打印<h4 id="4-5-同步机构"><a href="#4-5-同步机构" class="headerlink" title="4.5 同步机构"></a>4.5 同步机构</h4><h4 id="4-5-1-锁、上锁、开锁"><a href="#4-5-1-锁、上锁、开锁" class="headerlink" title="4.5.1 锁、上锁、开锁"></a>4.5.1 锁、上锁、开锁</h4></li>
</ul>
</li>
<li>每一个共享的临界资源：一个锁单位：0可用，1不可用。</li>
<li>上锁操作：<ul>
<li>检测锁位的值（0or1）</li>
<li>若0变为1（占用）</li>
<li>若1（占用），返回第一步</li>
</ul>
</li>
<li>开锁操作：使用完之后，锁位变为0。</li>
<li>上锁原语：保护cpu、当前进程变为等待，插入w的等待队列，转进程调度、w=1</li>
<li>开锁原语：移除等待队列的首元素，插入到就绪队列、该进程就绪、w=0<br>上锁原语-&gt;临界区-&gt;开锁原语<h4 id="4-5-2-信号等的PV操作"><a href="#4-5-2-信号等的PV操作" class="headerlink" title="4.5.2 信号等的PV操作"></a>4.5.2 信号等的PV操作</h4></li>
<li>2元组：(s.q)。<ul>
<li>s&gt;0,表示有可用资源，进程执行，绿灯。</li>
<li>s&lt;=0，表示没有可用资源，停止执行，红灯。</li>
</ul>
</li>
<li>P操作：P(s)；s减1（大于等于0返回，小于0（进程被阻）入信号灯等待队列，置为“等待状态”，转进程调度）</li>
<li>V操作：V(s)：S加一。大于0返回，小于等于0唤醒（从信号灯的等待队列中取出首元素、入就绪队列、置“就绪状态”、返回）<h4 id="4-6-进程互斥与同步的实现"><a href="#4-6-进程互斥与同步的实现" class="headerlink" title="4.6 进程互斥与同步的实现"></a>4.6 进程互斥与同步的实现</h4><h4 id="4-6-1-用上锁原语和开锁原语实现进程互斥"><a href="#4-6-1-用上锁原语和开锁原语实现进程互斥" class="headerlink" title="4.6.1 用上锁原语和开锁原语实现进程互斥"></a>4.6.1 用上锁原语和开锁原语实现进程互斥</h4>上锁原语-&gt;进入临界区cs-&gt;开锁原语 （main函数中设置w=1）<h4 id="4-6-2-用信号灯的P、V操作实现互斥"><a href="#4-6-2-用信号灯的P、V操作实现互斥" class="headerlink" title="4.6.2 用信号灯的P、V操作实现互斥"></a>4.6.2 用信号灯的P、V操作实现互斥</h4></li>
<li>mutex:互斥信号灯  </li>
<li>p(mutex)-&gt;临界区cs-&gt;v(mutex)</li>
<li>若有两个并发进程<ul>
<li>mutex=1:没有程序进入临界区</li>
<li>mutex=0:有一个程序进入临界区</li>
<li>mutex=-1:一个程序进入临界区，另一个程序等待进入</li>
</ul>
</li>
<li>若有n个并发进程，则可能有1,0,-1,…,-(n-1)取值</li>
<li>信号灯s为正值：挂起进程前还可以使用的P操作数，等于s还可以使用的物理资源数。</li>
<li>s为负值：在信号灯s队列中等待的进程个数。</li>
<li>P操作：请求一个资源/挂起进程，V操作：释放一个资源/唤醒进程。<br>化验单-&gt;化验进程-》开始工作<br>化验进程-》化验结果-》看病进程-》医疗方案。<h4 id="4-6-3-进程同步的实现"><a href="#4-6-3-进程同步的实现" class="headerlink" title="4.6.3 进程同步的实现"></a>4.6.3 进程同步的实现</h4></li>
<li>合作进程的执行次序</li>
<li>共享缓冲区的合作进程的同步的解法  </li>
<li>考虑4.4.3节中提到的问题<ol>
<li>sa表示缓冲区中是否有可供打印的计算结果，初值为0。</li>
<li>sb表示缓冲区有无空位置存放新的信息，其初值为1。</li>
</ol>
</li>
</ul>
<h4 id="4-6-4-生产者和消费者"><a href="#4-6-4-生产者和消费者" class="headerlink" title="4.6.4 生产者和消费者"></a>4.6.4 生产者和消费者</h4><ul>
<li>计算进程和打印进程<ul>
<li>多个计算进程cp不断产生数据，生产者</li>
<li>多个打印进程iop不断打印数据，消费者</li>
<li>有多个缓冲区</li>
</ul>
</li>
<li>通信问题<ul>
<li>发消息进程send不断产生消息，生产者</li>
<li>受消息recieve不断接收消息，消费者</li>
</ul>
</li>
<li>生产者和消费者的同步关系<ul>
<li>生产者：有界缓冲区无空位，等待；放入物品，发消息</li>
<li>消费者：无物品，等待；取物品，发消息</li>
</ul>
</li>
<li>信号灯的设置<ul>
<li>两个同步信号灯<ul>
<li>sb：缓冲区的数目，初值=n</li>
<li>sa：信息数目，初值=0</li>
</ul>
</li>
<li>一个互斥信号灯<ul>
<li>mutex：有界缓冲区是否被占用，初值=1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-7-进程通信-IPC"><a href="#4-7-进程通信-IPC" class="headerlink" title="4.7 进程通信(IPC)"></a>4.7 进程通信(IPC)</h4><ul>
<li>概念：进程之间直接以<code>较高的效率</code>传递<code>较多数据</code>的信息交互方式。也是两个不同的进程<code>共享数据</code>的方式。</li>
<li>实现：消息缓冲器、发送操作、接收操作</li>
<li>发送进程和接受进程的同步：发送等待、接受等待。<h4 id="4-7-2-进程通信的方式"><a href="#4-7-2-进程通信的方式" class="headerlink" title="4.7.2 进程通信的方式"></a>4.7.2 进程通信的方式</h4></li>
<li>消息缓冲通信<ul>
<li>信息头：发送进程的标识符、接受进程的标识符、传送信息的字节数。</li>
<li>消息缓冲、发送原语、接受原语：每一次想要发送消息，形成一个消息缓冲区，消息原语将消息发出；接受进程在本进程主存空间形成一个接受区，接受原语接受消息。</li>
</ul>
</li>
<li>信箱通信<ul>
<li>定义信箱结构</li>
<li>消息发送模块、功能接受模块：提供发送原语和接受原语</li>
<li>所使用的信箱可以用于用户空间中（接受进程地址空间的一部分）、也可以用于操作系统空间中。</li>
</ul>
</li>
<li>下面两个？？</li>
<li>sys V进程通信方式<ul>
<li>信号量</li>
<li>共享内存</li>
<li>消息队列</li>
</ul>
</li>
<li>posix进程间通信方式<ul>
<li>共享内存</li>
<li>信号量<br>&lt;!– #### 4.8 操作系统的进程即期间的通讯实例</li>
</ul>
</li>
</ul>
<ol>
<li>int pid=fork(); //创建进程<ul>
<li>为子进程分配了一个新的PCB</li>
<li>为子进程赋了一个唯一的进程标识号PID</li>
<li>子进程复制父进程的下列属性：用户id、组id、工作目录根目录、信号屏蔽设置和动作、环境变量、内存、所有已经打开的文件句柄</li>
<li>对父进程返回子进程的进程号，最子进程返回0</li>
</ul>
</li>
<li>等待进程/线程终止：wait(); waitpid();<ul>
<li>int status; pid=wait(&amp;status);<br>–&gt;<h4 id="4-8-线程的概念及特点"><a href="#4-8-线程的概念及特点" class="headerlink" title="4.8 线程的概念及特点"></a>4.8 线程的概念及特点</h4></li>
</ul>
</li>
</ol>
<ul>
<li>概念：比进程更小的活动单位，进程中的一个执行路径。</li>
<li>描述：进程中的一条执行路径、有自己私用的运行栈和处理机执行环境、与其他线程“共享”分配给进程的“内存和文件”、单个进程是创建的多个同时存在的线程中的一个。线程是一个动态概念。</li>
<li>线程调用实例<h4 id="4-10-进程调度"><a href="#4-10-进程调度" class="headerlink" title="4.10 进程调度"></a>4.10 进程调度</h4></li>
<li>调度/分派结构：多个就绪状态的进程对处理机的竞争是由进程调度程序来协调的。<ul>
<li>调度：就绪状态的进程排序。将一个进程插入到就绪队列，按照一定策略排序。</li>
<li>分派：调度时机，就绪队列第一个进程移出，建立其在处理机上执行环境，在处理机执行。</li>
</ul>
</li>
<li>调度的功能<ul>
<li>记录进程的状态变化</li>
<li>决定调度策略：1.优先调度、2.FIFO</li>
<li>实施处理机的分配和回收</li>
</ul>
</li>
<li>调度时机<ul>
<li>运行-》等待（阻塞）</li>
<li>运行-》就绪（时间片到）</li>
<li>等待-》就绪（唤醒）</li>
<li>任务完成，终止</li>
<li>异常出错</li>
<li>可剥夺调度，出现更高优先级的就绪进程。</li>
</ul>
</li>
<li>调度方式：“重要而紧迫”的进程怎么处理<ul>
<li>剥夺方式：暂停current，处理机给“重要而紧迫”</li>
<li>非剥夺方式：继续current，直到该进程完成或发生某事件到“完成”、“阻塞”，才给“重要而紧迫”</li>
</ul>
</li>
<li>调度算法<ul>
<li>进程优先数调度算法<ul>
<li>优先数的分类和确定<ol>
<li>静态优先数：根据所需资源来计算、基于程序运行时间估计、基于进程类型。</li>
<li>动态优先数：CPU超过一定时间降低、I/O增加，等待时间超过一定时间增加。</li>
</ol>
</li>
</ul>
</li>
<li>循环轮转调度算法<ul>
<li>时间片的计算：q=t/n （t为用户能接受的响应时间，n为进入系统的进程数目）</li>
<li>时间片的选取：太小，系统切换很频繁（切换时间不可忽略），从系统角度来看，时间片取大比较好。太大，轮转一次的总时间增大，对进程的响应速度放慢了。  </li>
<li>可变时间片轮转调度：根据系统当前的进程树来确定时间片的大小。</li>
<li>多级时间片循环调度<ul>
<li>多个就绪队列</li>
<li>先进入高优先级队列，高优先级队列的时间片较小。</li>
<li>用完后，进入下一级队列，优先级降低，但时间片增大一倍。</li>
<li>这个算法，较小时间片处理完较短进程，避免较长进程被频繁中断。</li>
</ul>
</li>
<li>时间片与优先级混合调度算法<ul>
<li>I/O后进入因I/O而等待队列，完成后进入高优先就绪。</li>
<li>运行时间片到了，进入低优先就绪队列。</li>
<li>CPU空闲时，若高优先就绪队列非空，则从高优先就绪队列中选择一个进程运行，分配时间片100ms。</li>
<li>CPU空闲时，若高优先就绪队列为空，则从低优先就绪队列中选择一个程序运行，分配时间片为500ms。</li>
<li>照顾I/O量大的进程，适当照顾计算量大的进程，提高系统资源利用率。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: Waylon Ding</p><p>原文链接: <a href="/blog/www.waylonding.cn/blog/2019/11/19/OpeartingSystem-Notes/">www.waylonding.cn/blog/2019/11/19/OpeartingSystem-Notes/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/blog/tags/System-Network/">System &amp; Network</a><a href="/blog/tags/Operating-System/">Operating System</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/blog/2019/11/20/Computing-Theory/" class="pre">Computing Theory Notes</a><a href="/blog/2019/11/19/ComputerNetwork-Review-Notes/" class="next">ComputerNetwork Notes</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机操作系统学习-amp-复习笔记"><span class="toc-text">计算机操作系统学习&amp;复习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一章-绪论"><span class="toc-text">第一章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-操作系统在计算机中的地位"><span class="toc-text">1.1 操作系统在计算机中的地位 *</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-操作系统采用的技术"><span class="toc-text">1.5 操作系统采用的技术 *</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二章-操作系统的结构和硬件支持"><span class="toc-text">第二章 操作系统的结构和硬件支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-处理机的态"><span class="toc-text">2.3 处理机的态 *</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-中断及其处理"><span class="toc-text">2.4 中断及其处理 *</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三章-操作系统的用户接口"><span class="toc-text">第三章 操作系统的用户接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-操作系统的用户接口及分类"><span class="toc-text">3.2 操作系统的用户接口及分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-系统功能调用及其实现技术"><span class="toc-text">3.3 系统功能调用及其实现技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-linux系统调用功能的实现"><span class="toc-text">3.5 linux系统调用功能的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第四章-进程及进程管理"><span class="toc-text">第四章 进程及进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-并发进程及其特点"><span class="toc-text">4.1 并发进程及其特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-进程定义"><span class="toc-text">4.2.1 进程定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-进程状态及其变迁"><span class="toc-text">4.2.2 进程状态及其变迁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-进程控制块及进程队列"><span class="toc-text">4.2.3 进程控制块及进程队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-进程控制"><span class="toc-text">4.3 进程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-进程互斥的概念"><span class="toc-text">4.4.2 进程互斥的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-进程同步的概念"><span class="toc-text">4.4.3 进程同步的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-同步机构"><span class="toc-text">4.5 同步机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-锁、上锁、开锁"><span class="toc-text">4.5.1 锁、上锁、开锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-信号等的PV操作"><span class="toc-text">4.5.2 信号等的PV操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-进程互斥与同步的实现"><span class="toc-text">4.6 进程互斥与同步的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-用上锁原语和开锁原语实现进程互斥"><span class="toc-text">4.6.1 用上锁原语和开锁原语实现进程互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-2-用信号灯的P、V操作实现互斥"><span class="toc-text">4.6.2 用信号灯的P、V操作实现互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-3-进程同步的实现"><span class="toc-text">4.6.3 进程同步的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-4-生产者和消费者"><span class="toc-text">4.6.4 生产者和消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-进程通信-IPC"><span class="toc-text">4.7 进程通信(IPC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-2-进程通信的方式"><span class="toc-text">4.7.2 进程通信的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-线程的概念及特点"><span class="toc-text">4.8 线程的概念及特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-10-进程调度"><span class="toc-text">4.10 进程调度</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2019/11/20/Computing-Theory/">Computing Theory Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/11/19/OpeartingSystem-Notes/">OpeartingSystem Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/11/19/ComputerNetwork-Review-Notes/">ComputerNetwork Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/11/18/QT%20creator%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8ETCP%E4%BC%A0%E8%BE%93%E8%AF%95%E9%AA%8C/">QT creator的使用与TCP传输试验</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/11/18/hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%A9%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0/">Build My Personal Blog with Github and Hexo</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/CS-Courses/">CS Courses</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/">hexo搭建属于自己的博客</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/hexo%E6%8A%80%E6%9C%AF/">hexo技术</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/Computer-Network/" style="font-size: 15px;">Computer Network</a> <a href="/blog/tags/System-Network/" style="font-size: 15px;">System & Network</a> <a href="/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/blog/tags/Operating-System/" style="font-size: 15px;">Operating System</a> <a href="/blog/tags/hexo%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/" style="font-size: 15px;">hexo相关技术</a> <a href="/blog/tags/markdown%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">markdown的使用</a> <a href="/blog/tags/Formal-language-and-Automata/" style="font-size: 15px;">Formal language and Automata</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/">2019</a><span class="archive-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/blog/baidusitemap.xml">网站地图</a> |  <a href="/blog/atom.xml">订阅本站</a> |  <a href="/blog/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/blog/." rel="nofollow">Waylon Ding.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/blog/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/blog/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/blog/share/css/share.css"><script type="text/javascript" src="/blog/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/blog/share/js/qrcode.js" charset="utf-8"></script></body></html>