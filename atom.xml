<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>REDIVIOUS‘s Blog</title>
  
  <subtitle>世界那么大，我想去看看</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="www.waylonding.cn/blog/"/>
  <updated>2019-11-30T05:15:57.908Z</updated>
  <id>www.waylonding.cn/blog/</id>
  
  <author>
    <name>Waylon Ding</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Computing Theory Notes</title>
    <link href="www.waylonding.cn/blog/2019/11/20/Computing-Theory/"/>
    <id>www.waylonding.cn/blog/2019/11/20/Computing-Theory/</id>
    <published>2019-11-20T06:49:38.000Z</published>
    <updated>2019-11-30T05:15:57.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Notes-of-Computing-Theory-2019"><a href="#Notes-of-Computing-Theory-2019" class="headerlink" title="Notes of Computing Theory 2019"></a>Notes of Computing Theory 2019</h2><p>Reference:</p><ul><li>Introduction to the Theory of Computation (3rd edition)</li><li>An Introduction to Formal Languages and Automata (5th thedition)</li><li>Computational Complexity: a Modern Approach</li></ul><h2 id="Part1-Formal-Language-and-Automata"><a href="#Part1-Formal-Language-and-Automata" class="headerlink" title="Part1 Formal Language and Automata"></a>Part1 Formal Language and Automata</h2><h3 id="1-1-Basis"><a href="#1-1-Basis" class="headerlink" title="1.1 Basis"></a>1.1 Basis</h3><h4 id="1-1-1-Introduction"><a href="#1-1-1-Introduction" class="headerlink" title="1.1.1 Introduction"></a>1.1.1 Introduction</h4><h4 id="1-1-2-Languages"><a href="#1-1-2-Languages" class="headerlink" title="1.1.2 Languages"></a>1.1.2 Languages</h4><h4 id="1-1-3-DFA"><a href="#1-1-3-DFA" class="headerlink" title="1.1.3 DFA"></a>1.1.3 DFA</h4><h4 id="1-1-4-NFA"><a href="#1-1-4-NFA" class="headerlink" title="1.1.4 NFA"></a>1.1.4 NFA</h4><h3 id="1-2-Regular-Expression"><a href="#1-2-Regular-Expression" class="headerlink" title="1.2 Regular_Expression"></a>1.2 Regular_Expression</h3><h4 id="1-2-1-Regular-Expressions"><a href="#1-2-1-Regular-Expressions" class="headerlink" title="1.2.1 Regular_Expressions"></a>1.2.1 Regular_Expressions</h4><h4 id="1-2-2-Regular-Properties"><a href="#1-2-2-Regular-Properties" class="headerlink" title="1.2.2 Regular_Properties"></a>1.2.2 Regular_Properties</h4><h4 id="1-2-3-Regular-Grammars"><a href="#1-2-3-Regular-Grammars" class="headerlink" title="1.2.3 Regular_Grammars"></a>1.2.3 Regular_Grammars</h4><h4 id="1-2-4-Regular-Pumping"><a href="#1-2-4-Regular-Pumping" class="headerlink" title="1.2.4 Regular_Pumping"></a>1.2.4 Regular_Pumping</h4><h4 id="1-2-5-Regular-Pumping-Examples"><a href="#1-2-5-Regular-Pumping-Examples" class="headerlink" title="1.2.5 Regular_Pumping_Examples"></a>1.2.5 Regular_Pumping_Examples</h4><h3 id="1-3-Context-Free"><a href="#1-3-Context-Free" class="headerlink" title="1.3 Context_Free"></a>1.3 Context_Free</h3><h4 id="1-3-1-Context-Free-Languages"><a href="#1-3-1-Context-Free-Languages" class="headerlink" title="1.3.1 Context-Free Languages"></a>1.3.1 Context-Free Languages</h4><ul><li>主要形式：S-&gt;ab|SS|e</li><li>推导表：对于一个语法，和确定的答案，可以每次替换最左的变量、或者每次替换最右的变量</li><li>推导树（解析树）：对于每一个推导都能给出一个derivation tree。</li><li>歧义性：leftmost和rightmost推导出来的结果不一样（有两个不同的derivation tree或者有两个不同的左文法）<br>例如E-&gt;E+E|E<em>E|(E)|a<br>对于a+a</em>a，有两个不同路径的派生<ul><li>要将歧义的转换为非歧义的，或许能够成功，但也有失败的。</li><li>有的语言是固有的歧义的。（PPT在此时隐含告诉了你如何用language构造grammar）</li></ul></li><li>注意PPT上举出的例子：{a^n b^n c^n}不是一个context-free的语言<h4 id="1-3-2-Properties-of-Context-Free-languages"><a href="#1-3-2-Properties-of-Context-Free-languages" class="headerlink" title="1.3.2 Properties of Context-Free languages"></a>1.3.2 Properties of Context-Free languages</h4></li><li>context-free的关键点是：language-L、grammars-G、variables-S</li><li>union操作：s-&gt;s1|s2</li><li>concatention操作：s-&gt;s1s2</li><li>star operation操作：s1-&gt;ss1|r</li><li>intersection、complement不一定是context-free<ul><li>intersection<ul><li>L1={a^n b^n c^m} context free S-&gt;AC; A-&gt;aAb|r; C-&gt;cC|r。 </li><li>L2={a^n b^m c^m} S-&gt;AB; A-&gt;aA|r; B-&gt;bBc|r。</li><li>其交集为{a^n b^n c^n} 不是context free</li></ul></li><li>complementation<ul><li>^(^(L1)+^(L2))=L1交集L2={a^n b^n c^n}。不是conetxt free</li></ul></li></ul></li><li>L1 context free; L2 regular; -&gt; L1交集L2 = context free（正则闭包）<ul><li>正则闭包：L1是上下文无关文法，L2是正则文法，则L1交集L2是上下文无关文法。</li><li>构造下推自动机：L1交集L2</li><li>例子：证明L={a^n b^n n!=100}是context free（见PPT）构造除了n=100之外的，取交集。</li><li>例子：证明L={w:na=nb=nc}不是context-free。假设是，并和{a<em>b</em>c*}相交，得到{a^n b^n c^n}，不是context-free。<h4 id="1-3-3-Simplifications-of-Context-Free-Grammars"><a href="#1-3-3-Simplifications-of-Context-Free-Grammars" class="headerlink" title="1.3.3 Simplifications of Context-Free Grammars"></a>1.3.3 Simplifications of Context-Free Grammars</h4></li></ul></li><li>替换原则：形如A-&gt;xBz，B-&gt;y1；可以替换为：A-&gt;xBz|xy1z<ul><li>nullable variables: M-&gt;e</li><li>unit productions: A-&gt;B. (X-&gt;X can be removed)</li><li>useless prodections: never terminate (A-&gt;aA); not reachable from S (详见PPT)</li></ul></li><li>context-free的正规表达 (chomsky normal form)<ul><li>都有形式：A-&gt;BC或者A-&gt;a (variable只能有两个，terminal只能有一个))</li><li>转换成chomsky form<ul><li>对每个terminal转换：Ta-&gt;A </li><li>用V合并两个varible</li></ul></li><li>Greinbach normal form<ul><li>A -&gt; aV1V2V3…（只有一个terminal，后面全是varible）<h4 id="1-3-5-parsing"><a href="#1-3-5-parsing" class="headerlink" title="1.3.5 parsing"></a>1.3.5 parsing</h4></li></ul></li></ul></li><li>lexical analyzer：识别关键词和变量</li><li>parser：知道程序的编程语言、对于输入的程序建立推导树、将推导树转换成机器码。</li><li>exhaustive parser：K^2w</li><li>S-grammar/cyk: A-&gt;av (v=&gt;string of variables) :O(w^2 * w) = O(w^3) (number of substrings * number of pre-suffix decompositions for a string) (和算法课上讲的context-free的表求解过程一致) <h4 id="1-3-6-Context-Free-Pumping"><a href="#1-3-6-Context-Free-Pumping" class="headerlink" title="1.3.6 Context_Free_Pumping"></a>1.3.6 Context_Free_Pumping</h4></li><li>我们有最多t个right-bond-size，r个变量 =&gt; 证明了至少有r+2层；根据鸽巢定理，一定会有重复使用的变量。</li><li>PPT P45展示了context-free的pumping lemma。关键点：w=uvxyz；有u v^i x y^i z也属于这个文法。（vxy&lt;=p;vy&gt;=1）</li><li>证明要点：分情况vxy位置，对于{a^n b^n c^n}来说有5种情况。vy&gt;=1，有k1+k2&gt;=1。<h4 id="1-3-7-Context-Free-Pumping-Examples"><a href="#1-3-7-Context-Free-Pumping-Examples" class="headerlink" title="1.3.7 Context_Free_Pumping_Examples"></a>1.3.7 Context_Free_Pumping_Examples</h4></li><li>L={vv:v belongs to {a,b}} not context-free (10种)</li><li>L={a^(n!):n&gt;=0} not context-free</li><li>L={a^(n^2) b^n: n&gt;=0} not context-free<h3 id="1-4-PDA"><a href="#1-4-PDA" class="headerlink" title="1.4 PDA"></a>1.4 PDA</h3><h4 id="1-4-1-PDA"><a href="#1-4-1-PDA" class="headerlink" title="1.4.1 PDA"></a>1.4.1 PDA</h4></li><li>a, b-&gt;c (input, pop, push)</li><li>NPDA: 有不确定状态的下推自动机：如e状态<br>如果一个string被接受了，代表所有的输入被消耗了，最后一个状态是接受状态。</li><li>push &amp; pop strings：a, w1-&gt;w2 (inout,pop strings push strings) (注意，在构造PDA的时候，需要知道pop和push中间需要加上一个介稳态)</li><li>instantaneous descripition：(q,u,s):(现有状态，剩余输入、现有在栈中的输入)</li><li>我们有：前一个时间的instantaneous descripition &gt; 后一个时间的instantaneous descripition。<h4 id="1-4-2-PDA-Accept-Context-Free"><a href="#1-4-2-PDA-Accept-Context-Free" class="headerlink" title="1.4.2 PDA_Accept_Context_Free"></a>1.4.2 PDA_Accept_Context_Free</h4></li><li>一个context-free language 和一个能被PDA接受的语言是等价的。证明过程：1.证明conetxt-free语言的语法被PDA的语法包含。（能将context-free文法转换为PDA；2.证明context-free语言（文法）包含PDA（能将任意的PDA转换为context-free文法）</li><li>context-free转换为PDA  <ol><li>q0-&gt;q1-&gt;q2 (q1:loop)  </li><li>grammar：A-&gt;w: e,A-&gt;w  </li><li>terminal：a,a-&gt;e</li></ol></li><li>PDA -&gt; context-free  <ol><li>转换到：PDA只有一个接受状态，利用e，e-&gt;e  </li><li>使用initial stack symbol#<br>增加e,e-&gt;@; e,e-&gt;Z；对于PDA来说，还是z为初始状态</li><li>使用唯一的接受stack symbol#<br>增加e,e-&gt;e; 然后空栈操作（添加e,x-&gt;e）x为除了@和#之外的所有的元素; 最后加操作e,@-&gt;e。</li><li>每次转换状态要么将一个symbol入栈，要么将一个symbol出栈，但不能两者同时。<br>举个例子：就是不能有k,a-&gt;b；需要转换为k,a-&gt;e; e,e-&gt;b;<br>特殊情况：如果有k,e-&gt;e；需要转换为k,e-&gt;u；e,u-&gt;e;</li><li>转换到这里完成，需要注意的是，新的栈开始符号#没有在任何的传递中使用。</li></ol></li><li>语法的构建：变量：Aqi，qj （qi、qj为PDA的状态） <ol><li>Initial state：q0；Accept state：qf  </li><li>start varible：Aq0qf  </li><li>kind1:from single state：Aq0q0-&gt;e（对于Aqiqi都成立）  </li><li>kind2:from triplets of states<br>$A_{q0q5} -&gt; A_{q0q0}A_{q0q5}|A_{q0q1}A_{q1q5}|A_{q0q2}A_{q2q5}|A_{q0q3}A_{q3q5}|A_{q0q4}A_{q4q5}|A_{q0q5}A_{q5q5}$</li><li>from pairs of transitions<br>缩减状态，详见PPT。</li></ol></li><li>证明Apq，有一个从状态p到状态q的串w，使得这个串变成空串：(p,w,e)&gt;(q,e,e),有以下几种情况<ol><li>Apq-&gt;AprArq-&gt;…-&gt;w</li><li>Apq-&gt;aArsb-&gt;…-&gt;w</li></ol><ul><li>用数学归纳法证明，详见ppt（这一点我期末考试再复习一遍，这里先立个flag）</li></ul></li></ul><h4 id="1-4-3-DPDA"><a href="#1-4-3-DPDA" class="headerlink" title="1.4.3 DPDA"></a>1.4.3 DPDA</h4><ul><li><p>确定性的下推自动机。不允许不确定性的情况存在。例如同时存在a,b-&gt;w1和a,b-&gt;w2。也不允许r,b-&gt;w1和a,b-&gt;w2同时存在。 </p></li><li><p>如果有一个DPDA构造的语言L，证明这个语言是确定性上下文法无关语言。  </p></li><li><p>DPFA属于PFA的一部分（真包含关系）。PPT中展示了一个context-free language它不能被任何DPDA接受：L(M)={a^n b^n}+{a^n b^2n} ：构造一条路径，构造一个PDA有形式L+{a^n b^n c^n}。而这个形式本来不属于context-free语言，推出矛盾。</p><h2 id="part2-Turing-machine"><a href="#part2-Turing-machine" class="headerlink" title="part2 Turing machine"></a>part2 Turing machine</h2><h3 id="2-1-turing-machines"><a href="#2-1-turing-machines" class="headerlink" title="2.1 turing machines"></a>2.1 turing machines</h3></li><li><p>最大范围的语言，包括{a^n b^n c^n}、ww</p></li><li><p>a-&gt;b,L (read a, write b, move left)</p></li><li><p>图灵机是确定性的，不允许e传递。P16</p></li><li><p>停止条件：无法根据语法去跟随步骤。接受状态也不允许有走出状态</p></li><li><p>一般表达：g(q1,a)=(q2,b,R)<br>串的表达eg: q2xayb&gt;xq0ayb（即状态左边的、状态、状态所指、状态右边的）</p></li><li><p>initial configuration：q0w 且有：L(M)={w: q0w &gt; x1qfx2} (q0: initial, qf: accept)</p><h3 id="2-2-turing-variations"><a href="#2-2-turing-variations" class="headerlink" title="2.2 turing variations"></a>2.2 turing variations</h3><h4 id="2-2-1-Turing-thesis"><a href="#2-2-1-Turing-thesis" class="headerlink" title="2.2.1 Turing thesis"></a>2.2.1 Turing thesis</h4></li><li><p>解决问题的算法是构造一个图灵机解决问题</p><ul><li>算法描述图灵机的步骤</li><li>图灵机 -&gt; 计算步骤<h4 id="2-2-2-variations-of-the-turing-machine"><a href="#2-2-2-variations-of-the-turing-machine" class="headerlink" title="2.2.2 variations of the turing machine"></a>2.2.2 variations of the turing machine</h4></li></ul></li><li><p>标准模型：PPT第六面 （本章证明以下变种都和标准图灵机相等）</p></li><li><p>Stay Option: L,R,S: left, right, stay </p><ul><li>PPT：P13</li><li>Prove：PPT P15 （能互相simulate）</li><li>stay option 和 standrad 的转换 P18</li></ul></li><li><p>multiple track tape: (b,a)-&gt;(c,d),L PPT: P21</p></li><li><p>semi-infinite: 在输入串的左端加入#。 PPT: P23</p><ul><li>将infinite分成left part和right part</li><li>(b,f)-&gt;(g,d),L,R 左边往左边流，右边往右边流</li><li>porve: 标准-&gt;半带 P25</li><li>prove: 半带-&gt;标准 P27</li></ul></li><li><p>multi-tape machine：(b,f)-&gt;(g,d),L,R P34</p><ul><li>prove: 多带-&gt;标准 P38</li></ul></li><li><p>多维图灵机：L,R,U,D P42</p><ul><li>二维模型：P46</li></ul></li><li><p>不确定性图灵机</p><ul><li>多个choice</li><li>确定性模拟非确定性P55（BFS）<h4 id="2-2-3-universal-turing-machine"><a href="#2-2-3-universal-turing-machine" class="headerlink" title="2.2.3 universal turing machine"></a>2.2.3 universal turing machine</h4></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Notes-of-Computing-Theory-2019&quot;&gt;&lt;a href=&quot;#Notes-of-Computing-Theory-2019&quot; class=&quot;headerlink&quot; title=&quot;Notes of Computing Theory 2019&quot;&gt;
      
    
    </summary>
    
    
      <category term="CS Courses" scheme="www.waylonding.cn/blog/categories/CS-Courses/"/>
    
    
      <category term="Formal language and Automata" scheme="www.waylonding.cn/blog/tags/Formal-language-and-Automata/"/>
    
  </entry>
  
  <entry>
    <title>OpeartingSystem Notes</title>
    <link href="www.waylonding.cn/blog/2019/11/19/OpeartingSystem-Notes/"/>
    <id>www.waylonding.cn/blog/2019/11/19/OpeartingSystem-Notes/</id>
    <published>2019-11-19T08:29:13.000Z</published>
    <updated>2019-12-02T09:01:29.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机操作系统学习-amp-复习笔记"><a href="#计算机操作系统学习-amp-复习笔记" class="headerlink" title="计算机操作系统学习&amp;复习笔记"></a>计算机操作系统学习&amp;复习笔记</h2><p>参考书目：计算机操作系统（人民邮电出版社）</p><h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-1-操作系统在计算机中的地位"><a href="#1-1-操作系统在计算机中的地位" class="headerlink" title="1.1 操作系统在计算机中的地位 *"></a>1.1 操作系统在计算机中的地位 *</h4><ul><li>操作系统是什么；<ul><li>是核心软件</li><li>负责软件硬件资源分配与调用</li><li>控制、协调并发活动</li><li>提供用户接口、为用户良好工作环境</li></ul></li><li>操作系统特点<br>位置：从里到往外裸机-&gt;操作系统-&gt;应用软件<ul><li>内容庞杂、涉及面广<ul><li>控制管理硬件、软件；控制程序进行</li><li>为用户提供良好接口</li></ul></li><li>实践性强</li><li>技术发展快<br>Unix和linux采取优先调度。<br>linux调度方法：140队列，140位位图，扫描位图（不怎么需要时间），高优先级入列</li></ul></li><li>OS和各层次的关系<ul><li>硬件：控制CPU、访问存储、驱动设备、中断</li><li>软件：控制管理、提供界面和服务</li></ul></li><li>各层次对OS的影响<ul><li>硬件约束：用串行（CPU）实现并行（操作系统）</li><li>上层用户需求：实时和分时，界面友好<h4 id="1-2-操作系统的形成和发展（多道程序、分时技术）"><a href="#1-2-操作系统的形成和发展（多道程序、分时技术）" class="headerlink" title="1.2 操作系统的形成和发展（多道程序、分时技术）"></a>1.2 操作系统的形成和发展（多道程序、分时技术）</h4><h4 id="1-3-操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）"><a href="#1-3-操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）" class="headerlink" title="1.3 操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）"></a>1.3 操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）</h4><h4 id="1-4-操作系统的基本类型"><a href="#1-4-操作系统的基本类型" class="headerlink" title="1.4 操作系统的基本类型"></a>1.4 操作系统的基本类型</h4></li></ul></li><li>批量操作系统</li><li>分时操作系统</li><li>实时操作系统</li><li>个人计算机操作系统</li><li>网络操作系统</li><li>分布式系统<h4 id="1-5-操作系统采用的技术"><a href="#1-5-操作系统采用的技术" class="headerlink" title="1.5 操作系统采用的技术 *"></a>1.5 操作系统采用的技术 *</h4></li><li>并行处理技术<ul><li>并行处理：多个部件、为整体任务同时执行。</li><li>多用户、多任务同时执行。<br>为描述任务，引入进程的概念。进程的状态及控制（任务状态）、进程同步与互斥（多任务协调）、进程调度（CPU控制权的分配等等）</li><li>系统资源共享<br>处理机共享（处理机分配调度）、存储器共享（存储分配、保护、虚拟存储与地址映射）、设备共享（设备分配驱动以及中断）、信息共享（文件结构、共享以及存取方法）</li></ul></li><li>虚拟技术<ul><li>用户：逻辑视图。操作系统：物理视图。</li><li>物理（硬件）资源（系统）：CPU、主存、打印机、磁盘等。</li><li>逻辑（软件）资源（用户）：CPU1、CPU2（CPU分时）；虚拟主存1、虚拟主存2（主存的主存管理）；打印机1、打印机2（虚拟打印技术）（网络上有很多资源需要打印机）</li></ul></li></ul><h3 id="第二章-操作系统的结构和硬件支持"><a href="#第二章-操作系统的结构和硬件支持" class="headerlink" title="第二章 操作系统的结构和硬件支持"></a>第二章 操作系统的结构和硬件支持</h3><h4 id="2-1-操作系统虚拟机"><a href="#2-1-操作系统虚拟机" class="headerlink" title="2.1 操作系统虚拟机"></a>2.1 操作系统虚拟机</h4><h4 id="2-2-操作系统组织结构"><a href="#2-2-操作系统组织结构" class="headerlink" title="2.2 操作系统组织结构"></a>2.2 操作系统组织结构</h4><ul><li>操作系统的结构</li><li>运行时的组织结构</li><li>操作系统与计算机层次的接口<h4 id="2-3-处理机的态"><a href="#2-3-处理机的态" class="headerlink" title="2.3 处理机的态 *"></a>2.3 处理机的态 *</h4></li><li>系统中两类程序：管理程序和用户程序：<ul><li>管理程序：管理系统资源、控制程序运行</li><li>用户程序: 使用资源、提出申请；被控制</li></ul></li><li>区分处理机状态的目的是为了保护操作系统。不保护就有可能瘫痪。</li><li>处理机的态：中央处理机的工作状态（取决于当前处理机运行的程序）<ul><li>管态：管理程序执行的态。称特权级。使用全部指令和资源。<ul><li>有的细分为核心态和管态</li></ul></li><li>用户态：用户程序执行的态。只允许访问自己的存储区域，禁止特权指令，不能直接取用资源与改变机器的态。</li></ul></li><li>管态和用户态区别：<ul><li>管态<ul><li>操作系统程序执行</li><li>使用全部指令</li><li>使用全部系统资源（包括整个存储空间）</li></ul></li><li>用户态<ul><li>用户程序执行</li><li>禁用特权指令</li><li>只允许用户程序访问自己的存储区域</li></ul></li><li>特权指令集<ul><li>涉及到外部设备的输入/输出命令</li><li>修改特殊寄存器的指令</li><li>改变机器状态的指令</li></ul></li></ul></li><li>实现处理机分态的硬件支持<ul><li>在状态寄存器中设置状态位：<ul><li>一位：用户态、管态</li><li>两位：核态、管态、用户态<ul><li>核态和管态都是操作系统程序执行时处理机的状态。核态：操作系统核心程序执行时的状态，权限比管态高，可以执行所有机器指令（改变机器状态）。</li></ul></li><li>Unix（linux）系统中状态的分类<ul><li>00-核态；01-管态；11-用户态</li></ul></li><li>80x86微处理器中状态位：（CPU特权级）DPL=0（核态）；DPL=3（用户态）</li></ul></li><li>程序性中断<ul><li>程序有越权操作时候发生的中断称为程序性中断。</li><li>中断机制负责使其陷入操作系统，用户态转换为管态，操作系统管理程序获得控制权开始执行。</li></ul></li><li>什么时候中断<br>用户态下超出了权限时保护操作系统：<ul><li>当用户执行了一条特权指令</li><li>当用户程序试图访问<code>操作系统数据区</code>或<code>其他程序占用的区域</code>时。<h4 id="2-4-中断及其处理"><a href="#2-4-中断及其处理" class="headerlink" title="2.4 中断及其处理 *"></a>2.4 中断及其处理 *</h4></li></ul></li></ul></li><li>中断：某个事件（掉电、定点加法溢出，I/O结束）发生时，停止现行程序执行，转而处理该事件的程序对事件进行处理，处理完毕返回执行原来程序。</li><li>中断类型：<ul><li>I/O中断</li><li>外中断：时钟、操作员控制台中断、通信中断</li><li>机器故障中断：电源、主存取指错等。</li><li>程序性中断：定点溢出、用户态下使用核态指令、非法操作</li><li>访管中断：对操作系统提出某种需求的时所发出的中断。</li></ul></li><li>中断方式：<ul><li>强迫性中断：除了访管中断</li><li>自愿中断：访管中断</li></ul></li><li>中断来源<ul><li>中断：由处理机外部事件引起的中断：时钟、磁盘、终端</li><li>俘获：由处理机内部事件引起的中断：非法指令、地址越界、浮点溢出、trap指令</li></ul></li><li>中断响应及硬件支持：<ul><li>保护现场、恢复现场<ul><li>现场： 后继指令所在主存的单元号、程序运行所处的状态、指令执行情况、程序执行的中间结果</li><li>保护现场：现场存入主存。</li><li>恢复现场：把保护的现场重新送到各个特殊寄存器</li></ul></li><li>中断响应：中央处理器发出请求-&gt;中止现有程序执行-&gt;引出中断处理程序的过程<ul><li>系统堆栈：存入指令计数器(PC)、处理机状态寄存器(PS) 的内容 (一般先PS后PC？)（硬件层面）</li><li>中断向量表：存入中断程序地址（地址内存从0开始）</li><li>中断响应实质：交换指令地址及处理机的状态信息</li></ul></li></ul></li><li>软件的中断处理过程<ul><li>中断进入</li><li>step1 保护中断程序的现场（没有保存的寄存器）</li><li>step2 进入相应的中断服务例程。</li><li>step3 恢复中断程序的现场。</li></ul></li></ul><h3 id="第三章-操作系统的用户接口"><a href="#第三章-操作系统的用户接口" class="headerlink" title="第三章 操作系统的用户接口"></a>第三章 操作系统的用户接口</h3><h4 id="3-1-用户工作环境"><a href="#3-1-用户工作环境" class="headerlink" title="3.1 用户工作环境"></a>3.1 用户工作环境</h4><ul><li>操作系统提供的环境</li><li>操作系统的生成和系统初启</li><li>应用程序的处理<h4 id="3-2-操作系统的用户接口及分类"><a href="#3-2-操作系统的用户接口及分类" class="headerlink" title="3.2 操作系统的用户接口及分类"></a>3.2 操作系统的用户接口及分类</h4></li><li>用户接口/用户界面：用户控制计算机的手段<ul><li>操作接口/命令界面：键盘命令（分时操作系统）（MS-DOS、unix/linux）、图形界面（windows）、作业控制语言（批处理系统）<br>组织工作流程，控制程序运行（C语言编写编译链接等）</li><li>程序接口：系统功能调用<br>程序运行时，使用系统功能调用来请求操作系统的服务。<h4 id="3-3-系统功能调用及其实现技术"><a href="#3-3-系统功能调用及其实现技术" class="headerlink" title="3.3 系统功能调用及其实现技术"></a>3.3 系统功能调用及其实现技术</h4></li></ul></li><li>硬件支持：由用户态到管态<ul><li>访管指令/自愿进管指令：svc n（功能号）</li><li>访管中断：正在运行的程序对于操作系统的某种需求。</li><li>系统功能调用：借助访管指令，取值n（特定功能），硬件进入，软件方法完成。</li></ul></li><li>系统调用实现<br>用户程序（svc i）、访管中断处理程序（按照i转移）、例行子程序入口地址表、例行自程序<h4 id="3-5-linux系统调用功能的实现"><a href="#3-5-linux系统调用功能的实现" class="headerlink" title="3.5 linux系统调用功能的实现"></a>3.5 linux系统调用功能的实现</h4></li><li>linux系统功能调用的进入<ul><li>异常处理（系统调用通过异常类型实现）、软中断（int 0x80）、状态转换（从用户态到核心态，执行自陷处理程序（防管中断处理程序））</li></ul></li><li>getuid系统调用过程<br>  用户程序(getuid())-&gt;标准C库(内含int0x80)-&gt;系统调用处理程序-&gt;内核例程（系统服务例程）</li><li>linux系统调用的进入和返回<ul><li>软中断（自陷指令/访管指令）int 0x80</li><li>发生中断（自陷/访管中断）</li><li>处理机用户态-&gt;内核态（内核状态的改变）</li><li>system_call()开始执行系统调用处理程序（系统功能调用的执行）</li><li>处理完毕后，iret返回到用户态</li></ul></li><li>Linux系统功能调用的实现机制<ul><li>硬件支持： 增加一个软中断指令、自陷</li><li>软件：系统调用号、系统调用表、系统服务例程、系统调用处理程序</li></ul></li><li>增加一个新的系统调用<ul><li>增加一个新的系统服务例程</li><li>增加一个新的系统调用号</li><li>在系统调用表中增加一项（新例程的地址）</li><li>将新的系统服务例程加入到系统中（系统重构）</li></ul></li><li>系统调用号<ul><li>linux中每个系统调用被赋予一个唯一的系统调用号<br>格式：#define _NR_fork 2</li></ul></li><li>系统调用表：记录了内核中所有已经注册过的系统调用、系统调用的函数指针（函数指针数组）（保存所有系统调用的函数指针）</li><li>系统调用的处理过程<ul><li>宏SAVE_ALL保护现场</li><li>正确性检查</li><li>eax中包含系统调用号，调用对应的服务例程</li><li>服务流程结束时，RESTORE_ALL恢复寄存器</li><li>iret返回</li></ul></li></ul><h3 id="第四章-进程及进程管理"><a href="#第四章-进程及进程管理" class="headerlink" title="第四章 进程及进程管理"></a>第四章 进程及进程管理</h3><h4 id="4-1-并发进程及其特点"><a href="#4-1-并发进程及其特点" class="headerlink" title="4.1 并发进程及其特点"></a>4.1 并发进程及其特点</h4><ul><li>程序的顺序执行：一个程序的一次执行过程称为一个计算，一个计算的若干操作必须按照严格的先后顺序来执行。<ul><li>顺序性：按照严格顺序执行</li><li>封闭性：一旦开始执行，不受外界因素影响</li><li>可再现性：执行的结果与他的执行速度无关（时间无关），与初始条件有关。</li></ul></li><li>并发程序<ul><li>定义：若干个程序同时在系统中运行，程序在时间上时重叠的（一个没做完，另外一个已经开始）</li><li>并行语句记号<br>cobegin<br>  S1，S2，S3…<br>coend</li></ul></li><li>并发程序的特点<ul><li>失去了封闭性和可再现性<br>一个程序的执行可以改变另一个程序的变量，后者的输出依赖于各程序执行的相对速度，失去了程序的封闭性的特点。</li><li>解决进程的同步问题（与时间有关的错误）</li><li>程序与计算不再一一对应：一个程序对应多个计算</li><li>程序并发执行的相互制约：间接的相互制约：资源共享、直接的相互制约：公共变量</li></ul></li></ul><h4 id="4-2-1-进程定义"><a href="#4-2-1-进程定义" class="headerlink" title="4.2.1 进程定义"></a>4.2.1 进程定义</h4><ul><li>运行（获得cpu）-&gt;暂停（保留状态）-&gt;运行（获得cpu）</li><li>定义：在给定的活动空间和初始环境下，在一个处理机上的执行过程。</li><li>与程序的区别<ul><li>程序静态（C语言代码不变）、进程动态（一次执行过程）</li><li>进程是一个独立运行的活动单位</li><li>竞争系统资源的基本单位（cpu，I/O）</li><li>一个程序可以对应多个进程，一个进程至少包含一个程序。<h4 id="4-2-2-进程状态及其变迁"><a href="#4-2-2-进程状态及其变迁" class="headerlink" title="4.2.2 进程状态及其变迁"></a>4.2.2 进程状态及其变迁</h4></li></ul></li><li>进程的基本状态<ul><li>运行状态（占用cpu）：已经获得运行所必须的资源，程序正在处理机上执行 （单cpu运行状态只能有一个）</li><li>等待状态（输入输出）：程序等待某一事件等待发生（等待外部传输完成等等）而暂时停止执行（这时即使给它cpu的控制权也无法执行）</li><li>就绪状态：进程已经获得除了CPU之外的运行所必须的资源，一旦获得了CPU控制权，就可以立即运行。</li></ul></li><li>进程状态的变迁：（基本状态变迁只有前三个）<ul><li>运行-&gt;等待：服务请求（I/O）</li><li>等待-&gt;就绪：（I/O是完成）服务完成，事件来到</li><li>就绪-&gt;运行：进程调度（CPU空出）</li><li>等待-&gt;运行：不可能</li><li>运行-&gt;就绪：时间片到了（分时系统中）</li><li>就绪-&gt;等待：有需求的系统提供（一般没有）</li></ul></li><li>linux系统状态变迁<ul><li>新进程-&gt;就绪：创建</li><li>就绪-&gt;运行：进程调度</li><li>运行-&gt;就绪：被抢占</li><li>等待-&gt;就绪：等待的事情发生</li><li>运行-&gt;等待：等待某事件</li><li>运行-&gt;终止：进程完成</li></ul></li><li>进程状态变迁的驱动及条件<br>见作业习题<h4 id="4-2-3-进程控制块及进程队列"><a href="#4-2-3-进程控制块及进程队列" class="headerlink" title="4.2.3 进程控制块及进程队列"></a>4.2.3 进程控制块及进程队列</h4></li><li>进程控制块：描述：1、进程与其他进程；2、系统资源的关系；以及3、进程在各个不同时期所处状态；的数据结构。称为进程控制块PCB。</li><li>程序与数据：描述进程“本身”所应该完成的功能</li><li>PCB：进程的动态特征，该进程与“其他进程”和“系统资源”的关系。</li><li>进程控制块（内容）：<ul><li>进程标识符：进程符号或者内部id号</li><li>进程当前状态：本进程目前处于何种状态。</li><li>当前队列指针：登记了处于同一状态的“下一个进程的PCB地址”。</li><li>进程优先级：进程提要求CPU的紧迫程度。</li><li>通信信息：进程间通信记录的有关信息。</li><li>家族联系：本进程和家族的联系（子进程、父进程等等）</li></ul></li><li>进程控制块的组织————进程队列结构<ul><li>就绪状态队列：ready_q_start —— 一个或者（最多140个）</li><li>等待打印机队列：wait_lpt_q_start —— 多个（等待打印机、磁盘、键盘等）</li><li>运行指针：running ——一个</li></ul></li><li>进程控制块的作用：<ul><li>修改PCB表项<br>  系统通过修改PCB表项的内容，‘动态记录’该进程‘当前的状态’和‘占有资源’的情况，以便实施有效的管理。</li><li>在进程队列中移动PCB结构<br>  进程控制和进程调度的功能实现，是在相应的进程队列中移动相关的PCB结构。 <h4 id="4-3-进程控制"><a href="#4-3-进程控制" class="headerlink" title="4.3 进程控制"></a>4.3 进程控制</h4></li></ul></li><li>进程状态的变化<ul><li>无 -（创建）- 有 -（撤销）- 消亡</li><li>运行 -（等待）- 等待</li><li>就绪 -（唤醒）- 等待</li><li>创建原语、撤销原语、等待原语、唤醒原语 （原语：原子操作（系统功能调用））</li></ul></li><li>进程创建<ul><li>进程创建原语——create（fork）</li><li>进程创建原语的功能：创建一个具有指定标识符的过程，建立进程的PCB结构</li><li>进程创建原语的实现：PCB池</li></ul></li><li>进程创建原语——create（fork）<ul><li>申请一个空的PCB结构</li><li>无空位报错，有则将入口信息填入PCB的对应项。</li><li>将PCB入就绪队列。</li><li>返回进程pid（PCB池中的位置）。</li></ul></li><li>进程撤销——kill/exit（退出自己）（一个，一组，自己）<ul><li>运行指针获得当前进程的pid</li><li>释放本进程所占用的资源给父进程</li><li>释放PCB结构</li><li>转进程调度</li></ul></li><li>进程等待原语——susp<ul><li>保护CPU现场到PCB结构中</li><li>置该进程为“等待”状态</li><li>将其PCB结构插入到相应等待队列</li><li>转进程调度</li></ul></li><li>进程唤醒原语——wakeup<ul><li>找到该等待队列</li><li>将该结构移出等待队列</li><li>将该进程置为就绪状态，PCB插入就绪队列</li><li>返回刚刚被打断的进程</li></ul></li><li>进程控制功能及其在进程队列上的操作<h4 id="4-4-2-进程互斥的概念"><a href="#4-4-2-进程互斥的概念" class="headerlink" title="4.4.2 进程互斥的概念"></a>4.4.2 进程互斥的概念</h4></li><li>临界资源：系统中有多个进程，共享各种资源，然而有些资源一次只能为一个进程所用。<ul><li>系统资源打印机，A、B共享一台打印机。若任意使用，两进程的输出结果交织在一起。解决方法：A使用之前先提出申请，然后独占，B只有在A释放之后系统才能分给B。</li><li>进程共享公共变量。</li></ul></li><li>临界区：</li><li>互斥：操作系统中。某一进程正在访问某一存储区域时，就不允许其他进程“读出来”或者“修改”该存储区的内容。<h4 id="4-4-3-进程同步的概念"><a href="#4-4-3-进程同步的概念" class="headerlink" title="4.4.3 进程同步的概念"></a>4.4.3 进程同步的概念</h4></li><li>并发进程在一些关键点上可能需要相互等待与互通消息，这种相互制约的等待与互通消息称为进程同步</li><li>共享缓冲区的计算进程与打印进程的同步<ul><li>计算进程cp和打印进程iop公用一个单缓冲</li><li>计算的速度快，输出的速度慢。丢失信息</li><li>计算的速度慢，输出的速度快。重复打印<h4 id="4-5-同步机构"><a href="#4-5-同步机构" class="headerlink" title="4.5 同步机构"></a>4.5 同步机构</h4><h4 id="4-5-1-锁、上锁、开锁"><a href="#4-5-1-锁、上锁、开锁" class="headerlink" title="4.5.1 锁、上锁、开锁"></a>4.5.1 锁、上锁、开锁</h4></li></ul></li><li>每一个共享的临界资源：一个锁单位：0可用，1不可用。</li><li>上锁操作：<ul><li>检测锁位的值（0or1）</li><li>若0变为1（占用）</li><li>若1（占用），返回第一步</li></ul></li><li>开锁操作：使用完之后，锁位变为0。</li><li>上锁原语：保护cpu、当前进程变为等待，插入w的等待队列，转进程调度、w=1</li><li>开锁原语：移除等待队列的首元素，插入到就绪队列、该进程就绪、w=0<br>上锁原语-&gt;临界区-&gt;开锁原语<h4 id="4-5-2-信号等的PV操作"><a href="#4-5-2-信号等的PV操作" class="headerlink" title="4.5.2 信号等的PV操作"></a>4.5.2 信号等的PV操作</h4></li><li>2元组：(s.q)。<ul><li>s&gt;0,表示有可用资源，进程执行，绿灯。</li><li>s&lt;=0，表示没有可用资源，停止执行，红灯。</li></ul></li><li>P操作：P(s)；s减1（大于等于0返回，小于0（进程被阻）入信号灯等待队列，置为“等待状态”，转进程调度）</li><li>V操作：V(s)：S加一。大于0返回，小于等于0唤醒（从信号灯的等待队列中取出首元素、入就绪队列、置“就绪状态”、返回）<h4 id="4-6-进程互斥与同步的实现"><a href="#4-6-进程互斥与同步的实现" class="headerlink" title="4.6 进程互斥与同步的实现"></a>4.6 进程互斥与同步的实现</h4><h4 id="4-6-1-用上锁原语和开锁原语实现进程互斥"><a href="#4-6-1-用上锁原语和开锁原语实现进程互斥" class="headerlink" title="4.6.1 用上锁原语和开锁原语实现进程互斥"></a>4.6.1 用上锁原语和开锁原语实现进程互斥</h4>上锁原语-&gt;进入临界区cs-&gt;开锁原语 （main函数中设置w=1）<h4 id="4-6-2-用信号灯的P、V操作实现互斥"><a href="#4-6-2-用信号灯的P、V操作实现互斥" class="headerlink" title="4.6.2 用信号灯的P、V操作实现互斥"></a>4.6.2 用信号灯的P、V操作实现互斥</h4></li><li>mutex:互斥信号灯  </li><li>p(mutex)-&gt;临界区cs-&gt;v(mutex)</li><li>若有两个并发进程<ul><li>mutex=1:没有程序进入临界区</li><li>mutex=0:有一个程序进入临界区</li><li>mutex=-1:一个程序进入临界区，另一个程序等待进入</li></ul></li><li>若有n个并发进程，则可能有1,0,-1,…,-(n-1)取值</li><li>信号灯s为正值：挂起进程前还可以使用的P操作数，等于s还可以使用的物理资源数。</li><li>s为负值：在信号灯s队列中等待的进程个数。</li><li>P操作：请求一个资源/挂起进程，V操作：释放一个资源/唤醒进程。<br>化验单-&gt;化验进程-》开始工作<br>化验进程-》化验结果-》看病进程-》医疗方案。<h4 id="4-6-3-进程同步的实现"><a href="#4-6-3-进程同步的实现" class="headerlink" title="4.6.3 进程同步的实现"></a>4.6.3 进程同步的实现</h4></li><li>合作进程的执行次序</li><li>共享缓冲区的合作进程的同步的解法  </li><li>考虑4.4.3节中提到的问题<ol><li>sa表示缓冲区中是否有可供打印的计算结果，初值为0。</li><li>sb表示缓冲区有无空位置存放新的信息，其初值为1。</li></ol></li></ul><h4 id="4-6-4-生产者和消费者"><a href="#4-6-4-生产者和消费者" class="headerlink" title="4.6.4 生产者和消费者"></a>4.6.4 生产者和消费者</h4><ul><li>计算进程和打印进程<ul><li>多个计算进程cp不断产生数据，生产者</li><li>多个打印进程iop不断打印数据，消费者</li><li>有多个缓冲区</li></ul></li><li>通信问题<ul><li>发消息进程send不断产生消息，生产者</li><li>受消息recieve不断接收消息，消费者</li></ul></li><li>生产者和消费者的同步关系<ul><li>生产者：有界缓冲区无空位，等待；放入物品，发消息</li><li>消费者：无物品，等待；取物品，发消息</li></ul></li><li>信号灯的设置<ul><li>两个同步信号灯<ul><li>sb：缓冲区的数目，初值=n</li><li>sa：信息数目，初值=0</li></ul></li><li>一个互斥信号灯<ul><li>mutex：有界缓冲区是否被占用，初值=1。</li></ul></li></ul></li></ul><h4 id="4-7-进程通信-IPC"><a href="#4-7-进程通信-IPC" class="headerlink" title="4.7 进程通信(IPC)"></a>4.7 进程通信(IPC)</h4><ul><li>概念：进程之间直接以<code>较高的效率</code>传递<code>较多数据</code>的信息交互方式。也是两个不同的进程<code>共享数据</code>的方式。</li><li>实现：消息缓冲器、发送操作、接收操作</li><li>发送进程和接受进程的同步：发送等待、接受等待。<h4 id="4-7-2-进程通信的方式"><a href="#4-7-2-进程通信的方式" class="headerlink" title="4.7.2 进程通信的方式"></a>4.7.2 进程通信的方式</h4></li><li>消息缓冲通信<ul><li>信息头：发送进程的标识符、接受进程的标识符、传送信息的字节数。</li><li>消息缓冲、发送原语、接受原语：每一次想要发送消息，形成一个消息缓冲区，消息原语将消息发出；接受进程在本进程主存空间形成一个接受区，接受原语接受消息。</li></ul></li><li>信箱通信<ul><li>定义信箱结构</li><li>消息发送模块、功能接受模块：提供发送原语和接受原语</li><li>所使用的信箱可以用于用户空间中（接受进程地址空间的一部分）、也可以用于操作系统空间中。</li></ul></li><li>下面两个？？</li><li>sys V进程通信方式<ul><li>信号量</li><li>共享内存</li><li>消息队列</li></ul></li><li>posix进程间通信方式<ul><li>共享内存</li><li>信号量<h4 id="4-8-线程的概念及特点"><a href="#4-8-线程的概念及特点" class="headerlink" title="4.8 线程的概念及特点"></a>4.8 线程的概念及特点</h4></li></ul></li><li>概念：比进程更小的活动单位，进程中的一个执行路径。</li><li>描述：进程中的一条执行路径、有自己私用的运行栈和处理机执行环境、与其他线程“共享”分配给进程的“内存和文件”、单个进程是创建的多个同时存在的线程中的一个。线程是一个动态概念。</li><li>线程调用实例<h4 id="4-9-操作系统的并发机制实例"><a href="#4-9-操作系统的并发机制实例" class="headerlink" title="4.9 操作系统的并发机制实例"></a>4.9 操作系统的并发机制实例</h4></li><li>创建进程及应用实例</li><li>创建线程及应用实例</li><li>等待进程、线程的终止及应用</li><li>信号量与使用方法</li><li>共享内存及应用实例<h4 id="4-10-进程调度"><a href="#4-10-进程调度" class="headerlink" title="4.10 进程调度"></a>4.10 进程调度</h4></li><li>调度/分派结构：多个就绪状态的进程对处理机的竞争是由进程调度程序来协调的。<ul><li>调度：就绪状态的进程排序。将一个进程插入到就绪队列，按照一定策略排序。</li><li>分派：调度时机，就绪队列第一个进程移出，建立其在处理机上执行环境，在处理机执行。</li></ul></li><li>调度的功能<ul><li>记录进程的状态变化</li><li>决定调度策略：1.优先调度、2.FIFO</li><li>实施处理机的分配和回收</li></ul></li><li>调度时机<ul><li>运行-》等待（阻塞）</li><li>运行-》就绪（时间片到）</li><li>等待-》就绪（唤醒）</li><li>任务完成，终止</li><li>异常出错</li><li>可剥夺调度，出现更高优先级的就绪进程。</li></ul></li><li>调度方式：“重要而紧迫”的进程怎么处理<ul><li>剥夺方式：暂停current，处理机给“重要而紧迫”</li><li>非剥夺方式：继续current，直到该进程完成或发生某事件到“完成”、“阻塞”，才给“重要而紧迫”</li></ul></li><li>调度算法<ul><li>进程优先数调度算法<ul><li>优先数的分类和确定<ol><li>静态优先数：根据所需资源来计算、基于程序运行时间估计、基于进程类型。</li><li>动态优先数：CPU超过一定时间降低、I/O增加，等待时间超过一定时间增加。</li></ol></li></ul></li><li>循环轮转调度算法<ul><li>时间片的计算：q=t/n （t为用户能接受的响应时间，n为进入系统的进程数目）</li><li>时间片的选取：太小，系统切换很频繁（切换时间不可忽略），从系统角度来看，时间片取大比较好。太大，轮转一次的总时间增大，对进程的响应速度放慢了。  </li><li>可变时间片轮转调度：根据系统当前的进程树来确定时间片的大小。</li><li>多级时间片循环调度<ul><li>多个就绪队列</li><li>先进入高优先级队列，高优先级队列的时间片较小。</li><li>用完后，进入下一级队列，优先级降低，但时间片增大一倍。</li><li>这个算法，较小时间片处理完较短进程，避免较长进程被频繁中断。</li></ul></li><li>时间片与优先级混合调度算法<ul><li>I/O后进入因I/O而等待队列，完成后进入高优先就绪。</li><li>运行时间片到了，进入低优先就绪队列。</li><li>CPU空闲时，若高优先就绪队列非空，则从高优先就绪队列中选择一个进程运行，分配时间片100ms。</li><li>CPU空闲时，若高优先就绪队列为空，则从低优先就绪队列中选择一个程序运行，分配时间片为500ms。</li><li>照顾I/O量大的进程，适当照顾计算量大的进程，提高系统资源利用率。</li></ul></li></ul></li></ul></li></ul><h3 id="第五章-资源分配与调度"><a href="#第五章-资源分配与调度" class="headerlink" title="第五章 资源分配与调度"></a>第五章 资源分配与调度</h3><h4 id="5-1-资源管理概述"><a href="#5-1-资源管理概述" class="headerlink" title="5.1 资源管理概述"></a>5.1 资源管理概述</h4><ul><li>资源管理的目的和任务</li><li>虚拟资源<h4 id="5-2-资源管理的机制和策略"><a href="#5-2-资源管理的机制和策略" class="headerlink" title="5.2 资源管理的机制和策略"></a>5.2 资源管理的机制和策略</h4></li><li>资源分配机制</li><li>资源分配策略<h4 id="5-3-死锁"><a href="#5-3-死锁" class="headerlink" title="5.3 死锁"></a>5.3 死锁</h4></li><li>定义与示例</li><li>原因和必要条件</li><li>系统模型和死锁的处理</li></ul><h3 id="第六章-主存管理"><a href="#第六章-主存管理" class="headerlink" title="第六章 主存管理"></a>第六章 主存管理</h3><h4 id="6-1-主存管理概述"><a href="#6-1-主存管理概述" class="headerlink" title="6.1 主存管理概述"></a>6.1 主存管理概述</h4><ul><li>主存分片共享</li><li>程序的逻辑组织（一维地址和二维地址）<h4 id="6-2-主存管理功能"><a href="#6-2-主存管理功能" class="headerlink" title="6.2 主存管理功能"></a>6.2 主存管理功能</h4></li><li>虚拟存储器</li><li>地址映射</li><li>主存分配</li><li>存储保护<h4 id="6-3-分区存储管理"><a href="#6-3-分区存储管理" class="headerlink" title="6.3 分区存储管理"></a>6.3 分区存储管理</h4></li><li>动态分区存储管理技术</li><li>分区分配机构/</li><li>分区分配与安置策略（安置策略的算法首次适应、最佳适应、最坏适应）</li><li>碎片问题及拼接技术/<h4 id="6-4-页式存储管理"><a href="#6-4-页式存储管理" class="headerlink" title="6.4 页式存储管理"></a>6.4 页式存储管理</h4></li><li>页式系统应解决的问题<ul><li>页式系统的地址映射</li><li>请调策略</li><li>放置策略</li><li>淘汰策略</li></ul></li><li>页式地址变换</li><li>请调页面的机制</li><li>淘汰机制与策略</li><li>几种置换算法（OPT、FIFO、LRU、）<h4 id="6-5-段式及段页式存储管理"><a href="#6-5-段式及段页式存储管理" class="headerlink" title="6.5 段式及段页式存储管理"></a>6.5 段式及段页式存储管理</h4></li><li>段式地址结构</li><li>段式地址变换</li><li>扩充段表功能</li><li>段页式存储管理</li></ul><h3 id="第七章-设备管理（I-O管理）"><a href="#第七章-设备管理（I-O管理）" class="headerlink" title="第七章 设备管理（I/O管理）"></a>第七章 设备管理（I/O管理）</h3><h4 id="7-1-设备管理概述"><a href="#7-1-设备管理概述" class="headerlink" title="7.1 设备管理概述"></a>7.1 设备管理概述</h4><ul><li>设备管理的功能</li><li>设备的独立性</li><li>设备控制块<h4 id="7-2-缓冲技术"><a href="#7-2-缓冲技术" class="headerlink" title="7.2 缓冲技术"></a>7.2 缓冲技术</h4></li><li>缓冲概述</li><li>常用的缓冲技术</li><li>UNIX系统的缓冲区管理<h4 id="7-3-设备分配"><a href="#7-3-设备分配" class="headerlink" title="7.3 设备分配"></a>7.3 设备分配</h4>（为计算机所有的用户程序、活动的进程分配它们所需的外部设备）</li><li>设备分配概述</li><li>独享分配</li><li>共享分配</li><li>虚拟分配<h4 id="7-4-输入-输出控制"><a href="#7-4-输入-输出控制" class="headerlink" title="7.4 输入/输出控制"></a>7.4 输入/输出控制</h4>（软件控制硬件：端口、总线、控制器）</li><li>输入/输出硬件</li><li>输入/输出控制方式</li><li>输入/输出子系统</li><li>输入/输出控制的例子<br>（以设备处理进程方式为例讨论I/O的控制过程）</li></ul><h3 id="第八章-文件系统"><a href="#第八章-文件系统" class="headerlink" title="第八章 文件系统"></a>第八章 文件系统</h3><h4 id="8-1-文件系统概述"><a href="#8-1-文件系统概述" class="headerlink" title="8.1 文件系统概述"></a>8.1 文件系统概述</h4><ul><li>文件</li><li>文件系统</li><li>文件的组织<h4 id="8-2-文件的逻辑结构和存取方法"><a href="#8-2-文件的逻辑结构和存取方法" class="headerlink" title="8.2 文件的逻辑结构和存取方法"></a>8.2 文件的逻辑结构和存取方法</h4></li><li>文件的逻辑结构</li><li>文件的存取方法<h4 id="8-3-文件的物理结构"><a href="#8-3-文件的物理结构" class="headerlink" title="8.3 文件的物理结构"></a>8.3 文件的物理结构</h4></li><li>连续文件</li><li>串联文件</li><li>索引文件</li><li>文件物理结构比较（连续、串联、索引）<h4 id="8-4-文件存储空间的管理"><a href="#8-4-文件存储空间的管理" class="headerlink" title="8.4 文件存储空间的管理"></a>8.4 文件存储空间的管理</h4></li><li>空闲文件目录</li><li>空闲块链</li><li>位示图</li><li>分配策略<h4 id="8-5-文件目录"><a href="#8-5-文件目录" class="headerlink" title="8.5 文件目录"></a>8.5 文件目录</h4></li><li>文件目录及其内容</li><li>一级文件目录及缺点</li><li>多级文件目录<h4 id="8-6-共享与安全"><a href="#8-6-共享与安全" class="headerlink" title="8.6 共享与安全"></a>8.6 共享与安全</h4></li><li>文件共享与安全性的关系</li><li>存取权限的类型及其验证</li><li>用文件路径名加快文件的查找<h4 id="8-7-文件操作与文件备份"><a href="#8-7-文件操作与文件备份" class="headerlink" title="8.7 文件操作与文件备份"></a>8.7 文件操作与文件备份</h4></li><li>文件操作</li><li>文件备份<h4 id="8。8-UNIX文件系统的主要结构及实现"><a href="#8。8-UNIX文件系统的主要结构及实现" class="headerlink" title="8。8 UNIX文件系统的主要结构及实现"></a>8。8 UNIX文件系统的主要结构及实现</h4></li><li>UNIX文件系统的特点</li><li>UNIX系统的索引文件结构</li><li>UNIX系统文件目录结构</li><li>UNIX系统的打开文件机构</li><li>文件存储器空闲块的管理</li><li>UNIX文件系统调用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机操作系统学习-amp-复习笔记&quot;&gt;&lt;a href=&quot;#计算机操作系统学习-amp-复习笔记&quot; class=&quot;headerlink&quot; title=&quot;计算机操作系统学习&amp;amp;复习笔记&quot;&gt;&lt;/a&gt;计算机操作系统学习&amp;amp;复习笔记&lt;/h2&gt;&lt;p&gt;参考书目：计
      
    
    </summary>
    
    
      <category term="CS Courses" scheme="www.waylonding.cn/blog/categories/CS-Courses/"/>
    
    
      <category term="System &amp; Network" scheme="www.waylonding.cn/blog/tags/System-Network/"/>
    
      <category term="Operating System" scheme="www.waylonding.cn/blog/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>ComputerNetwork Notes</title>
    <link href="www.waylonding.cn/blog/2019/11/19/ComputerNetwork-Review-Notes/"/>
    <id>www.waylonding.cn/blog/2019/11/19/ComputerNetwork-Review-Notes/</id>
    <published>2019-11-19T08:13:01.000Z</published>
    <updated>2019-12-03T13:00:41.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络-自顶向下-学习笔记-amp-计算机通信与网络课程复习"><a href="#计算机网络-自顶向下-学习笔记-amp-计算机通信与网络课程复习" class="headerlink" title="计算机网络-自顶向下 学习笔记 &amp; 计算机通信与网络课程复习"></a>计算机网络-自顶向下 学习笔记 &amp; 计算机通信与网络课程复习</h2><p>参考书目：计算机网络-自顶向下方法（原书第7版）</p><h3 id="第1章-计算机网络和因特网"><a href="#第1章-计算机网络和因特网" class="headerlink" title="第1章 计算机网络和因特网"></a>第1章 计算机网络和因特网</h3><h4 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h4><ul><li>定义：互联、自治（无主从关系）的计算机集合</li><li>全球最大的互联网络：ISP网络互联的“网络之网络”<ul><li>计算机设备集合：主机=端系统（运行各种网络运用）</li><li>通信链路：光纤、铜缆、无线电等等；传输速率=带宽</li><li>分组交换：转发分组（数据包）：路由器和交换机</li><li>端系统接入Internet靠服务提供商ISP，协议控制因特网中的信息接收和发送</li><li>因特网标准：RFC、IETF</li></ul></li><li>因特网的服务视角<ul><li>为网络应用提供通讯服务的通信基础设施：Web、VoIP、email等</li><li>为网络应用提供应用编程接口（API）：支持应用程序连接网络，提供类似邮政系统的数据传输服务<h4 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h4></li></ul></li><li>网络结构的深入研究<ul><li>网络边缘：主机、位于数据中心的服务器</li><li>网络核心：路由器、网络的网络</li><li>接入网、物理媒体：通信链路（有线或者无线的通信链路）</li></ul></li><li>主机（端系统）：位于网络边缘、运行网络程序</li><li>通信模型：C/S模型和P2P （客户机和服务器）<ul><li>C/S：Web应用、文件传输FTP请求</li><li>P2P：QQ、Skype、BT</li></ul></li><li>接入网络<ul><li>将网络边缘接入网络核心（端系统连接到边缘路由器）</li><li>边缘路由器：端系统到任何其他远程系统路径上的第一台路由器</li><li><h4 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h4></li></ul></li><li>基本问题：数据如何通过网络传输</li><li>关键功能：路由（确定从源到目的）+转发（将分组从路由器的输入端口交换至正确的输出端口）</li><li>电路交换<ul><li>过程：建立连接、交换数据（通信）、释放连接</li><li>特点：独占资源、确定链路、实时传输不会延迟</li><li>多路复用（共享信道）<ul><li>方法：频分多路复用——FDM、时分多路复用——TDM、波分多路复用——WDM、码分多路复用——CDM</li><li>CDM（码分多路复用）：广泛用于无线链路共享<ul><li>每个用户分配一个唯一的m bit的码片序列（0用-1表示，1用+1表示）</li><li>编码=(码片序列*数据序列)_求和</li><li>解码=码片序列*编码信号/m</li><li>要点：接收哪个用户的数据，用哪个数据的码片序列。</li></ul></li></ul></li><li>存在的问题：网络有突发性、间歇性，不合适；不够灵活；</li></ul></li><li>报文交换：源/应用发送整体信息（例如一个文件）给目的主机</li><li>分组交换（存储、转发）<ul><li>报文分拆出来的一些列相对较小的数据包</li><li>分组交换需要报文的拆分和重组，需要额外开销（加头）</li><li>分组传输时间延迟：delay=L/R</li><li>T=M/R+nL/R</li></ul></li><li>分组交换VS电路交换<ul><li>相同条件下：分组交换能够比电路交换支持更多的用户</li><li>若要连续传输大量数据（及传送时间远远大于呼叫建立时间），则采用电路交换）</li><li>应对突发数据、间接数据的时候，采用分组交换比较合适</li></ul></li><li>网络核心分类：<ul><li>电信网络：电路交换网络（FDM、TDM）、分子交换网络（虚电路网络、数据报网络）</li></ul></li><li>ISP和因特网主干<ul><li>端系统-&gt;internet：接入ISP——家庭、公司、大学ISPs</li><li>接入ISP进一步互联：这样任任意两个主机才能互相发送分组</li><li>当前internet结构：十分复杂，无人能够给出准确描述</li><li>网络的网络<ul><li>若所有的接入ISP直接互联O(N^2)!太大</li><li>可选方案1: 每个接入ISP连接到一个国家或全球ISP.(主干ISP)</li><li>商业角度会有竞争对手：会有多个ISP集群</li><li>但是这些ISP必须互联，产生：对等链路和IXP(internet exchange point)</li><li>可能出现区域网络（reginal net）连接接入ISP</li><li>内容提供商网络可以运行自己的网络，将服务、内容靠近最终用户。</li></ul></li><li>最后结构为：<ul><li>一级商业ISP：tier-1：提供国家或国际范围的覆盖</li><li>内容提供商网络（google）：私有网络，连接其数据中心与internet（绕过一级ISP和区域ISPs）<h4 id="1-4-分组交换网中的时延、丢包和吞吐量"><a href="#1-4-分组交换网中的时延、丢包和吞吐量" class="headerlink" title="1.4 分组交换网中的时延、丢包和吞吐量"></a>1.4 分组交换网中的时延、丢包和吞吐量</h4></li></ul></li></ul></li><li>k=10^3, M=10^6, G=10^9, T=10^12</li><li>时延<ul><li>原因：分组到达速率&gt;输出链路容量、分组排队、等待输出链路可用</li><li>d_nodal = d_proc + d_queue + d_trans + d_prop</li><li>d_proc: 节点处理延迟——差错检测，确定输出链路，通常&lt;毫秒</li><li>d_queue: 排队延迟——输出链路等待传输的时间，取决于路由器的拥塞程度</li><li>d_trans: 传输时延——L分组长度，R链路带宽，d_trans=L/R</li><li>d_prop: 传播时延——d物理链路长度，s媒体中的传播速度，d_prop=d/s</li><li>在一个节点从前到后依次是：节点处理时延(d_proc)、排队时延(d_queue)、传输时延(d_trans)、传播时延(d_prop)</li></ul></li><li>排队时延<ul><li>链路带宽R，分组长度L，平均分组到达速率a。</li><li>流量强度=La/R<ul><li>La/R-&gt;0:平均排队时延很小，甚至为0</li><li>La/R&lt;1：时延较小，且会随着时间的推延而变小</li><li>La/R=1：时延不会变化，具体数值取决于当时队列长度</li><li>La/R&gt;1：平均时延较大，且随时间的推延而趋于无穷</li></ul></li><li>分组丢失的原因和后果<ul><li>缓存中队列的容量是有限的</li><li>分组到达队列已满，分组被丢弃</li><li>被前一个节点、源端系统重新传输，或者根本不会重传</li></ul></li></ul></li><li>时延带宽积=传播时延*带宽：比特单位的链路长度</li><li>丢包（分组丢失）<ul><li>原因：分组到达已满队列，将被丢弃；丢弃分组可能由前序节点或者源重新发送（或者不发送）</li><li>丢包率=丢包数/已发送分组总数</li></ul></li><li>吞吐量：表示在发送端与接受端之间传送数据的速率<ul><li>即时吞吐量：给定时刻的速率</li><li>平均吞吐量：一段时间的平均速率</li><li>瓶颈链路：端到端路径上，限制选到端吞吐量的链路</li><li>internet场景<ul><li>min(Rs,Rc,R/10): 10条链路共享<h4 id="1-5-协议层次及服务模型"><a href="#1-5-协议层次及服务模型" class="headerlink" title="1.5 协议层次及服务模型"></a>1.5 协议层次及服务模型</h4></li></ul></li></ul></li><li>计算机网络的体系结构<ul><li>分层结构</li><li>每一层完成特定种类的服务/功能，每一层依赖底层提供的服务，通过层内的动作完成相应的功能</li><li>体系结构是计算机网络隔层及其协议的集合，是抽象的</li></ul></li><li>分层结构的好处：关系清晰；有利于系统更新、维护；有利于标准化。<ul><li>分层的参考模型（refernce model）可用于讨论</li></ul></li><li>因特网的协议栈<ul><li>应用层：支持网络应用<ul><li>FTP、SMTP、HTTP</li></ul></li><li>运输层：主机间的数据传输（端到端的传输）<ul><li>TCP、UDP</li><li>连接控制、流量控制、差错控制、分段与重组、SAP殉职（将完整报文提交给正确进程）</li></ul></li><li>网络层：将数据报从源端重送到目的端<ul><li>IP、路由协议</li><li>路由和分组转发、逻辑寻址、IP全局唯一</li></ul></li><li>链路层：数据在网络相邻节点之间的传输<ul><li>PPP、以太网、802.11</li><li>流量控制、差错控制、访问控制</li><li>node-to-node数据传输、组帧、物理寻址</li></ul></li><li>物理层：在线路上传输比特流<ul><li>接口特性、传输模式（单工、全/半双工）、比特同步、数据率、比特编码</li></ul></li></ul></li><li>基本概念<ul><li>实体（entity）：任何可以发送和接收消息的“硬件”和“软件进程”，通常是一个特定的“软件模块”。</li><li>对等体（peer）：不同机器上包含对应层的实体称为对等体</li><li>协议（protocal）<ul><li>语法：即数据与控制信息的结构或者格式</li><li>语义：何种控制消息，完成何种动作，做出何种应答</li><li>同步：事件实现顺序</li></ul></li><li>服务（service）：保证上层对等体之间能互相通信，“下层向上层”提供的功能</li><li>服务原语：邻层交互交换的必要命令</li><li>注意：协议是同层，服务是邻层</li><li>协议数据单元（PDU）：对等层次上传输的数据但愿</li><li>服务数据单元（SDU）：层与层之间交换的数据单元</li><li>网络体系结构（Network Architrcture）：层和协议的集合</li><li>协议栈：特定的系统使用的一组协议（每层一个协议）</li></ul></li><li>报文的封装<ul><li>应用层：报文</li><li>运输层：报文段=报文+首部</li><li>网络层：数据报=报文段+首部</li><li>链路层：帧=数据报+首部+尾部</li><li>物理层：比特流</li></ul></li><li>OSI参考模型（由国际标准化组织ISO提出）<ul><li>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li><li>表示层：应用程序解释数据的含义：加密、压缩、数据表示转化（转换为主机独立的编码）</li><li>会话层：数据交换、同步、定界、建立检查点、恢复能力（最薄一层）</li><li>实际internet没有表示层和会话层，全部交给了应用开发者，交给了应用层</li></ul></li><li>TCP/IP模型<ul><li>应用层（HTTP、SMTP）、运输层（TCP、UDP）、网际层（IP）、网络接口层（网络接口）</li></ul></li><li>5层参考模型：综合TCP/IP模型和OSI模型<h3 id="第2章-应用层"><a href="#第2章-应用层" class="headerlink" title="第2章    应用层"></a>第2章    应用层</h3><h4 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h4><h4 id="2-2-Web和HTTP"><a href="#2-2-Web和HTTP" class="headerlink" title="2.2 Web和HTTP"></a>2.2 Web和HTTP</h4><h4 id="2-3-因特网中的电子邮件"><a href="#2-3-因特网中的电子邮件" class="headerlink" title="2.3 因特网中的电子邮件"></a>2.3 因特网中的电子邮件</h4><h4 id="2-4-DNS：因特网的目录服务"><a href="#2-4-DNS：因特网的目录服务" class="headerlink" title="2.4 DNS：因特网的目录服务"></a>2.4 DNS：因特网的目录服务</h4><h4 id="2-5-P2P文件分发"><a href="#2-5-P2P文件分发" class="headerlink" title="2.5 P2P文件分发"></a>2.5 P2P文件分发</h4></li></ul><h3 id="第3章-运输层"><a href="#第3章-运输层" class="headerlink" title="第3章    运输层"></a>第3章    运输层</h3><h4 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h4><ul><li>运输层：不同进程、逻辑通信（只考虑点到点，不考虑点和点之间的具体构造）</li><li>网络层：不同主机，逻辑通信<ul><li>家庭通信的例子：进程=（要发信息的）孩子们，应用消息（报文）=信封，主机=房子，传输层协议=要送信给邮局的人，网络层协议=邮政服务</li></ul></li><li>UDP数据报、TCP报文段</li><li>TCP差错检测、拥塞控制、可靠数据传输（连接建立）<h4 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2 多路复用与多路分解"></a>3.2 多路复用与多路分解</h4></li><li>接收端进行多路分用：传输层依据头部信息，将收到的segement交给正确的socket</li><li>发送端进行多路复用：从多个socket接收数据，为每块数据封装上头部信息，生成segmennt，交给网络层。</li><li>数据报携带一个传输层的段（报文段）：每个段携带<code>源端口号</code>和<code>目的端口号</code>。</li><li>无连接的多路分用<ul><li>UDP的Socket二元组表示：（目的IP，目的port）</li><li>携带源端口号，以便信息反馈</li><li>创建port：DatagramSocket mySocket1=new DatagramSocket(12345);</li></ul></li><li>面向连接的分用<ul><li>TCP Socket的四元组表示（源IP，源port，目的IP，目的port）</li><li>多线程的Web服务器：进程创建多线程，多TCP连接<h4 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h4></li></ul></li><li>基于internet的IP协议：多路复用和分用、简单的错误校验</li><li>best effort服务，可能：丢失、非按顺序到达</li><li>优点：减少连接时延、实现和维护简单、首部开销小、无拥塞控制（更好地控制发送时间和速率）</li><li>流媒体、DNS、SNMP</li><li>应用层实现可靠传输</li><li>报文结构：源port（16）、目的port（16）、length（16）、checksum（16）</li><li>checksum：段的内容视为16bit整数：取和，进位加在后面，按位求反。接收方计算校验和和校验字段进行比对：不等有错，相等不一定没错。<h4 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h4></li><li>可靠的定义：不错、不丢、不乱。</li><li>可靠数据传输协议：rdt。TOP-10问题！</li><li>可靠数据传输协议的基本结构：接口<ul><li>rdt_send():上层应用调用，将数据交给rdt以发送给对方</li><li>udt_send():被rdt调用，在不可靠信道上向接收方传输数据</li><li>rdt_rcv():分组到达接收方信道时被调用</li><li>diliver_data():被rdt调用，向上层应用交付数据</li><li>注意：分组在不可靠信道上传输是双向的，而上层接收和交付数据是单向的</li><li>packet=make_pkt(data):把数据打包变成分组</li><li>extract(packet,data):把分组提取变成数据</li></ul></li><li>Rdt1.0:可靠信道上的可靠数据传输<ul><li>不会发生错误、不会丢弃分组</li><li>FSM见PPT27面</li></ul></li><li>Rdt2.0:产生位错误的信道（0反转位1，1反转为0）<ul><li>ARQ协议<ul><li>一种重传机制的rdt协议</li><li>校验和检测错误</li><li>ACK/NAK: 显式地，正确接收/分组有错误</li><li>NAk: 重传分组</li><li>引入的新机制有：差错检测、接收方反馈控制消息ACK/NAK、重传</li></ul></li><li>FSM<ul><li>发送方：停-等协议<ul><li>等状态：等待来自上层的调用</li><li>停状态：等待ACK或NAK</li><li>分组增加校验和：snd_pkt(data,checksum)</li><li>判断收到了NAK，重传分组：rdt_rcv(rcvpkt)&amp;&amp;isNAK(rcvpkt)-&gt;udt_send(sndpkt)</li><li>判断收到了ACK，回到等状态，action为空：rdt_rcv(rcvpkt)&amp;&amp;isACK(rcvpkt)</li></ul></li><li>接收方<ul><li>判断分组被损毁，返回NAK：rdt_rcv(rcvpkt)&amp;&amp;corrupt(rcvpkt)-&gt;udt_send(NAK)</li><li>判断分组正常，提取数据交付上层，返回ACK：rdt_rcv(rcvpkt)&amp;&amp;notcorrupt(rcvpkt)-&gt;extract(rcvpkt,data),diliver_data(data),udt_send(ACK)</li></ul></li></ul></li></ul></li><li>Rdt2.1&amp;&amp;Rdt2.2: 解决NAK、ACK错误的情况<ul><li>Rdt2.1<ul><li>如果错误，就重传。重传会产生重复分组，解决重复分组，添加序列号实现，接收方丢弃重复分组。两个序列号（0，1）即可</li><li>FSM：</li></ul></li><li>Rdt2.2: 无NAK的消息协议<ul><li>发送方收到重复ACK之后，重传</li><li>FSM</li></ul></li></ul></li><li>Rdt3.0: 处理分组丢失问题<ul><li>发送方等待合理时间：如果没有ACK，重传<ul><li>增加定时器</li><li>FSM见PPT</li></ul></li><li>几种典型场景见PPT<ul><li>没有丢失</li><li>丢失packet</li><li>丢失ACK</li><li>过早超时</li></ul></li><li>Rdt3.0的性能分析：见PPT<ul><li>U_sender=(L/R)/(RTT+L/R) 性能很差</li></ul></li></ul></li><li>提高Rdt性能：流水线传输以及滑动窗口协议<ul><li>等待过程中可以发送其他分组，N段流水性能提高N倍</li><li>窗口：允许使用的序列号范围，尺寸为N即最多有N个等待确认的消息</li></ul></li><li>GBN<br>  * </li><li>SR<ul><li><h4 id="3-5-面向连接的运输：TCP"><a href="#3-5-面向连接的运输：TCP" class="headerlink" title="3.5 面向连接的运输：TCP"></a>3.5 面向连接的运输：TCP</h4></li></ul></li><li>TCP将IP层的不可靠变为可靠</li><li>技术：流水线机制、累计确认、单一重传定时器<ul><li>出发重传的事件：超时、收到重复的ACK</li></ul></li><li>如何估计RTT<ul><li>SampleRTT：从段发出去到收到ACK的事件</li><li>SampleRTT的变化值：测量多个RTT求平均值（指数加权移动平均）<br>EstimatedRTT=(1-alpha)<em>EstimatedRTT+alpha</em>SampleRTT (alpha=0.125)</li><li>测量RTT的变化值：SampleRTT和EstimatedRTT的差值<br>DevRTT=(1-beta)<em>DevRTT+beta</em>|SampleRTT-EstimatedRTT| (beta=0.25)</li><li>TimeoutInterval=EstimatedRTT+4*DevRTT</li></ul></li><li>发送方<ul><li>创建segment，序列号：segment第一个字节的编号。</li><li>开启计时器，设置超时时间TimeOutInterval</li><li>超时：重传引起超时的Segment，重起定时器</li><li>shoudaoACK：更新SendBase，若窗口中还有没有被确认的分组，重起定时器</li></ul></li><li>快速重传机制<ul><li>重复ACK检测分组丢失：如果sender收到对于同一个数据的3个ACK，即假定该数据之后的段已经丢失，在计时器超时之前即进行重传</li><li>超时间隔加倍：每一次TCP重传均将下一次超时间隔设置为先前值的两倍</li></ul></li><li>流量控制<ul><li>发送方数据过快过多，淹没接收方（buffer溢出）</li><li>窗口值的计算<ul><li>接收方：LastByteRcvd – LastByteRead ≤ RcvBuffer<br>RcvWindows = RcvBuffer – [LastByteRcvd - LastByteRead]</li><li>发送方：LastByteSent – LastByteAcked ≤ RcvWindow</li><li>特殊情况：RcvWindow=0，无任何数据给发送方，发送方会向接收方发送只有一个字节数据的报文段，目的是试探</li></ul></li></ul></li><li>连接管理<ul><li>初始化TCP变量<ul><li>序列号、Buffer和流量控制信息</li><li>三次握手<ul><li>客户发送SYN报文段：告知服务器序列号</li><li>服务器收到SYN报文段，回复SYNACK报文段：建立缓存区、回复序列号</li><li>客户端收到SYNACK，回复ACK报文段，可能包含数据</li></ul></li></ul></li><li>关闭请求：一般是客户机关闭<ul><li>客户机向服务器发送TCP FIN报文段</li><li>服务器收到FIN，回复ACK，关闭连接，发送FIN</li><li>收到FIN，回复ACK；重复收到FIN，重发ACK</li><li>服务器收到ACK，真正关闭连接</li></ul></li><li>TCP连接管理的状态序列：见PPT81<h4 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6 拥塞控制原理"></a>3.6 拥塞控制原理</h4></li></ul></li><li>拥塞的表现：分组丢失、分组延迟过大</li><li>拥塞控制和流量控制的区别：拥塞控制着眼于网络处理，流量控制着眼于接收方处理</li><li>场景一：两个发送方、两个接收方，一个具有无限大缓存的路由器，没有重传。假定带宽为C。PPT83 </li><li>场景二：有限缓存的一个路由器<ol><li>如果sender知道buffer信息，有buffer发数据，没有buffer就不发。lamdaIn=lamdaOut</li><li>丢失后才重发。lamdaIn‘&gt;lamdaIn&gt;=lamdaOut</li><li>定时器超时重传。lamdaIn‘&gt;&gt;lamdaIn=lamdaOut<br>不必要的重传会占用链路带宽</li></ol></li><li>场景三：四个发送方、多跳、超时/重传<ul><li>另一个代价：分组被drop掉了，相当于浪费了上游的资源。</li><li>lamdaIn’过大，lamdaOut趋近于0，即所有资源都被浪费掉了</li></ul></li><li>拥塞控制的方法<ul><li>端到端的拥塞控制：TCP的方法。路由器不需要提供支持，观察丢失、时间延迟等网络行为判断是否拥塞。</li><li>网络辅助的拥塞控制：路由器向发送方显示地反馈网络拥塞信息。（阻塞分组的形式指示发送方应该采取何种速率）</li><li>ATM ABR拥塞控制（网络辅助）<ul><li>RM cells：交换机设置RM cell位：NI bit——rate不允许增长，CI bit——拥塞指示。RM cell由接收方返回给发送方</li><li>RM cell的ER字段（两个字节）：显式的速率字段，发送方货值路径所能支持的最小速率</li><li>数据cell的EFCI位：拥塞的交换机将其设置为1，如果RM cell前面的data cell的EFCI为1，发送方在返回RM cell中置CI位。<h4 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7 TCP拥塞控制"></a>3.7 TCP拥塞控制</h4></li></ul></li></ul></li><li>TCP的发送方限制外发流量的速率：<ul><li>拥塞窗口：<br>LastByteSent-LastByteAcked&lt;=CongWin<br>rate=congWin/RTT bytes/sec</li></ul></li><li>发送方感知拥塞的方式：发送超时、三个冗余ACK</li><li>TCP 拥塞算法Reno：<ul><li>加性增，乘性减<ul><li>Additive Increase：每个RTT将CongWin增大一个MSS（防止拥塞窗口缓慢增大，过早出现拥塞）</li><li>Multiplicative Decrease：发生丢包事件后，当前COngWin大小减半（大大减少注入到网络中的分组数）</li></ul></li><li>慢启动SS：<ul><li>TCP建立连接时，CongWin=1</li><li>连接开始时，指数性增长。每个RTT时，CongWin翻倍（收到了ACK之后）</li><li>门限值ssThread</li></ul></li><li>对超时事件的反应：<ul><li>门限值设置为当前CingWin的一半</li><li>将CongWin设置为1个MSS大小</li><li>窗口以指数增大</li><li>达到门限值之后，线性增长。</li></ul></li><li>对于重复收到3个ACK的反应——快速重传<ul><li>门限值设置为但概念CongWin的一半，将CongWin减少为现在的门限值+3MSS</li><li>线性增大拥塞窗口</li><li>早起的Tahoe版本在这种情况下也将CongWin降为1。</li></ul></li></ul></li><li>Reno的改进：New Reno</li><li>TCP的性能：<ul><li>丢包发生时，窗口大小为W，吞吐量为W/RTT</li><li>丢包事件发生之后，窗口大小减小为W/2，吞吐量为W/2RTT</li><li>平均吞吐量为0.75W/RTT</li></ul></li><li>吞吐量是丢包率L的函数：1.22MSS/(RTT*sqrt(L))</li><li>公平性分析：<ul><li>目标：如果K个TCP连接共享同一个带宽为R的瓶颈链路，每个连接的平均传输速率为R/K。</li><li>TCP是公平的吗：是的，P118</li></ul></li><li>TCP和UDP一起，无公平性。UDP恒定速率发送，而TCP会被拥塞机制限制速率</li><li>只使用TCP也不存在公平性。某些应用可以并发产生TCP连接。例如：链路速率为R，已经有9个连接，那么：<ul><li>新来的请求1个TCP，被分到R/10的速率，新来的请求11个TCP，被分到R/2的速率</li></ul></li><li>传输层主要内容：<ul><li>复用/解复用</li><li>可靠数据传输</li><li>流量控制</li><li>拥塞控制</li><li>UDP、TCP<h3 id="第4章-网络层：数据平面"><a href="#第4章-网络层：数据平面" class="headerlink" title="第4章    网络层：数据平面"></a>第4章    网络层：数据平面</h3><h4 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h4></li></ul></li><li>功能：实现主机到主机之间的通信<ul><li>发送主机向接收主机传送数据段（segment）。</li><li>发送主机：将数据段封装到数据报（datagram）中。 </li><li>接收主机：向传输层交付数据段</li><li>路由器检验所有穿越它的IP数据报的头部域</li></ul></li><li>核心功能：转发和路由、连接建立<ul><li>转发：从路由器的输入端口转移到合适的输出端口（转发表）</li><li>路由：确定分组从源到目的经过的路径（路由算法）</li><li>连接建立和传输层不同点：网络层是两个主机之间。路径上的路由器等网络设备都要参与其中。传输层是应用进程之间的连接，对中间网络设备透明</li></ul></li><li>网络层服务模型<ul><li>无连接服务：数据报网络<ul><li>不事先为系列分组的传输确定传输路径。</li><li>每个分组独立确定传输路径，不同分组可能传输路径不同</li></ul></li><li>连接服务：虚电路网络<ul><li>首先为系列分组的传输确定从源到目的经过的路径</li><li>沿着该路径（连接）传输系列分组，系列分组的传输路径相同</li><li>传输结束后，拆除连接</li></ul></li></ul></li><li>虚电路网络<ul><li>虚电路：源主机到目的主机类似于电路的逻辑连接<ul><li>分组交换（与电路交换的区别）、每个分组的传输利用链路的全部带宽</li><li>源主机到目的主机的路径经过的网络层设备共同完成虚电路的功能</li></ul></li><li>通信过程：呼叫建立-&gt;数据传输-&gt;拆除呼叫<ul><li>建立的过程中会分配VCID</li><li>每个分组携带虚电路标识VCID，而不是目的主机地址</li><li>虚电路经过的每个网络设备（如路由器），都需要维护虚电路的状态</li></ul></li><li>优点：继承了电路交换和分组交换的优点<ul><li>链路、网络设备资源可以面向VC进行预分配（预分配资源=可预期服务性能）</li><li>占用全部带宽</li></ul></li><li>VC的具体实现<ul><li>源主机到目的主机一条路径</li><li>每一段链路有一个虚电路号VCID，沿这段链路传输的分组携带对应虚电路的VCID而不是目的地址。（因为每一段链路上的设备的能力是各不相同的）</li><li>路由器转发分组时，依据转发表改写/替换虚电路号</li><li>每一个路由器需要维护VC连接的状态信息：虚电路建立对应接入口的增加，拆除对应着删除</li><li>虚电路信令协议：用于VC的建立、维护和拆除（internet网络不采用）</li><li>c启动呼叫、s呼叫到达、s接受呼叫、c呼叫连接、c数据流开始、s接收数据</li></ul></li></ul></li><li>数据报网络<ul><li>网络层无连接，每个分组携带目的地址</li><li>路由器根据目的地址转发分组：根据路由协议和算法构造转发表，检索转发表，每一个分组独立选路。</li><li>转发表：目的地址、输出链路<ul><li>目的地址（32为二进制）为地址范围，聚合转发表入口</li><li>地址范围为连续地址（前n比特有相同地址）</li><li>最长前缀匹配优先：遇到都可以匹配的时候，发送最长前缀对应的链路接口</li></ul></li></ul></li><li>数据报网络 VS VC网络<ul><li>Internet（数据报网络）：简化网络，复杂“边缘”（意思是很多事情都在端系统完成）<ul><li>没有严格的时间需求</li><li>链路众多，特点和性能各异，统一服务困难</li><li>”智能“端系统：可以自适应、实现性能控制和差错恢复</li></ul></li><li>ATM网络（VC网络）：简化“边缘”，复杂网络（意思是很多事情都在网络上完成）<ul><li>电话网络演化而来，核心业务是实时对话：严格的时间、可靠性需求</li><li>”哑“端系统（非智能）：电话机、传真机<h4 id="4-2-路由器工作原理"><a href="#4-2-路由器工作原理" class="headerlink" title="4.2 路由器工作原理"></a>4.2 路由器工作原理</h4></li></ul></li></ul></li><li>路由器的结构<ul><li>路由选择和分组转发两个部分组成</li><li>路由选择：路由选择处理机=路由选择协议+路由表</li><li>交换结构：分组处理——转发表<ul><li>线路端接：物理层位流级的接收</li><li>数据链路层处理（协议、拆封）：以太网等等</li><li>网络层处理（排队、查找、转发）</li></ul></li></ul></li><li>输入端口<br>分散式交换: 给出“目的地址”，使用“路由选择表”（存储于输入端口的内存中），查找“输出端口”<ul><li>目标：以“线路速度”完成输入端口的处理</li><li>排队：if 到达速度 &gt; 转发给结构的速度<ul><li>线头阻塞：FIFO机制造成的，因为输入端的FIFO首先处理队列靠前的数据，队列后面的数据的缓存口可能已经空闲，但是因为得不到处理而等待。</li></ul></li><li>交换结构<ul><li>经内存交换<ul><li>CPU控制完成</li><li>分组被拷贝到内存中，CPU控制下输出到输出端口</li><li>受限于内存的带宽（每个分组走两次总线）</li></ul></li></ul></li><li>经总线交换<ul><li>输入端口经一根共享总线，直接传送到输出端口</li><li>受限于总线的带宽</li><li>32Gbps总线，Cisco 5600对于运行在接入网或者企业网的路由器，通过总线交换的转发速度是足够的</li></ul></li><li>经内连网络<ul><li>优点为：克服总线带宽限制</li><li>先进设计：将长度变化的IP分组，分片乘固定尺寸的“信元”，通过交换结构对“信元“进行转发</li><li>Banyan网络：过去在多处理机计算机体系结构中，用来互联多个处理器网络</li><li>60Gbps，Cisco 12000</li></ul></li></ul></li><li>输出端口<ul><li>缓存管理：当“交换结构”将分组“交付给输出端口的速率”超过输出“链路的速率”时，输出端口缓存</li><li>调度原则：在“数据报队列”中，“选择数据报”进行传输</li><li>缓存区的设置<ul><li>RFC3439: B=RTT*R</li><li>理论研究，N条TCP连接经过的链路而言：B=RTT*R/sqrt(N)</li></ul></li><li>输出端口调度策略：先来先服务（FCFS）、加权公平排队（WFQ）</li><li>分组丢弃策略<ul><li>弃尾策略</li><li>删除一个或者多个已排队的分组</li><li>主动队列管理——随即早期检测RED<ul><li>每时每刻计算平均的队列长度avgth</li><li>最小阈值minth、醉倒阈值maxth</li><li>avgth小雨minth，允许分组入列</li><li>avgth大于maxth，分组被标记或者丢弃</li><li>在两者之间，按照概率标记或者丢弃分组<h4 id="4-3-网际协议：IPv4、寻址、IPv6及其他"><a href="#4-3-网际协议：IPv4、寻址、IPv6及其他" class="headerlink" title="4.3 网际协议：IPv4、寻址、IPv6及其他"></a>4.3 网际协议：IPv4、寻址、IPv6及其他</h4></li></ul></li></ul></li></ul></li><li>IP数据报结构：首部+数据<ul><li>首部：固定部分+可变部分<ul><li>固定部分：<ul><li>版本号：4 bit：4-&gt;ipv4；6-&gt;ipv6</li><li>首部长度：4 bit：最大数是15（每一个单位对应4个字节/一行）</li><li>典型IP分组第一个字节为45</li><li>服务类型TOS（区分服务）：8 bit：只有在网络提供区分服务才有效，一般不可用，一般00H</li><li>总长度：16 bit：首部+数据的总长度：最大65535B。and最小的IP分组首部为20B。故IP分组可以封装的最大数据为：65535-20=65515B</li><li>生存时间（TTL）：8 bit：IP分组在网络中可以通过的路由器数，每转发一次分组TTL减1，如果TTL=0，丢弃该IP分组</li><li>协议：8 bit：指示是哪个数据报：实现复用/分用。eg. 6为TCP，17为UDP。</li><li>首部校验和：16 bit：计算校验和时该字段全0。</li><li>源地址、目的地址：32 bit：分别标识发送分组的源主机/路由器（网络接口）、接受分组的目的主机/路由器（网络接口）的IP地址。</li></ul></li><li>可变部分<ul><li>选项字段：1-40B：携带安全、源选路径、时间戳和路由记录等内容。实际上很少被使用。</li><li>填充：0-3B之间，补齐整个首部，符合32为对齐，保证首部长度是4字节的倍数。</li></ul></li></ul></li></ul></li><li>IP分片<ul><li>MTU（最大传输单元）：链路层数据帧可封装数据的上限<ul><li>不同链路的MTU不一样</li></ul></li><li>分片与重组<ul><li>大IP分组向小MTU链路转发的时候，可以被“分片”。路由器只分不装，最后在目的主机组装</li><li>IP首部的相关字段用于“标识分片”以及确定分片的相关顺序（如果没有收全则全部丢弃）<ul><li>标识ID：16 bit：一个计数器，每产生一个IP分组计数器加一，作为该IP分组的标识</li><li>标志位：3 bit：<ul><li>DF：是否能对大IP分组进行分片（1不行，0可以）</li><li>MF：1代表不是独立的IP分组，是分片过后的，且不是最后一片；0代表最后一片（末分片）</li></ul></li><li>片偏移 13 bit：一个IP分组“分片”封装“源IP分组”的数据“相对偏移量”。<ul><li>如果没有被分片，这里一定是0</li><li>片偏移量以8字节为单位</li></ul></li></ul></li><li>分片过程：L为ip分组长度，M为待转发链路的MTU<ul><li>L&gt;M,DF=0可以分片</li><li>复制源IP分组的标识</li><li>除了最后一个分片，其他分片均分为MTU允许的最大分片</li><li>最大分片可封装的数据为：d=[(M-20)/8]_向下取整*8</li><li>需要总片数为：n=[(L-20)/d]_向上取整</li><li>每片的片偏移字段取值为：Fi=d/8*(i-1)</li><li>每一片总长度d+20，最后一片L-(n-1)*d</li><li>MF的取值：前n-1片取1，最后一片取0</li></ul></li></ul></li></ul></li><li>IP编址<ul><li>IP分组：源地址、目的地址</li><li>接口：主机/路由器与物理链路的连接：实现网络层功能、路由器通常有多个接口、主机通常只有1到2个接口</li><li>IPv4: 32bit：编号标识主机、路由器接口<ul><li>IP地址与每个接口关联</li><li>IP地址=网络号NetID+主机号HostID</li><li>IP子网：相同网络号设备接口+不跨越路由器就可以彼此互联</li><li>有类编址：<ul><li>50% A类：（0+7位）NetID+（24位）HostID（0.0.0.0-127.255.255.255）</li><li>25% B类：（10+14位）NetID+（16位）HostID (128.0.0.0-191.255.255.255)</li><li>12.5% C类：（110+21位）NetID+（8位）HostID (192.0.0.0-223.255.255.255)</li><li>6.25% D类：1110+28位（组播地址）(223.0.0.0-239.255.255.255)</li><li>6.25%：E类：1111+28位（研究保留）(240.0.0.0-255.255.255.255)</li></ul></li><li>特殊IP地址：见PPT</li><li>私有IP地址<ul><li>A：NETID：10</li><li>B：NETID：172.16-172.31</li><li>C：NETID：192.168.0-192.168.255</li></ul></li></ul></li></ul></li><li>IP子网：NetID+SubID（原网络主机号的部分比特）+HostID<ul><li>路由器将各个子网连接在一起</li><li>子网掩码：NetID和SubNetID全部取1，HostID全部取0<ul><li>子网掩码的运用：目的IP与子网掩码按位与运算，提取子网地址</li><li>可分配地址范围：去掉主机域全0（子网地址）和主机域全1的（广播地址）。</li></ul></li></ul></li><li>IP地址扩展——构造超网<ul><li>从网络号中借用一部分位数作为主机号</li></ul></li><li>CIDR：无类域间路由<ul><li>消除A、B、C类地址的界限，NetID+SubID=prefix可以任意长度</li><li>子网地址与子网掩码，方便子网划分</li><li>无类地址的格式：a.b.c.d/x (x为前缀长度，十进制)</li><li>优点<ul><li>提高IPv4地址空间分配效率</li><li>提高路由效率：很多子网聚合成一个较大的子网，构造超网</li><li>路由聚合（减少路由表的表项）：满足最长前缀匹配优先</li></ul></li></ul></li><li>DHCP协议：主机如何获取IP地址<ul><li>静态“硬编码”：IP、子网掩码、默认网关（路由器接口地址）</li><li>动态DHCP（port 67）<ul><li>从服务器动态获取：IP、子网掩码、默认网关、DNS服务器名称与IP地址</li><li>即插即用型的协议，允许地址重用、支持在用地址的续租、支持移动用户加入网络</li><li>新主机获取本网IP过程：<ul><li>主机，广播DHCP发现报文（DHCP discover）</li><li>DHCP服务器响应，DHCP offer（DHCP提供报文）</li><li>“DHCP request”（请求报文）</li><li>“DHCP ack”（确定报文）</li><li>报文在传输层采用UDP </li></ul></li></ul></li></ul></li><li>网络地址转换NAT：（私有地址在共有网络上的转换）<ul><li>NAT的动机：<ul><li>本地IP变更，无需告诉外界</li><li>变更ISP时，无需修改内部网络的IP地址</li><li>内部网络设备对外界网络不可见，不能直接寻址，保证安全性</li></ul></li><li>实现（NAT转换表）<ul><li>替换：(源IP地址，源端口号)-&gt;(NAT IP地址，新端口号)</li><li>记录：(源IP地址，源端口号)和(NAT IP地址，新端口号)记录下来</li><li>替换：(源IP地址，源端口号)替换每个进入内网的IP数据报的(目的IP地址，目的端口号)，即(NAT IP地址，新端口号)</li></ul></li><li>NAT的主要争议：违反了端到端的原则，节点不应该介入修改IP地址和端口号；路由器仅应当处理高达第三层的分组；应当采用IPv6来解决IP地址短缺问题</li></ul></li><li>NAT穿透问题（外部客户访问）<ul><li>采用端口NAT，在路由器中静态的为服务器配置”一条记录“<br>如(123.76.29.7,80) 总是指向(10.0.0.1,80)</li><li>通用即插即用UPnP<ul><li>IGD协议，了解公共IP地址</li><li>向路由器注册、移除映射记录（内部ip，内部port）-&gt; (公共ip，公共port)</li><li>内部程序向外部程序公开(公共ip，公共port)</li><li>适用于p2p</li></ul></li><li>中继（skype）（有一个中继服务器）<ul><li>10.0.0.1通过NAT与中继建立了连接</li><li>客户端与中继建立了连接</li><li>建立中继<h3 id="第5章-网络层：控制平面"><a href="#第5章-网络层：控制平面" class="headerlink" title="第5章    网络层：控制平面"></a>第5章    网络层：控制平面</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4></li></ul></li></ul></li></ul><h4 id="5-2-路由选择算法"><a href="#5-2-路由选择算法" class="headerlink" title="5.2 路由选择算法"></a>5.2 路由选择算法</h4><h4 id="5-3-因特网中自治系统内部的路由选择：OSPF"><a href="#5-3-因特网中自治系统内部的路由选择：OSPF" class="headerlink" title="5.3 因特网中自治系统内部的路由选择：OSPF"></a>5.3 因特网中自治系统内部的路由选择：OSPF</h4><h4 id="5-4-ISP之间的路由选择：BGP"><a href="#5-4-ISP之间的路由选择：BGP" class="headerlink" title="5.4 ISP之间的路由选择：BGP"></a>5.4 ISP之间的路由选择：BGP</h4><h4 id="5-6-ICMP：因特网控制报文协议"><a href="#5-6-ICMP：因特网控制报文协议" class="headerlink" title="5.6 ICMP：因特网控制报文协议"></a>5.6 ICMP：因特网控制报文协议</h4><h3 id="第6章-链路层和局域网"><a href="#第6章-链路层和局域网" class="headerlink" title="第6章    链路层和局域网"></a>第6章    链路层和局域网</h3><h4 id="6-1-链路层概述"><a href="#6-1-链路层概述" class="headerlink" title="6.1 链路层概述"></a>6.1 链路层概述</h4><h4 id="6-2-差错检测和纠正技术"><a href="#6-2-差错检测和纠正技术" class="headerlink" title="6.2 差错检测和纠正技术"></a>6.2 差错检测和纠正技术</h4><h4 id="6-3-多路访问链路协议"><a href="#6-3-多路访问链路协议" class="headerlink" title="6.3 多路访问链路协议"></a>6.3 多路访问链路协议</h4><h4 id="6-4-交换局域网"><a href="#6-4-交换局域网" class="headerlink" title="6.4 交换局域网"></a>6.4 交换局域网</h4><h4 id="6-7-回顾：Web页面请求的历程"><a href="#6-7-回顾：Web页面请求的历程" class="headerlink" title="6.7 回顾：Web页面请求的历程"></a>6.7 回顾：Web页面请求的历程</h4><h3 id="第7章-无线网络和移动网络"><a href="#第7章-无线网络和移动网络" class="headerlink" title="第7章    无线网络和移动网络"></a>第7章    无线网络和移动网络</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><ul><li>无线网络的元素<ul><li>无线主机（可移动、可固定）</li><li>无线链路：连接无线主机和基站（802.11ac; 802.11n; 802.11a,g; 802.11b; 802.15）(4G\3G\2G\2.5G\802.11ag ptop)</li><li>基站：连接无线网络</li></ul></li><li>Ad hoc 网络：无基站，内部分配</li><li>单跳、多跳<h4 id="7-2-无线链路和网络特征"><a href="#7-2-无线链路和网络特征" class="headerlink" title="7.2 无线链路和网络特征"></a>7.2 无线链路和网络特征</h4></li><li>信号强度递减、其他源的干扰、多路径传播：差错比有线链路明显</li><li>SNR越高，BER越低；给定SNR，高比特传输速率会带来较高的BER</li><li>隐藏终端、信号衰减</li><li>码分多址访问<h4 id="7-3-WiFi：802-11无线LAN"><a href="#7-3-WiFi：802-11无线LAN" class="headerlink" title="7.3 WiFi：802.11无线LAN"></a>7.3 WiFi：802.11无线LAN</h4></li><li>80211b: 2.4</li></ul><h4 id="考试中出现过的协议"><a href="#考试中出现过的协议" class="headerlink" title="考试中出现过的协议"></a>考试中出现过的协议</h4><ul><li>ICMP</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机网络-自顶向下-学习笔记-amp-计算机通信与网络课程复习&quot;&gt;&lt;a href=&quot;#计算机网络-自顶向下-学习笔记-amp-计算机通信与网络课程复习&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-自顶向下 学习笔记 &amp;amp; 计算机通信与
      
    
    </summary>
    
    
      <category term="CS Courses" scheme="www.waylonding.cn/blog/categories/CS-Courses/"/>
    
    
      <category term="Computer Network" scheme="www.waylonding.cn/blog/tags/Computer-Network/"/>
    
      <category term="System &amp; Network" scheme="www.waylonding.cn/blog/tags/System-Network/"/>
    
  </entry>
  
  <entry>
    <title>QT creator的使用与TCP传输试验</title>
    <link href="www.waylonding.cn/blog/2019/11/18/QT%20creator%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8ETCP%E4%BC%A0%E8%BE%93%E8%AF%95%E9%AA%8C/"/>
    <id>www.waylonding.cn/blog/2019/11/18/QT creator的使用与TCP传输试验/</id>
    <published>2019-11-18T12:52:39.000Z</published>
    <updated>2019-11-19T11:33:18.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用QT-creater实现图形化界面"><a href="#使用QT-creater实现图形化界面" class="headerlink" title="使用QT creater实现图形化界面"></a>使用QT creater实现图形化界面</h1><h1 id="1-QT-creater的安装"><a href="#1-QT-creater的安装" class="headerlink" title="1 QT creater的安装"></a>1 QT creater的安装</h1><ul><li>安装的时候注意一点即可，QT5.9之后的安装包不再分VS版本和WINGW版本，而是都整合到了一个安装包中，请根据需要下载</li><li>下载地址可以参考：<a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">QT的安装</a></li><li>安装过程可以参考以下博客：<a href="https://blog.csdn.net/qq_23473839/article/details/80523318" target="_blank" rel="noopener">https://blog.csdn.net/qq_23473839/article/details/80523318</a></li></ul><h1 id="2-用QT实现C-图形界面"><a href="#2-用QT实现C-图形界面" class="headerlink" title="2 用QT实现C++图形界面"></a>2 用QT实现C++图形界面</h1><h2 id="2-1-生成简单的窗口并输出文字"><a href="#2-1-生成简单的窗口并输出文字" class="headerlink" title="2.1 生成简单的窗口并输出文字"></a>2.1 生成简单的窗口并输出文字</h2><ul><li>关于在qt图形化界面上生成文字（英文），可参照以下博客：<a href="https://blog.csdn.net/larger5/article/details/78587076" target="_blank" rel="noopener">https://blog.csdn.net/larger5/article/details/78587076</a>  <ul><li>要注意一点，你的文件路径不能出现中文，不然会报错，就像这样：<code>Error while building/deploying project qt (kit: Desktop Qt 5.11.0 MinGW 32bit) When executing step &quot;qmake&quot;</code>   </li><li>关于解决中文路径的方法，推荐以下博客：<a href="https://blog.csdn.net/m0_37906001/article/details/76672634" target="_blank" rel="noopener">https://blog.csdn.net/m0_37906001/article/details/76672634</a>  </li><li>建议还是尽量全部使用用英文路径，以免以后遇到不必要的麻烦。<h2 id="2-2-UI探索"><a href="#2-2-UI探索" class="headerlink" title="2.2 UI探索"></a>2.2 UI探索</h2></li></ul></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用QT-creater实现图形化界面&quot;&gt;&lt;a href=&quot;#使用QT-creater实现图形化界面&quot; class=&quot;headerlink&quot; title=&quot;使用QT creater实现图形化界面&quot;&gt;&lt;/a&gt;使用QT creater实现图形化界面&lt;/h1&gt;&lt;h1 i
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="www.waylonding.cn/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="www.waylonding.cn/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Build My Personal Blog with Github and Hexo</title>
    <link href="www.waylonding.cn/blog/2019/11/18/hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%A9%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0/"/>
    <id>www.waylonding.cn/blog/2019/11/18/hexo博客安装与利用hexo写文章/</id>
    <published>2019-11-18T12:52:39.000Z</published>
    <updated>2019-11-19T11:32:38.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搭建hexo博客并用hexo写文章"><a href="#搭建hexo博客并用hexo写文章" class="headerlink" title="搭建hexo博客并用hexo写文章"></a>搭建hexo博客并用hexo写文章</h2><p>文中对所有的参考博客都给出了链接，感谢这些博客给予的帮助。</p><h3 id="1-利用github和hexo搭建博客"><a href="#1-利用github和hexo搭建博客" class="headerlink" title="1 利用github和hexo搭建博客"></a>1 利用github和hexo搭建博客</h3><h4 id="1-1-搭建步骤概述"><a href="#1-1-搭建步骤概述" class="headerlink" title="1.1 搭建步骤概述"></a>1.1 搭建步骤概述</h4><ol><li>本地安装（命令行安装）git、nodejs、hexo。创建本地blog文件夹，执行hexo init。</li><li>注册github账号（如果没有注册）、github创建新项目，用于保存你的hexo博客。（若还没在本地配置账号信息和ssh，也需要创建）</li><li>在本地文件夹，修改<code>_config.yml</code>的一些配置，首先要指向你的github仓库，然后生成博客。可以利用.io域名访问</li><li>如果要绑定个人域名，添加一条DNS记录即可。</li><li>然后可以配置主题，主题官网在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题配置</a></li><li>可以修改和安装一些设置</li></ol><h4 id="1-2-可供参考的安装和配置hexo的博文"><a href="#1-2-可供参考的安装和配置hexo的博文" class="headerlink" title="1.2 可供参考的安装和配置hexo的博文"></a>1.2 可供参考的安装和配置hexo的博文</h4><ol><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></li><li><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">https://www.cnblogs.com/visugar/p/6821777.html</a></li></ol><h3 id="2-把hexo博客搭载到域名子目录"><a href="#2-把hexo博客搭载到域名子目录" class="headerlink" title="2 把hexo博客搭载到域名子目录"></a>2 把hexo博客搭载到域名子目录</h3><ul><li>主要参考的是以下的博客：<a href="https://www.jianshu.com/p/18356b0a7494" target="_blank" rel="noopener">https://www.jianshu.com/p/18356b0a7494</a><br>直接看：<code>三、操作步骤</code> 修改即可（前提是你上一步的搭建过程该有的配置已经完成）</li></ul><h3 id="3-用hexo编写和发布文章"><a href="#3-用hexo编写和发布文章" class="headerlink" title="3 用hexo编写和发布文章"></a>3 用hexo编写和发布文章</h3><h4 id="3-1-markdown文件的书写"><a href="#3-1-markdown文件的书写" class="headerlink" title="3.1 markdown文件的书写"></a>3.1 markdown文件的书写</h4><p>hexo主要是用markdown进行书写，下面归纳整理了一些markdown书写过程中的一些常用功能的查找手册以及问题的解决方法：</p><ul><li>关于markdown的整体格式和页面书写书写可以参考以下教程：<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">markdown教程</a></li><li>markdown公式大全参考：<a href="https://www.jianshu.com/p/25f0139637b7" target="_blank" rel="noopener">https://www.jianshu.com/p/25f0139637b7</a>  </li><li>为md文件生成toc目录，这里我们以在VScode上编写markdown文本为例：<a href="https://www.jianshu.com/p/4721ddd27027" target="_blank" rel="noopener">https://www.jianshu.com/p/4721ddd27027</a><ul><li>VScode自动生成目录时有可能遇到换行不对的问题，参考以下网址解决即可：<a href="https://jingyan.baidu.com/article/6b97984df62b501ca3b0bf7a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6b97984df62b501ca3b0bf7a.html</a></li><li>本地md生成了toc目录之后，传到github上之后，该md文件也能正常显示目录，不用再下载任何插件。（由于网上有些人说github上面不支持toc目录，这里澄清一下，并不用额外安装插件，只用在本地安装toc支持并能正常显示目录，在github上面也能正常显示）</li><li>hexo支持toc自动生成目录，可以参考以下博文配置：<a href="https://www.jianshu.com/p/87a885fef1a6" target="_blank" rel="noopener">https://www.jianshu.com/p/87a885fef1a6</a>  </li></ul></li></ul><h4 id="3-2-关于用hexo发布博客"><a href="#3-2-关于用hexo发布博客" class="headerlink" title="3.2 关于用hexo发布博客"></a>3.2 关于用hexo发布博客</h4><ul><li>文章发布见如下步骤：<ul><li>在主目录下，输入<code>hexo new post &quot;文章名&quot;</code>或者<code>hexo new “文章名”</code>,都会在<code>source/_posts/</code>中多出一个.md文件（命令行也会提示你这里多出来一个.md文件），编写这个md文件即可。</li><li>打开这个md文件，你会看到要你填写title、date、tags。其中title和date已经自动生成好了(你也可以改)，你只需要填写tag（标签）即可。当然你可也以自己添加其他属性，比如comment（是否可以评论）、toc（是否显示文章目录）、categories（文章分类）。给出一个完整的文章接本设置的代码如下：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 你的文章的title</span><br><span class="line">date: yy-mm-dd hh:mm:ss</span><br><span class="line">comments: true #是否可评论</span><br><span class="line">toc: true #是否显示文章目录</span><br><span class="line">categories: gexo博客搭建 #分类</span><br><span class="line">tags:   #标签</span><br><span class="line">    - tag1</span><br><span class="line">    - tag2</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li>编写好文件之后，用<code>hexo clean</code>；<code>hexo g</code>；<code>hexo d</code> 这三条命令，将你所编写的文件放到你的博客上</li></ul></li></ul><h3 id="4-hexo的个性化布局"><a href="#4-hexo的个性化布局" class="headerlink" title="4 hexo的个性化布局"></a>4 hexo的个性化布局</h3><h4 id="4-1-hexo的页面设置"><a href="#4-1-hexo的页面设置" class="headerlink" title="4.1 hexo的页面设置"></a>4.1 hexo的页面设置</h4><ul><li>hexo有几个官方的页面，但是需要自己生成：标签、分类、归档和关于，下面简单介绍一下：<ul><li>标签页面，创建方式<code>hexo new page tags</code>，然后再在主题配置文件<code>_config.yml</code>中添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">    tags: /tags</span><br></pre></td></tr></table></figure>在文章中添加tags的方法就是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 你的文章的title</span><br><span class="line">tags:   #标签</span><br><span class="line">    - tag1</span><br><span class="line">    - tag2</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li>添加分类页面；创建方式<code>hexo new page categories</code>，然后在主题配置文件中添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">    categories: /categories</span><br></pre></td></tr></table></figure>在文章中添加分类的方法为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 你的文章的title</span><br><span class="line">categories:   #分类</span><br><span class="line">    - hexo</span><br><span class="line">    - skills</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li>同理，根据以上的步骤，还可以添加主页面home、归档archives、关于about。主题配置文件<code>_config.yml</code>中添加如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">    home: /      //主页</span><br><span class="line">    categories: /categories //分类        </span><br><span class="line">    archives: /archives   //归档   </span><br><span class="line">    tags: /tags   //标签                  </span><br><span class="line">    about: /about   //关于</span><br></pre></td></tr></table></figure></li></ul></li><li>我们也可以自己定义一个页面，比如<code>myself</code>页面，创建方式还是<code>hexo new page myself</code>,在主题配置文件<code>_config.yml</code>中添加如下（这里显示我们所有的页面配置）：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">    home: /      //主页</span><br><span class="line">    categories: /categories //分类        </span><br><span class="line">    archives: /archives   //归档   </span><br><span class="line">    tags: /tags   //标签                  </span><br><span class="line">    about: /about   //关于</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;搭建hexo博客并用hexo写文章&quot;&gt;&lt;a href=&quot;#搭建hexo博客并用hexo写文章&quot; class=&quot;headerlink&quot; title=&quot;搭建hexo博客并用hexo写文章&quot;&gt;&lt;/a&gt;搭建hexo博客并用hexo写文章&lt;/h2&gt;&lt;p&gt;文中对所有的参考博客
      
    
    </summary>
    
    
      <category term="hexo搭建属于自己的博客" scheme="www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo技术" scheme="www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/hexo%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo相关技术" scheme="www.waylonding.cn/blog/tags/hexo%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
      <category term="markdown的使用" scheme="www.waylonding.cn/blog/tags/markdown%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
