{"meta":{"title":"REDIVIOUS‘s Blog","subtitle":"世界那么大，我想去看看","description":"Waylon Ding's blog.","author":"Waylon Ding","url":"www.waylonding.cn/blog"},"pages":[{"title":"about","date":"2019-11-19T06:48:40.000Z","updated":"2019-11-19T06:48:40.233Z","comments":true,"path":"about/index.html","permalink":"www.waylonding.cn/blog/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Computing Theory Notes","slug":"Computing-Theory","date":"2019-11-20T06:49:38.000Z","updated":"2019-11-30T05:15:57.908Z","comments":true,"path":"2019/11/20/Computing-Theory/","link":"","permalink":"www.waylonding.cn/blog/2019/11/20/Computing-Theory/","excerpt":"","text":"Notes of Computing Theory 2019Reference: Introduction to the Theory of Computation (3rd edition) An Introduction to Formal Languages and Automata (5th thedition) Computational Complexity: a Modern Approach Part1 Formal Language and Automata1.1 Basis1.1.1 Introduction1.1.2 Languages1.1.3 DFA1.1.4 NFA1.2 Regular_Expression1.2.1 Regular_Expressions1.2.2 Regular_Properties1.2.3 Regular_Grammars1.2.4 Regular_Pumping1.2.5 Regular_Pumping_Examples1.3 Context_Free1.3.1 Context-Free Languages 主要形式：S-&gt;ab|SS|e 推导表：对于一个语法，和确定的答案，可以每次替换最左的变量、或者每次替换最右的变量 推导树（解析树）：对于每一个推导都能给出一个derivation tree。 歧义性：leftmost和rightmost推导出来的结果不一样（有两个不同的derivation tree或者有两个不同的左文法）例如E-&gt;E+E|EE|(E)|a对于a+aa，有两个不同路径的派生 要将歧义的转换为非歧义的，或许能够成功，但也有失败的。 有的语言是固有的歧义的。（PPT在此时隐含告诉了你如何用language构造grammar） 注意PPT上举出的例子：{a^n b^n c^n}不是一个context-free的语言1.3.2 Properties of Context-Free languages context-free的关键点是：language-L、grammars-G、variables-S union操作：s-&gt;s1|s2 concatention操作：s-&gt;s1s2 star operation操作：s1-&gt;ss1|r intersection、complement不一定是context-free intersection L1={a^n b^n c^m} context free S-&gt;AC; A-&gt;aAb|r; C-&gt;cC|r。 L2={a^n b^m c^m} S-&gt;AB; A-&gt;aA|r; B-&gt;bBc|r。 其交集为{a^n b^n c^n} 不是context free complementation ^(^(L1)+^(L2))=L1交集L2={a^n b^n c^n}。不是conetxt free L1 context free; L2 regular; -&gt; L1交集L2 = context free（正则闭包） 正则闭包：L1是上下文无关文法，L2是正则文法，则L1交集L2是上下文无关文法。 构造下推自动机：L1交集L2 例子：证明L={a^n b^n n!=100}是context free（见PPT）构造除了n=100之外的，取交集。 例子：证明L={w:na=nb=nc}不是context-free。假设是，并和{abc*}相交，得到{a^n b^n c^n}，不是context-free。1.3.3 Simplifications of Context-Free Grammars 替换原则：形如A-&gt;xBz，B-&gt;y1；可以替换为：A-&gt;xBz|xy1z nullable variables: M-&gt;e unit productions: A-&gt;B. (X-&gt;X can be removed) useless prodections: never terminate (A-&gt;aA); not reachable from S (详见PPT) context-free的正规表达 (chomsky normal form) 都有形式：A-&gt;BC或者A-&gt;a (variable只能有两个，terminal只能有一个)) 转换成chomsky form 对每个terminal转换：Ta-&gt;A 用V合并两个varible Greinbach normal form A -&gt; aV1V2V3…（只有一个terminal，后面全是varible）1.3.5 parsing lexical analyzer：识别关键词和变量 parser：知道程序的编程语言、对于输入的程序建立推导树、将推导树转换成机器码。 exhaustive parser：K^2w S-grammar/cyk: A-&gt;av (v=&gt;string of variables) :O(w^2 * w) = O(w^3) (number of substrings * number of pre-suffix decompositions for a string) (和算法课上讲的context-free的表求解过程一致) 1.3.6 Context_Free_Pumping 我们有最多t个right-bond-size，r个变量 =&gt; 证明了至少有r+2层；根据鸽巢定理，一定会有重复使用的变量。 PPT P45展示了context-free的pumping lemma。关键点：w=uvxyz；有u v^i x y^i z也属于这个文法。（vxy&lt;=p;vy&gt;=1） 证明要点：分情况vxy位置，对于{a^n b^n c^n}来说有5种情况。vy&gt;=1，有k1+k2&gt;=1。1.3.7 Context_Free_Pumping_Examples L={vv:v belongs to {a,b}} not context-free (10种) L={a^(n!):n&gt;=0} not context-free L={a^(n^2) b^n: n&gt;=0} not context-free1.4 PDA1.4.1 PDA a, b-&gt;c (input, pop, push) NPDA: 有不确定状态的下推自动机：如e状态如果一个string被接受了，代表所有的输入被消耗了，最后一个状态是接受状态。 push &amp; pop strings：a, w1-&gt;w2 (inout,pop strings push strings) (注意，在构造PDA的时候，需要知道pop和push中间需要加上一个介稳态) instantaneous descripition：(q,u,s):(现有状态，剩余输入、现有在栈中的输入) 我们有：前一个时间的instantaneous descripition &gt; 后一个时间的instantaneous descripition。1.4.2 PDA_Accept_Context_Free 一个context-free language 和一个能被PDA接受的语言是等价的。证明过程：1.证明conetxt-free语言的语法被PDA的语法包含。（能将context-free文法转换为PDA；2.证明context-free语言（文法）包含PDA（能将任意的PDA转换为context-free文法） context-free转换为PDA q0-&gt;q1-&gt;q2 (q1:loop) grammar：A-&gt;w: e,A-&gt;w terminal：a,a-&gt;e PDA -&gt; context-free 转换到：PDA只有一个接受状态，利用e，e-&gt;e 使用initial stack symbol#增加e,e-&gt;@; e,e-&gt;Z；对于PDA来说，还是z为初始状态 使用唯一的接受stack symbol#增加e,e-&gt;e; 然后空栈操作（添加e,x-&gt;e）x为除了@和#之外的所有的元素; 最后加操作e,@-&gt;e。 每次转换状态要么将一个symbol入栈，要么将一个symbol出栈，但不能两者同时。举个例子：就是不能有k,a-&gt;b；需要转换为k,a-&gt;e; e,e-&gt;b;特殊情况：如果有k,e-&gt;e；需要转换为k,e-&gt;u；e,u-&gt;e; 转换到这里完成，需要注意的是，新的栈开始符号#没有在任何的传递中使用。 语法的构建：变量：Aqi，qj （qi、qj为PDA的状态） Initial state：q0；Accept state：qf start varible：Aq0qf kind1:from single state：Aq0q0-&gt;e（对于Aqiqi都成立） kind2:from triplets of states$A_{q0q5} -&gt; A_{q0q0}A_{q0q5}|A_{q0q1}A_{q1q5}|A_{q0q2}A_{q2q5}|A_{q0q3}A_{q3q5}|A_{q0q4}A_{q4q5}|A_{q0q5}A_{q5q5}$ from pairs of transitions缩减状态，详见PPT。 证明Apq，有一个从状态p到状态q的串w，使得这个串变成空串：(p,w,e)&gt;(q,e,e),有以下几种情况 Apq-&gt;AprArq-&gt;…-&gt;w Apq-&gt;aArsb-&gt;…-&gt;w 用数学归纳法证明，详见ppt（这一点我期末考试再复习一遍，这里先立个flag） 1.4.3 DPDA 确定性的下推自动机。不允许不确定性的情况存在。例如同时存在a,b-&gt;w1和a,b-&gt;w2。也不允许r,b-&gt;w1和a,b-&gt;w2同时存在。 如果有一个DPDA构造的语言L，证明这个语言是确定性上下文法无关语言。 DPFA属于PFA的一部分（真包含关系）。PPT中展示了一个context-free language它不能被任何DPDA接受：L(M)={a^n b^n}+{a^n b^2n} ：构造一条路径，构造一个PDA有形式L+{a^n b^n c^n}。而这个形式本来不属于context-free语言，推出矛盾。 part2 Turing machine2.1 turing machines 最大范围的语言，包括{a^n b^n c^n}、ww a-&gt;b,L (read a, write b, move left) 图灵机是确定性的，不允许e传递。P16 停止条件：无法根据语法去跟随步骤。接受状态也不允许有走出状态 一般表达：g(q1,a)=(q2,b,R)串的表达eg: q2xayb&gt;xq0ayb（即状态左边的、状态、状态所指、状态右边的） initial configuration：q0w 且有：L(M)={w: q0w &gt; x1qfx2} (q0: initial, qf: accept) 2.2 turing variations2.2.1 Turing thesis 解决问题的算法是构造一个图灵机解决问题 算法描述图灵机的步骤 图灵机 -&gt; 计算步骤2.2.2 variations of the turing machine 标准模型：PPT第六面 （本章证明以下变种都和标准图灵机相等） Stay Option: L,R,S: left, right, stay PPT：P13 Prove：PPT P15 （能互相simulate） stay option 和 standrad 的转换 P18 multiple track tape: (b,a)-&gt;(c,d),L PPT: P21 semi-infinite: 在输入串的左端加入#。 PPT: P23 将infinite分成left part和right part (b,f)-&gt;(g,d),L,R 左边往左边流，右边往右边流 porve: 标准-&gt;半带 P25 prove: 半带-&gt;标准 P27 multi-tape machine：(b,f)-&gt;(g,d),L,R P34 prove: 多带-&gt;标准 P38 多维图灵机：L,R,U,D P42 二维模型：P46 不确定性图灵机 多个choice 确定性模拟非确定性P55（BFS）2.2.3 universal turing machine","categories":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}],"tags":[{"name":"Formal language and Automata","slug":"Formal-language-and-Automata","permalink":"www.waylonding.cn/blog/tags/Formal-language-and-Automata/"}],"keywords":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}]},{"title":"OpeartingSystem Notes","slug":"OpeartingSystem-Notes","date":"2019-11-19T08:29:13.000Z","updated":"2019-11-26T14:27:59.717Z","comments":true,"path":"2019/11/19/OpeartingSystem-Notes/","link":"","permalink":"www.waylonding.cn/blog/2019/11/19/OpeartingSystem-Notes/","excerpt":"","text":"计算机操作系统学习&amp;复习笔记参考书目：计算机操作系统（人民邮电出版社） 第一章 绪论1.1 操作系统在计算机中的地位 * 操作系统是什么； 是核心软件 负责软件硬件资源分配与调用 控制、协调并发活动 提供用户接口、为用户良好工作环境 操作系统特点位置：从里到往外裸机-&gt;操作系统-&gt;应用软件 内容庞杂、涉及面广 控制管理硬件、软件；控制程序进行 为用户提供良好接口 实践性强 技术发展快Unix和linux采取优先调度。linux调度方法：140队列，140位位图，扫描位图（不怎么需要时间），高优先级入列 OS和各层次的关系 硬件：控制CPU、访问存储、驱动设备、中断 软件：控制管理、提供界面和服务 各层次对OS的影响 硬件约束：用串行（CPU）实现并行（操作系统） 上层用户需求：实时和分时，界面友好 1.5 操作系统采用的技术 * 并行处理技术 并行处理：多个部件、为整体任务同时执行。 多用户、多任务同时执行。为描述任务，引入进程的概念。进程的状态及控制（任务状态）、进程同步与互斥（多任务协调）、进程调度（CPU控制权的分配等等） 系统资源共享处理机共享（处理机分配调度）、存储器共享（存储分配、保护、虚拟存储与地址映射）、设备共享（设备分配驱动以及中断）、信息共享（文件结构、共享以及存取方法） 虚拟技术 用户：逻辑视图。操作系统：物理视图。 物理（硬件）资源（系统）：CPU、主存、打印机、磁盘等。 逻辑（软件）资源（用户）：CPU1、CPU2（CPU分时）；虚拟主存1、虚拟主存2（主存的主存管理）；打印机1、打印机2（虚拟打印技术）（网络上有很多资源需要打印机） 第二章 操作系统的结构和硬件支持2.3 处理机的态 * 系统中两类程序：管理程序和用户程序： 管理程序：管理系统资源、控制程序运行 用户程序: 使用资源、提出申请；被控制 区分处理机状态的目的是为了保护操作系统。不保护就有可能瘫痪。 处理机的态：中央处理机的工作状态（取决于当前处理机运行的程序） 管态：管理程序执行的态。称特权级。使用全部指令和资源。 有的细分为核心态和管态 用户态：用户程序执行的态。只允许访问自己的存储区域，禁止特权指令，不能直接取用资源与改变机器的态。 管态和用户态区别： 管态 操作系统程序执行 使用全部指令 使用全部系统资源（包括整个存储空间） 用户态 用户程序执行 禁用特权指令 只允许用户程序访问自己的存储区域 特权指令集 涉及到外部设备的输入/输出命令 修改特殊寄存器的指令 改变机器状态的指令 实现处理机分态的硬件支持 在状态寄存器中设置状态位： 一位：用户态、管态 两位：核态、管态、用户态 核态和管态都是操作系统程序执行时处理机的状态。核态：操作系统核心程序执行时的状态，权限比管态高，可以执行所有机器指令（改变机器状态）。 Unix（linux）系统中状态的分类 00-核态；01-管态；11-用户态 80x86微处理器中状态位：（CPU特权级）DPL=0（核态）；DPL=3（用户态） 程序性中断 程序有越权操作时候发生的中断称为程序性中断。 中断机制负责使其陷入操作系统，用户态转换为管态，操作系统管理程序获得控制权开始执行。 什么时候中断用户态下超出了权限时保护操作系统： 当用户执行了一条特权指令 当用户程序试图访问操作系统数据区或其他程序占用的区域时。2.4 中断及其处理 * 中断：某个事件（掉电、定点加法溢出，I/O结束）发生时，停止现行程序执行，转而处理该事件的程序对事件进行处理，处理完毕返回执行原来程序。 中断类型： I/O中断 外中断：时钟、操作员控制台中断、通信中断 机器故障中断：电源、主存取指错等。 程序性中断：定点溢出、用户态下使用核态指令、非法操作 访管中断：对操作系统提出某种需求的时所发出的中断。 中断方式： 强迫性中断：除了访管中断 自愿中断：访管中断 中断来源 中断：由处理机外部事件引起的中断：时钟、磁盘、终端 俘获：由处理机内部事件引起的中断：非法指令、地址越界、浮点溢出、trap指令 中断响应及硬件支持： 保护现场、恢复现场 现场： 后继指令所在主存的单元号、程序运行所处的状态、指令执行情况、程序执行的中间结果 保护现场：现场存入主存。 恢复现场：把保护的现场重新送到各个特殊寄存器 中断响应：中央处理器发出请求-&gt;中止现有程序执行-&gt;引出中断处理程序的过程 系统堆栈：存入指令计数器(PC)、处理机状态寄存器(PS) 的内容 (一般先PS后PC？)（硬件层面） 中断向量表：存入中断程序地址（地址内存从0开始） 中断响应实质：交换指令地址及处理机的状态信息 软件的中断处理过程 中断进入 step1 保护中断程序的现场（没有保存的寄存器） step2 进入相应的中断服务例程。 step3 恢复中断程序的现场。 第三章 操作系统的用户接口3.2 操作系统的用户接口及分类 用户接口/用户界面：用户控制计算机的手段 操作接口/命令界面：键盘命令（分时操作系统）（MS-DOS、unix/linux）、图形界面（windows）、作业控制语言（批处理系统）组织工作流程，控制程序运行（C语言编写编译链接等） 程序接口：系统功能调用程序运行时，使用系统功能调用来请求操作系统的服务。3.3 系统功能调用及其实现技术 硬件支持：由用户态到管态 访管指令/自愿进管指令：svc n（功能号） 访管中断：正在运行的程序对于操作系统的某种需求。 系统功能调用：借助访管指令，取值n（特定功能），硬件进入，软件方法完成。 系统调用实现用户程序（svc i）、访管中断处理程序（按照i转移）、例行子程序入口地址表、例行自程序3.5 linux系统调用功能的实现 linux系统功能调用的进入 异常处理（系统调用通过异常类型实现）、软中断（int 0x80）、状态转换（从用户态到核心态，执行自陷处理程序（防管中断处理程序）） getuid系统调用过程 用户程序(getuid())-&gt;标准C库(内含int0x80)-&gt;系统调用处理程序-&gt;内核例程（系统服务例程） linux系统调用的进入和返回 软中断（自陷指令/访管指令）int 0x80 发生中断（自陷/访管中断） 处理机用户态-&gt;内核态（内核状态的改变） system_call()开始执行系统调用处理程序（系统功能调用的执行） 处理完毕后，iret返回到用户态 Linux系统功能调用的实现机制 硬件支持： 增加一个软中断指令、自陷 软件：系统调用号、系统调用表、系统服务例程、系统调用处理程序 增加一个新的系统调用 增加一个新的系统服务例程 增加一个新的系统调用号 在系统调用表中增加一项（新例程的地址） 将新的系统服务例程加入到系统中（系统重构） 系统调用号 linux中每个系统调用被赋予一个唯一的系统调用号格式：#define _NR_fork 2 系统调用表：记录了内核中所有已经注册过的系统调用、系统调用的函数指针（函数指针数组）（保存所有系统调用的函数指针） 系统调用的处理过程 宏SAVE_ALL保护现场 正确性检查 eax中包含系统调用号，调用对应的服务例程 服务流程结束时，RESTORE_ALL恢复寄存器 iret返回 第四章 进程及进程管理4.1 并发进程及其特点 程序的顺序执行：一个程序的一次执行过程称为一个计算，一个计算的若干操作必须按照严格的先后顺序来执行。 顺序性：按照严格顺序执行 封闭性：一旦开始执行，不受外界因素影响 可再现性：执行的结果与他的执行速度无关（时间无关），与初始条件有关。 并发程序 定义：若干个程序同时在系统中运行，程序在时间上时重叠的（一个没做完，另外一个已经开始） 并行语句记号cobegin S1，S2，S3…coend 并发程序的特点 失去了封闭性和可再现性一个程序的执行可以改变另一个程序的变量，后者的输出依赖于各程序执行的相对速度，失去了程序的封闭性的特点。 解决进程的同步问题（与时间有关的错误） 程序与计算不再一一对应：一个程序对应多个计算 程序并发执行的相互制约：间接的相互制约：资源共享、直接的相互制约：公共变量 4.2.1 进程定义 运行（获得cpu）-&gt;暂停（保留状态）-&gt;运行（获得cpu） 定义：在给定的活动空间和初始环境下，在一个处理机上的执行过程。 与程序的区别 程序静态（C语言代码不变）、进程动态（一次执行过程） 进程是一个独立运行的活动单位 竞争系统资源的基本单位（cpu，I/O） 一个程序可以对应多个进程，一个进程至少包含一个程序。4.2.2 进程状态及其变迁 进程的基本状态 运行状态（占用cpu）：已经获得运行所必须的资源，程序正在处理机上执行 （单cpu运行状态只能有一个） 等待状态（输入输出）：程序等待某一事件等待发生（等待外部传输完成等等）而暂时停止执行（这时即使给它cpu的控制权也无法执行） 就绪状态：进程已经获得除了CPU之外的运行所必须的资源，一旦获得了CPU控制权，就可以立即运行。 进程状态的变迁：（基本状态变迁只有前三个） 运行-&gt;等待：服务请求（I/O） 等待-&gt;就绪：（I/O是完成）服务完成，事件来到 就绪-&gt;运行：进程调度（CPU空出） 等待-&gt;运行：不可能 运行-&gt;就绪：时间片到了（分时系统中） 就绪-&gt;等待：有需求的系统提供（一般没有） linux系统状态变迁 新进程-&gt;就绪：创建 就绪-&gt;运行：进程调度 运行-&gt;就绪：被抢占 等待-&gt;就绪：等待的事情发生 运行-&gt;等待：等待某事件 运行-&gt;终止：进程完成 进程状态变迁的驱动及条件见作业习题4.2.3 进程控制块及进程队列 进程控制块：描述：1、进程与其他进程；2、系统资源的关系；以及3、进程在各个不同时期所处状态；的数据结构。称为进程控制块PCB。 程序与数据：描述进程“本身”所应该完成的功能 PCB：进程的动态特征，该进程与“其他进程”和“系统资源”的关系。 进程控制块（内容）： 进程标识符：进程符号或者内部id号 进程当前状态：本进程目前处于何种状态。 当前队列指针：登记了处于同一状态的“下一个进程的PCB地址”。 进程优先级：进程提要求CPU的紧迫程度。 通信信息：进程间通信记录的有关信息。 家族联系：本进程和家族的联系（子进程、父进程等等） 进程控制块的组织————进程队列结构 就绪状态队列：ready_q_start —— 一个或者（最多140个） 等待打印机队列：wait_lpt_q_start —— 多个（等待打印机、磁盘、键盘等） 运行指针：running ——一个 进程控制块的作用： 修改PCB表项 系统通过修改PCB表项的内容，‘动态记录’该进程‘当前的状态’和‘占有资源’的情况，以便实施有效的管理。 在进程队列中移动PCB结构 进程控制和进程调度的功能实现，是在相应的进程队列中移动相关的PCB结构。 4.3 进程控制 进程状态的变化 无 -（创建）- 有 -（撤销）- 消亡 运行 -（等待）- 等待 就绪 -（唤醒）- 等待 创建原语、撤销原语、等待原语、唤醒原语 （原语：原子操作（系统功能调用）） 进程创建 进程创建原语——create（fork） 进程创建原语的功能：创建一个具有指定标识符的过程，建立进程的PCB结构 进程创建原语的实现：PCB池 进程创建原语——create（fork） 申请一个空的PCB结构 无空位报错，有则将入口信息填入PCB的对应项。 将PCB入就绪队列。 返回进程pid（PCB池中的位置）。 进程撤销——kill/exit（退出自己）（一个，一组，自己） 运行指针获得当前进程的pid 释放本进程所占用的资源给父进程 释放PCB结构 转进程调度 进程等待原语——susp 保护CPU现场到PCB结构中 置该进程为“等待”状态 将其PCB结构插入到相应等待队列 转进程调度 进程唤醒原语——wakeup 找到该等待队列 将该结构移出等待队列 将该进程置为就绪状态，PCB插入就绪队列 返回刚刚被打断的进程 进程控制功能及其在进程队列上的操作4.4.2 进程互斥的概念 临界资源：系统中有多个进程，共享各种资源，然而有些资源一次只能为一个进程所用。 系统资源打印机，A、B共享一台打印机。若任意使用，两进程的输出结果交织在一起。解决方法：A使用之前先提出申请，然后独占，B只有在A释放之后系统才能分给B。 进程共享公共变量。 临界区： 互斥：操作系统中。某一进程正在访问某一存储区域时，就不允许其他进程“读出来”或者“修改”该存储区的内容。4.4.3 进程同步的概念 并发进程在一些关键点上可能需要相互等待与互通消息，这种相互制约的等待与互通消息称为进程同步 共享缓冲区的计算进程与打印进程的同步 计算进程cp和打印进程iop公用一个单缓冲 计算的速度快，输出的速度慢。丢失信息 计算的速度慢，输出的速度快。重复打印4.5 同步机构4.5.1 锁、上锁、开锁 每一个共享的临界资源：一个锁单位：0可用，1不可用。 上锁操作： 检测锁位的值（0or1） 若0变为1（占用） 若1（占用），返回第一步 开锁操作：使用完之后，锁位变为0。 上锁原语：保护cpu、当前进程变为等待，插入w的等待队列，转进程调度、w=1 开锁原语：移除等待队列的首元素，插入到就绪队列、该进程就绪、w=0上锁原语-&gt;临界区-&gt;开锁原语4.5.2 信号等的PV操作 2元组：(s.q)。 s&gt;0,表示有可用资源，进程执行，绿灯。 s&lt;=0，表示没有可用资源，停止执行，红灯。 P操作：P(s)；s减1（大于等于0返回，小于0（进程被阻）入信号灯等待队列，置为“等待状态”，转进程调度） V操作：V(s)：S加一。大于0返回，小于等于0唤醒（从信号灯的等待队列中取出首元素、入就绪队列、置“就绪状态”、返回）4.6 进程互斥与同步的实现4.6.1 用上锁原语和开锁原语实现进程互斥上锁原语-&gt;进入临界区cs-&gt;开锁原语 （main函数中设置w=1）4.6.2 用信号灯的P、V操作实现互斥 mutex:互斥信号灯 p(mutex)-&gt;临界区cs-&gt;v(mutex) 若有两个并发进程 mutex=1:没有程序进入临界区 mutex=0:有一个程序进入临界区 mutex=-1:一个程序进入临界区，另一个程序等待进入 若有n个并发进程，则可能有1,0,-1,…,-(n-1)取值 信号灯s为正值：挂起进程前还可以使用的P操作数，等于s还可以使用的物理资源数。 s为负值：在信号灯s队列中等待的进程个数。 P操作：请求一个资源/挂起进程，V操作：释放一个资源/唤醒进程。化验单-&gt;化验进程-》开始工作化验进程-》化验结果-》看病进程-》医疗方案。4.6.3 进程同步的实现 合作进程的执行次序 共享缓冲区的合作进程的同步的解法 考虑4.4.3节中提到的问题 sa表示缓冲区中是否有可供打印的计算结果，初值为0。 sb表示缓冲区有无空位置存放新的信息，其初值为1。 4.6.4 生产者和消费者 计算进程和打印进程 多个计算进程cp不断产生数据，生产者 多个打印进程iop不断打印数据，消费者 有多个缓冲区 通信问题 发消息进程send不断产生消息，生产者 受消息recieve不断接收消息，消费者 生产者和消费者的同步关系 生产者：有界缓冲区无空位，等待；放入物品，发消息 消费者：无物品，等待；取物品，发消息 信号灯的设置 两个同步信号灯 sb：缓冲区的数目，初值=n sa：信息数目，初值=0 一个互斥信号灯 mutex：有界缓冲区是否被占用，初值=1。 4.7 进程通信(IPC) 概念：进程之间直接以较高的效率传递较多数据的信息交互方式。也是两个不同的进程共享数据的方式。 实现：消息缓冲器、发送操作、接收操作 发送进程和接受进程的同步：发送等待、接受等待。4.7.2 进程通信的方式 消息缓冲通信 信息头：发送进程的标识符、接受进程的标识符、传送信息的字节数。 消息缓冲、发送原语、接受原语：每一次想要发送消息，形成一个消息缓冲区，消息原语将消息发出；接受进程在本进程主存空间形成一个接受区，接受原语接受消息。 信箱通信 定义信箱结构 消息发送模块、功能接受模块：提供发送原语和接受原语 所使用的信箱可以用于用户空间中（接受进程地址空间的一部分）、也可以用于操作系统空间中。 下面两个？？ sys V进程通信方式 信号量 共享内存 消息队列 posix进程间通信方式 共享内存 信号量&lt;!– #### 4.8 操作系统的进程即期间的通讯实例 int pid=fork(); //创建进程 为子进程分配了一个新的PCB 为子进程赋了一个唯一的进程标识号PID 子进程复制父进程的下列属性：用户id、组id、工作目录根目录、信号屏蔽设置和动作、环境变量、内存、所有已经打开的文件句柄 对父进程返回子进程的进程号，最子进程返回0 等待进程/线程终止：wait(); waitpid(); int status; pid=wait(&amp;status);–&gt;4.8 线程的概念及特点 概念：比进程更小的活动单位，进程中的一个执行路径。 描述：进程中的一条执行路径、有自己私用的运行栈和处理机执行环境、与其他线程“共享”分配给进程的“内存和文件”、单个进程是创建的多个同时存在的线程中的一个。线程是一个动态概念。 线程调用实例4.10 进程调度 调度/分派结构：多个就绪状态的进程对处理机的竞争是由进程调度程序来协调的。 调度：就绪状态的进程排序。将一个进程插入到就绪队列，按照一定策略排序。 分派：调度时机，就绪队列第一个进程移出，建立其在处理机上执行环境，在处理机执行。 调度的功能 记录进程的状态变化 决定调度策略：1.优先调度、2.FIFO 实施处理机的分配和回收 调度时机 运行-》等待（阻塞） 运行-》就绪（时间片到） 等待-》就绪（唤醒） 任务完成，终止 异常出错 可剥夺调度，出现更高优先级的就绪进程。 调度方式：“重要而紧迫”的进程怎么处理 剥夺方式：暂停current，处理机给“重要而紧迫” 非剥夺方式：继续current，直到该进程完成或发生某事件到“完成”、“阻塞”，才给“重要而紧迫” 调度算法 进程优先数调度算法 优先数的分类和确定 静态优先数：根据所需资源来计算、基于程序运行时间估计、基于进程类型。 动态优先数：CPU超过一定时间降低、I/O增加，等待时间超过一定时间增加。 循环轮转调度算法 时间片的计算：q=t/n （t为用户能接受的响应时间，n为进入系统的进程数目） 时间片的选取：太小，系统切换很频繁（切换时间不可忽略），从系统角度来看，时间片取大比较好。太大，轮转一次的总时间增大，对进程的响应速度放慢了。 可变时间片轮转调度：根据系统当前的进程树来确定时间片的大小。 多级时间片循环调度 多个就绪队列 先进入高优先级队列，高优先级队列的时间片较小。 用完后，进入下一级队列，优先级降低，但时间片增大一倍。 这个算法，较小时间片处理完较短进程，避免较长进程被频繁中断。 时间片与优先级混合调度算法 I/O后进入因I/O而等待队列，完成后进入高优先就绪。 运行时间片到了，进入低优先就绪队列。 CPU空闲时，若高优先就绪队列非空，则从高优先就绪队列中选择一个进程运行，分配时间片100ms。 CPU空闲时，若高优先就绪队列为空，则从低优先就绪队列中选择一个程序运行，分配时间片为500ms。 照顾I/O量大的进程，适当照顾计算量大的进程，提高系统资源利用率。","categories":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}],"tags":[{"name":"System & Network","slug":"System-Network","permalink":"www.waylonding.cn/blog/tags/System-Network/"},{"name":"Operating System","slug":"Operating-System","permalink":"www.waylonding.cn/blog/tags/Operating-System/"}],"keywords":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}]},{"title":"ComputerNetwork Notes","slug":"ComputerNetwork-Review-Notes","date":"2019-11-19T08:13:01.000Z","updated":"2019-12-02T03:31:30.652Z","comments":true,"path":"2019/11/19/ComputerNetwork-Review-Notes/","link":"","permalink":"www.waylonding.cn/blog/2019/11/19/ComputerNetwork-Review-Notes/","excerpt":"","text":"计算机网络-自顶向下 学习笔记 &amp; 计算机通信与网络课程复习参考书目：计算机网络-自顶向下方法（原书第7版） 第1章 计算机网络和因特网1.1 什么是因特网1.2 网络边缘1.4 分组交换网中的时延、丢包和吞吐量1.5 协议层次及服务模型第2章 应用层2.1 应用层协议原理2.2 Web和HTTP2.3 因特网中的电子邮件2.4 DNS：因特网的目录服务2.5 P2P文件分发第3章 运输层3.1 概述和运输层服务 运输层：不同进程、逻辑通信（只考虑点到点，不考虑点和点之间的具体构造） 网络层：不同主机，逻辑通信 家庭通信的例子：进程=（要发信息的）孩子们，应用消息（报文）=信封，主机=房子，传输层协议=要送信给邮局的人，网络层协议=邮政服务 UDP数据报、TCP报文段 TCP差错检测、拥塞控制、可靠数据传输（连接建立）3.2 多路复用与多路分解 接收端进行多路分用：传输层依据头部信息，将收到的segement交给正确的socket 发送端进行多路复用：从多个socket接收数据，为每块数据封装上头部信息，生成segmennt，交给网络层。 数据报携带一个传输层的段（报文段）：每个段携带源端口号和目的端口号。 无连接的多路分用 UDP的Socket二元组表示：（目的IP，目的port） 携带源端口号，以便信息反馈 创建port：DatagramSocket mySocket1=new DatagramSocket(12345); 面向连接的分用 TCP Socket的四元组表示（源IP，源port，目的IP，目的port） 多线程的Web服务器：进程创建多线程，多TCP连接3.3 无连接运输：UDP 基于internet的IP协议：多路复用和分用、简单的错误校验 best effort服务，可能：丢失、非按顺序到达 优点：减少连接时延、实现和维护简单、首部开销小、无拥塞控制（更好地控制发送时间和速率） 流媒体、DNS、SNMP 应用层实现可靠传输 报文结构：源port（16）、目的port（16）、length（16）、checksum（16） checksum：段的内容视为16bit整数：取和，进位加在后面，按位求反。接收方计算校验和和校验字段进行比对：不等有错，相等不一定没错。3.4 可靠数据传输原理 可靠的定义：不错、不丢、不乱。 可靠数据传输协议：rdt。TOP-10问题！ 可靠数据传输协议的基本结构：接口 rdt_send():上层应用调用，将数据交给rdt以发送给对方 udt_send():被rdt调用，在不可靠信道上向接收方传输数据 rdt_rcv():分组到达接收方信道时被调用 diliver_data():被rdt调用，向上层应用交付数据 注意：分组在不可靠信道上传输是双向的，而上层接收和交付数据是单向的 packet=make_pkt(data):把数据打包变成分组 extract(packet,data):把分组提取变成数据 Rdt1.0:可靠信道上的可靠数据传输 不会发生错误、不会丢弃分组 FSM见PPT27面 Rdt2.0:产生位错误的信道（0反转位1，1反转为0） ARQ协议 一种重传机制的rdt协议 校验和检测错误 ACK/NAK: 显式地，正确接收/分组有错误 NAk: 重传分组 引入的新机制有：差错检测、接收方反馈控制消息ACK/NAK、重传 FSM 发送方：停-等协议 等状态：等待来自上层的调用 停状态：等待ACK或NAK 分组增加校验和：snd_pkt(data,checksum) 判断收到了NAK，重传分组：rdt_rcv(rcvpkt)&amp;&amp;isNAK(rcvpkt)-&gt;udt_send(sndpkt) 判断收到了ACK，回到等状态，action为空：rdt_rcv(rcvpkt)&amp;&amp;isACK(rcvpkt) 接收方 判断分组被损毁，返回NAK：rdt_rcv(rcvpkt)&amp;&amp;corrupt(rcvpkt)-&gt;udt_send(NAK) 判断分组正常，提取数据交付上层，返回ACK：rdt_rcv(rcvpkt)&amp;&amp;notcorrupt(rcvpkt)-&gt;extract(rcvpkt,data),diliver_data(data),udt_send(ACK) Rdt2.1&amp;&amp;Rdt2.2: 解决NAK、ACK错误的情况 Rdt2.1 如果错误，就重传。重传会产生重复分组，解决重复分组，添加序列号实现，接收方丢弃重复分组。两个序列号（0，1）即可 FSM： Rdt2.2: 无NAK的消息协议 发送方收到重复ACK之后，重传 FSM Rdt3.0: 处理分组丢失问题 发送方等待合理时间：如果没有ACK，重传 增加定时器 FSM见PPT 几种典型场景见PPT 没有丢失 丢失packet 丢失ACK 过早超时 Rdt3.0的性能分析：见PPT U_sender=(L/R)/(RTT+L/R) 性能很差 提高Rdt性能：流水线传输以及滑动窗口协议 等待过程中可以发送其他分组，N段流水性能提高N倍 窗口：允许使用的序列号范围，尺寸为N即最多有N个等待确认的消息 GBN * SR 3.5 面向连接的运输：TCP TCP将IP层的不可靠变为可靠 技术：流水线机制、累计确认、单一重传定时器 出发重传的事件：超时、收到重复的ACK 如何估计RTT SampleRTT：从段发出去到收到ACK的事件 SampleRTT的变化值：测量多个RTT求平均值（指数加权移动平均）EstimatedRTT=(1-alpha)EstimatedRTT+alphaSampleRTT (alpha=0.125) 测量RTT的变化值：SampleRTT和EstimatedRTT的差值DevRTT=(1-beta)DevRTT+beta|SampleRTT-EstimatedRTT| (beta=0.25) TimeoutInterval=EstimatedRTT+4*DevRTT 发送方 创建segment，序列号：segment第一个字节的编号。 开启计时器，设置超时时间TimeOutInterval 超时：重传引起超时的Segment，重起定时器 shoudaoACK：更新SendBase，若窗口中还有没有被确认的分组，重起定时器 快速重传机制 重复ACK检测分组丢失：如果sender收到对于同一个数据的3个ACK，即假定该数据之后的段已经丢失，在计时器超时之前即进行重传 超时间隔加倍：每一次TCP重传均将下一次超时间隔设置为先前值的两倍 流量控制 发送方数据过快过多，淹没接收方（buffer溢出） 窗口值的计算 接收方：LastByteRcvd – LastByteRead ≤ RcvBufferRcvWindows = RcvBuffer – [LastByteRcvd - LastByteRead] 发送方：LastByteSent – LastByteAcked ≤ RcvWindow 特殊情况：RcvWindow=0，无任何数据给发送方，发送方会向接收方发送只有一个字节数据的报文段，目的是试探 连接管理 初始化TCP变量 序列号、Buffer和流量控制信息 三次握手 客户发送SYN报文段：告知服务器序列号 服务器收到SYN报文段，回复SYNACK报文段：建立缓存区、回复序列号 客户端收到SYNACK，回复ACK报文段，可能包含数据 关闭请求：一般是客户机关闭 客户机向服务器发送TCP FIN报文段 服务器收到FIN，回复ACK，关闭连接，发送FIN 收到FIN，回复ACK；重复收到FIN，重发ACK 服务器收到ACK，真正关闭连接 TCP连接管理的状态序列：见PPT813.6 拥塞控制原理 3.7 TCP拥塞控制第4章 网络层：数据平面4.1 网络层概述4.2 路由器工作原理4.3 网际协议：IPv4、寻址、IPv6及其他第5章 网络层：控制平面5.1 概述5.2 路由选择算法5.3 因特网中自治系统内部的路由选择：OSPF5.4 ISP之间的路由选择：BGP5.6 ICMP：因特网控制报文协议第6章 链路层和局域网6.1 链路层概述6.2 差错检测和纠正技术6.3 多路访问链路协议6.4 交换局域网6.7 回顾：Web页面请求的历程第7章 无线网络和移动网络7.1 概述 无线网络的元素 无线主机（可移动、可固定） 无线链路：连接无线主机和基站（802.11ac; 802.11n; 802.11a,g; 802.11b; 802.15）(4G\\3G\\2G\\2.5G\\802.11ag ptop) 基站：连接无线网络 Ad hoc 网络：无基站，内部分配 单跳、多跳7.2 无线链路和网络特征 信号强度递减、其他源的干扰、多路径传播：差错比有线链路明显 SNR越高，BER越低；给定SNR，高比特传输速率会带来较高的BER 隐藏终端、信号衰减 码分多址访问7.3 WiFi：802.11无线LAN 80211b: 2.4","categories":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}],"tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"www.waylonding.cn/blog/tags/Computer-Network/"},{"name":"System & Network","slug":"System-Network","permalink":"www.waylonding.cn/blog/tags/System-Network/"}],"keywords":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}]},{"title":"QT creator的使用与TCP传输试验","slug":"QT creator的使用与TCP传输试验","date":"2019-11-18T12:52:39.000Z","updated":"2019-11-19T11:33:18.532Z","comments":true,"path":"2019/11/18/QT creator的使用与TCP传输试验/","link":"","permalink":"www.waylonding.cn/blog/2019/11/18/QT%20creator%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8ETCP%E4%BC%A0%E8%BE%93%E8%AF%95%E9%AA%8C/","excerpt":"","text":"使用QT creater实现图形化界面1 QT creater的安装 安装的时候注意一点即可，QT5.9之后的安装包不再分VS版本和WINGW版本，而是都整合到了一个安装包中，请根据需要下载 下载地址可以参考：QT的安装 安装过程可以参考以下博客：https://blog.csdn.net/qq_23473839/article/details/80523318 2 用QT实现C++图形界面2.1 生成简单的窗口并输出文字 关于在qt图形化界面上生成文字（英文），可参照以下博客：https://blog.csdn.net/larger5/article/details/78587076 要注意一点，你的文件路径不能出现中文，不然会报错，就像这样：Error while building/deploying project qt (kit: Desktop Qt 5.11.0 MinGW 32bit) When executing step &quot;qmake&quot; 关于解决中文路径的方法，推荐以下博客：https://blog.csdn.net/m0_37906001/article/details/76672634 建议还是尽量全部使用用英文路径，以免以后遇到不必要的麻烦。2.2 UI探索","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"www.waylonding.cn/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"www.waylonding.cn/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"www.waylonding.cn/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Build My Personal Blog with Github and Hexo","slug":"hexo博客安装与利用hexo写文章","date":"2019-11-18T12:52:39.000Z","updated":"2019-11-19T11:32:38.761Z","comments":true,"path":"2019/11/18/hexo博客安装与利用hexo写文章/","link":"","permalink":"www.waylonding.cn/blog/2019/11/18/hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%A9%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0/","excerpt":"","text":"搭建hexo博客并用hexo写文章文中对所有的参考博客都给出了链接，感谢这些博客给予的帮助。 1 利用github和hexo搭建博客1.1 搭建步骤概述 本地安装（命令行安装）git、nodejs、hexo。创建本地blog文件夹，执行hexo init。 注册github账号（如果没有注册）、github创建新项目，用于保存你的hexo博客。（若还没在本地配置账号信息和ssh，也需要创建） 在本地文件夹，修改_config.yml的一些配置，首先要指向你的github仓库，然后生成博客。可以利用.io域名访问 如果要绑定个人域名，添加一条DNS记录即可。 然后可以配置主题，主题官网在hexo主题配置 可以修改和安装一些设置 1.2 可供参考的安装和配置hexo的博文 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://www.cnblogs.com/visugar/p/6821777.html 2 把hexo博客搭载到域名子目录 主要参考的是以下的博客：https://www.jianshu.com/p/18356b0a7494直接看：三、操作步骤 修改即可（前提是你上一步的搭建过程该有的配置已经完成） 3 用hexo编写和发布文章3.1 markdown文件的书写hexo主要是用markdown进行书写，下面归纳整理了一些markdown书写过程中的一些常用功能的查找手册以及问题的解决方法： 关于markdown的整体格式和页面书写书写可以参考以下教程：markdown教程 markdown公式大全参考：https://www.jianshu.com/p/25f0139637b7 为md文件生成toc目录，这里我们以在VScode上编写markdown文本为例：https://www.jianshu.com/p/4721ddd27027 VScode自动生成目录时有可能遇到换行不对的问题，参考以下网址解决即可：https://jingyan.baidu.com/article/6b97984df62b501ca3b0bf7a.html 本地md生成了toc目录之后，传到github上之后，该md文件也能正常显示目录，不用再下载任何插件。（由于网上有些人说github上面不支持toc目录，这里澄清一下，并不用额外安装插件，只用在本地安装toc支持并能正常显示目录，在github上面也能正常显示） hexo支持toc自动生成目录，可以参考以下博文配置：https://www.jianshu.com/p/87a885fef1a6 3.2 关于用hexo发布博客 文章发布见如下步骤： 在主目录下，输入hexo new post &quot;文章名&quot;或者hexo new “文章名”,都会在source/_posts/中多出一个.md文件（命令行也会提示你这里多出来一个.md文件），编写这个md文件即可。 打开这个md文件，你会看到要你填写title、date、tags。其中title和date已经自动生成好了(你也可以改)，你只需要填写tag（标签）即可。当然你可也以自己添加其他属性，比如comment（是否可以评论）、toc（是否显示文章目录）、categories（文章分类）。给出一个完整的文章接本设置的代码如下： 12345678910---title: 你的文章的titledate: yy-mm-dd hh:mm:sscomments: true #是否可评论toc: true #是否显示文章目录categories: gexo博客搭建 #分类tags: #标签 - tag1 - tag2--- 编写好文件之后，用hexo clean；hexo g；hexo d 这三条命令，将你所编写的文件放到你的博客上 4 hexo的个性化布局4.1 hexo的页面设置 hexo有几个官方的页面，但是需要自己生成：标签、分类、归档和关于，下面简单介绍一下： 标签页面，创建方式hexo new page tags，然后再在主题配置文件_config.yml中添加：12menu: tags: /tags 在文章中添加tags的方法就是：123456---title: 你的文章的titletags: #标签 - tag1 - tag2--- 添加分类页面；创建方式hexo new page categories，然后在主题配置文件中添加：12menu: categories: /categories 在文章中添加分类的方法为：123456---title: 你的文章的titlecategories: #分类 - hexo - skills--- 同理，根据以上的步骤，还可以添加主页面home、归档archives、关于about。主题配置文件_config.yml中添加如下：123456menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于 我们也可以自己定义一个页面，比如myself页面，创建方式还是hexo new page myself,在主题配置文件_config.yml中添加如下（这里显示我们所有的页面配置）： 123456menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于","categories":[{"name":"hexo搭建属于自己的博客","slug":"hexo搭建属于自己的博客","permalink":"www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"name":"hexo技术","slug":"hexo搭建属于自己的博客/hexo技术","permalink":"www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/hexo%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo相关技术","slug":"hexo相关技术","permalink":"www.waylonding.cn/blog/tags/hexo%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"markdown的使用","slug":"markdown的使用","permalink":"www.waylonding.cn/blog/tags/markdown%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"keywords":[{"name":"hexo搭建属于自己的博客","slug":"hexo搭建属于自己的博客","permalink":"www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"name":"hexo技术","slug":"hexo搭建属于自己的博客/hexo技术","permalink":"www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/hexo%E6%8A%80%E6%9C%AF/"}]}]}