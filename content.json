{"meta":{"title":"REDIVIOUS‘s Blog","subtitle":"世界那么大，我想去看看","description":"Waylon Ding's blog.","author":"Waylon Ding","url":"www.waylonding.cn/blog"},"pages":[{"title":"about","date":"2019-11-19T06:48:40.000Z","updated":"2019-11-19T06:48:40.233Z","comments":true,"path":"about/index.html","permalink":"www.waylonding.cn/blog/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Computing Theory Notes","slug":"Computing-Theory","date":"2019-11-20T06:49:38.000Z","updated":"2019-12-04T07:03:20.367Z","comments":true,"path":"2019/11/20/Computing-Theory/","link":"","permalink":"www.waylonding.cn/blog/2019/11/20/Computing-Theory/","excerpt":"","text":"Notes of Computing Theory 2019Reference: CSC-4890: Introduction to Theory of Computation the website: https://csc.lsu.edu/~busch/courses/theorycomp/ Introduction to the Theory of Computation (3rd edition) An Introduction to Formal Languages and Automata (5th thedition) Computational Complexity: a Modern Approach Part1 Formal Language and Automata1.1 Basis1.1.1 Introduction1.1.2 Languages1.1.3 DFA1.1.4 NFA1.2 Regular_Expression1.2.1 Regular_Expressions1.2.2 Regular_Properties1.2.3 Regular_Grammars1.2.4 Regular_Pumping1.2.5 Regular_Pumping_Examples1.3 Context_Free1.3.1 Context-Free Languages 主要形式：S-&gt;ab|SS|e 推导表：对于一个语法，和确定的答案，可以每次替换最左的变量、或者每次替换最右的变量 推导树（解析树）：对于每一个推导都能给出一个derivation tree。 歧义性：leftmost和rightmost推导出来的结果不一样（有两个不同的derivation tree或者有两个不同的左文法）例如E-&gt;E+E|EE|(E)|a对于a+aa，有两个不同路径的派生 要将歧义的转换为非歧义的，或许能够成功，但也有失败的。 有的语言是固有的歧义的。（PPT在此时隐含告诉了你如何用language构造grammar） 注意PPT上举出的例子：{a^n b^n c^n}不是一个context-free的语言1.3.2 Properties of Context-Free languages context-free的关键点是：language-L、grammars-G、variables-S union操作：s-&gt;s1|s2 concatention操作：s-&gt;s1s2 star operation操作：s1-&gt;ss1|r intersection、complement不一定是context-free intersection L1={a^n b^n c^m} context free S-&gt;AC; A-&gt;aAb|r; C-&gt;cC|r。 L2={a^n b^m c^m} S-&gt;AB; A-&gt;aA|r; B-&gt;bBc|r。 其交集为{a^n b^n c^n} 不是context free complementation ^(^(L1)+^(L2))=L1交集L2={a^n b^n c^n}。不是conetxt free L1 context free; L2 regular; -&gt; L1交集L2 = context free（正则闭包） 正则闭包：L1是上下文无关文法，L2是正则文法，则L1交集L2是上下文无关文法。 构造下推自动机：L1交集L2 例子：证明L={a^n b^n n!=100}是context free（见PPT）构造除了n=100之外的，取交集。 例子：证明L={w:na=nb=nc}不是context-free。假设是，并和{abc*}相交，得到{a^n b^n c^n}，不是context-free。1.3.3 Simplifications of Context-Free Grammars 替换原则：形如A-&gt;xBz，B-&gt;y1；可以替换为：A-&gt;xBz|xy1z nullable variables: M-&gt;e unit productions: A-&gt;B. (X-&gt;X can be removed) useless prodections: never terminate (A-&gt;aA); not reachable from S (详见PPT) context-free的正规表达 (chomsky normal form) 都有形式：A-&gt;BC或者A-&gt;a (variable只能有两个，terminal只能有一个)) 转换成chomsky form 对每个terminal转换：Ta-&gt;A 用V合并两个varible Greinbach normal form A -&gt; aV1V2V3…（只有一个terminal，后面全是varible）1.3.5 parsing lexical analyzer：识别关键词和变量 parser：知道程序的编程语言、对于输入的程序建立推导树、将推导树转换成机器码。 exhaustive parser：K^2w S-grammar/cyk: A-&gt;av (v=&gt;string of variables) :O(w^2 * w) = O(w^3) (number of substrings * number of pre-suffix decompositions for a string) (和算法课上讲的context-free的表求解过程一致) 1.3.6 Context_Free_Pumping 我们有最多t个right-bond-size，r个变量 =&gt; 证明了至少有r+2层；根据鸽巢定理，一定会有重复使用的变量。 PPT P45展示了context-free的pumping lemma。关键点：w=uvxyz；有u v^i x y^i z也属于这个文法。（vxy&lt;=p;vy&gt;=1） 证明要点：分情况vxy位置，对于{a^n b^n c^n}来说有5种情况。vy&gt;=1，有k1+k2&gt;=1。1.3.7 Context_Free_Pumping_Examples L={vv:v belongs to {a,b}} not context-free (10种) L={a^(n!):n&gt;=0} not context-free L={a^(n^2) b^n: n&gt;=0} not context-free1.4 PDA1.4.1 PDA a, b-&gt;c (input, pop, push) NPDA: 有不确定状态的下推自动机：如e状态如果一个string被接受了，代表所有的输入被消耗了，最后一个状态是接受状态。 push &amp; pop strings：a, w1-&gt;w2 (inout,pop strings push strings) (注意，在构造PDA的时候，需要知道pop和push中间需要加上一个介稳态) instantaneous descripition：(q,u,s):(现有状态，剩余输入、现有在栈中的输入) 我们有：前一个时间的instantaneous descripition &gt; 后一个时间的instantaneous descripition。1.4.2 PDA_Accept_Context_Free 一个context-free language 和一个能被PDA接受的语言是等价的。证明过程：1.证明conetxt-free语言的语法被PDA的语法包含。（能将context-free文法转换为PDA；2.证明context-free语言（文法）包含PDA（能将任意的PDA转换为context-free文法） context-free转换为PDA q0-&gt;q1-&gt;q2 (q1:loop) grammar：A-&gt;w: e,A-&gt;w terminal：a,a-&gt;e PDA -&gt; context-free 转换到：PDA只有一个接受状态，利用e，e-&gt;e 使用initial stack symbol#增加e,e-&gt;@; e,e-&gt;Z；对于PDA来说，还是z为初始状态 使用唯一的接受stack symbol#增加e,e-&gt;e; 然后空栈操作（添加e,x-&gt;e）x为除了@和#之外的所有的元素; 最后加操作e,@-&gt;e。 每次转换状态要么将一个symbol入栈，要么将一个symbol出栈，但不能两者同时。举个例子：就是不能有k,a-&gt;b；需要转换为k,a-&gt;e; e,e-&gt;b;特殊情况：如果有k,e-&gt;e；需要转换为k,e-&gt;u；e,u-&gt;e; 转换到这里完成，需要注意的是，新的栈开始符号#没有在任何的传递中使用。 语法的构建：变量：Aqi，qj （qi、qj为PDA的状态） Initial state：q0；Accept state：qf start varible：Aq0qf kind1:from single state：Aq0q0-&gt;e（对于Aqiqi都成立） kind2:from triplets of states$A_{q0q5} -&gt; A_{q0q0}A_{q0q5}|A_{q0q1}A_{q1q5}|A_{q0q2}A_{q2q5}|A_{q0q3}A_{q3q5}|A_{q0q4}A_{q4q5}|A_{q0q5}A_{q5q5}$ from pairs of transitions缩减状态，详见PPT。 证明Apq，有一个从状态p到状态q的串w，使得这个串变成空串：(p,w,e)&gt;(q,e,e),有以下几种情况 Apq-&gt;AprArq-&gt;…-&gt;w Apq-&gt;aArsb-&gt;…-&gt;w 用数学归纳法证明，详见ppt（这一点我期末考试再复习一遍，这里先立个flag） 1.4.3 DPDA 确定性的下推自动机。不允许不确定性的情况存在。例如同时存在a,b-&gt;w1和a,b-&gt;w2。也不允许r,b-&gt;w1和a,b-&gt;w2同时存在。 如果有一个DPDA构造的语言L，证明这个语言是确定性上下文法无关语言。 DPFA属于PFA的一部分（真包含关系）。PPT中展示了一个context-free language它不能被任何DPDA接受：L(M)={a^n b^n}+{a^n b^2n} ：构造一条路径，构造一个PDA有形式L+{a^n b^n c^n}。而这个形式本来不属于context-free语言，推出矛盾。 part2 Turing machine2.1 turing machines 最大范围的语言，包括{a^n b^n c^n}、ww a-&gt;b,L (read a, write b, move left) 图灵机是确定性的，不允许e传递。P16 停止条件：无法根据语法去跟随步骤。接受状态也不允许有走出状态 一般表达：g(q1,a)=(q2,b,R)串的表达eg: q2xayb&gt;xq0ayb（即状态左边的、状态、状态所指、状态右边的） initial configuration：q0w 且有：L(M)={w: q0w &gt; x1qfx2} (q0: initial, qf: accept) 2.2 turing variations2.2.1 Turing thesis 解决问题的算法是构造一个图灵机解决问题 算法描述图灵机的步骤 图灵机 -&gt; 计算步骤2.2.2 variations of the turing machine 标准模型：PPT第六面 （本章证明以下变种都和标准图灵机相等） Stay Option: L,R,S: left, right, stay PPT：P13 Prove：PPT P15 （能互相simulate） stay option 和 standrad 的转换 P18 multiple track tape: (b,a)-&gt;(c,d),L PPT: P21 semi-infinite: 在输入串的左端加入#。 PPT: P23 将infinite分成left part和right part (b,f)-&gt;(g,d),L,R 左边往左边流，右边往右边流 porve: 标准-&gt;半带 P25 prove: 半带-&gt;标准 P27 multi-tape machine：(b,f)-&gt;(g,d),L,R P34 prove: 多带-&gt;标准 P38 多维图灵机：L,R,U,D P42 二维模型：P46 不确定性图灵机 多个choice 确定性模拟非确定性P55（BFS）2.2.3 universal turing machine","categories":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}],"tags":[{"name":"Formal language and Automata","slug":"Formal-language-and-Automata","permalink":"www.waylonding.cn/blog/tags/Formal-language-and-Automata/"}],"keywords":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}]},{"title":"OpeartingSystem Notes","slug":"OpeartingSystem-Notes","date":"2019-11-19T08:29:13.000Z","updated":"2019-12-02T09:01:29.735Z","comments":true,"path":"2019/11/19/OpeartingSystem-Notes/","link":"","permalink":"www.waylonding.cn/blog/2019/11/19/OpeartingSystem-Notes/","excerpt":"","text":"计算机操作系统学习&amp;复习笔记参考书目：计算机操作系统（人民邮电出版社） 第一章 绪论1.1 操作系统在计算机中的地位 * 操作系统是什么； 是核心软件 负责软件硬件资源分配与调用 控制、协调并发活动 提供用户接口、为用户良好工作环境 操作系统特点位置：从里到往外裸机-&gt;操作系统-&gt;应用软件 内容庞杂、涉及面广 控制管理硬件、软件；控制程序进行 为用户提供良好接口 实践性强 技术发展快Unix和linux采取优先调度。linux调度方法：140队列，140位位图，扫描位图（不怎么需要时间），高优先级入列 OS和各层次的关系 硬件：控制CPU、访问存储、驱动设备、中断 软件：控制管理、提供界面和服务 各层次对OS的影响 硬件约束：用串行（CPU）实现并行（操作系统） 上层用户需求：实时和分时，界面友好1.2 操作系统的形成和发展（多道程序、分时技术）1.3 操作系统的基本概念（定义、特性、资源管理的功能、应该解决的基本功能）1.4 操作系统的基本类型 批量操作系统 分时操作系统 实时操作系统 个人计算机操作系统 网络操作系统 分布式系统1.5 操作系统采用的技术 * 并行处理技术 并行处理：多个部件、为整体任务同时执行。 多用户、多任务同时执行。为描述任务，引入进程的概念。进程的状态及控制（任务状态）、进程同步与互斥（多任务协调）、进程调度（CPU控制权的分配等等） 系统资源共享处理机共享（处理机分配调度）、存储器共享（存储分配、保护、虚拟存储与地址映射）、设备共享（设备分配驱动以及中断）、信息共享（文件结构、共享以及存取方法） 虚拟技术 用户：逻辑视图。操作系统：物理视图。 物理（硬件）资源（系统）：CPU、主存、打印机、磁盘等。 逻辑（软件）资源（用户）：CPU1、CPU2（CPU分时）；虚拟主存1、虚拟主存2（主存的主存管理）；打印机1、打印机2（虚拟打印技术）（网络上有很多资源需要打印机） 第二章 操作系统的结构和硬件支持2.1 操作系统虚拟机2.2 操作系统组织结构 操作系统的结构 运行时的组织结构 操作系统与计算机层次的接口2.3 处理机的态 * 系统中两类程序：管理程序和用户程序： 管理程序：管理系统资源、控制程序运行 用户程序: 使用资源、提出申请；被控制 区分处理机状态的目的是为了保护操作系统。不保护就有可能瘫痪。 处理机的态：中央处理机的工作状态（取决于当前处理机运行的程序） 管态：管理程序执行的态。称特权级。使用全部指令和资源。 有的细分为核心态和管态 用户态：用户程序执行的态。只允许访问自己的存储区域，禁止特权指令，不能直接取用资源与改变机器的态。 管态和用户态区别： 管态 操作系统程序执行 使用全部指令 使用全部系统资源（包括整个存储空间） 用户态 用户程序执行 禁用特权指令 只允许用户程序访问自己的存储区域 特权指令集 涉及到外部设备的输入/输出命令 修改特殊寄存器的指令 改变机器状态的指令 实现处理机分态的硬件支持 在状态寄存器中设置状态位： 一位：用户态、管态 两位：核态、管态、用户态 核态和管态都是操作系统程序执行时处理机的状态。核态：操作系统核心程序执行时的状态，权限比管态高，可以执行所有机器指令（改变机器状态）。 Unix（linux）系统中状态的分类 00-核态；01-管态；11-用户态 80x86微处理器中状态位：（CPU特权级）DPL=0（核态）；DPL=3（用户态） 程序性中断 程序有越权操作时候发生的中断称为程序性中断。 中断机制负责使其陷入操作系统，用户态转换为管态，操作系统管理程序获得控制权开始执行。 什么时候中断用户态下超出了权限时保护操作系统： 当用户执行了一条特权指令 当用户程序试图访问操作系统数据区或其他程序占用的区域时。2.4 中断及其处理 * 中断：某个事件（掉电、定点加法溢出，I/O结束）发生时，停止现行程序执行，转而处理该事件的程序对事件进行处理，处理完毕返回执行原来程序。 中断类型： I/O中断 外中断：时钟、操作员控制台中断、通信中断 机器故障中断：电源、主存取指错等。 程序性中断：定点溢出、用户态下使用核态指令、非法操作 访管中断：对操作系统提出某种需求的时所发出的中断。 中断方式： 强迫性中断：除了访管中断 自愿中断：访管中断 中断来源 中断：由处理机外部事件引起的中断：时钟、磁盘、终端 俘获：由处理机内部事件引起的中断：非法指令、地址越界、浮点溢出、trap指令 中断响应及硬件支持： 保护现场、恢复现场 现场： 后继指令所在主存的单元号、程序运行所处的状态、指令执行情况、程序执行的中间结果 保护现场：现场存入主存。 恢复现场：把保护的现场重新送到各个特殊寄存器 中断响应：中央处理器发出请求-&gt;中止现有程序执行-&gt;引出中断处理程序的过程 系统堆栈：存入指令计数器(PC)、处理机状态寄存器(PS) 的内容 (一般先PS后PC？)（硬件层面） 中断向量表：存入中断程序地址（地址内存从0开始） 中断响应实质：交换指令地址及处理机的状态信息 软件的中断处理过程 中断进入 step1 保护中断程序的现场（没有保存的寄存器） step2 进入相应的中断服务例程。 step3 恢复中断程序的现场。 第三章 操作系统的用户接口3.1 用户工作环境 操作系统提供的环境 操作系统的生成和系统初启 应用程序的处理3.2 操作系统的用户接口及分类 用户接口/用户界面：用户控制计算机的手段 操作接口/命令界面：键盘命令（分时操作系统）（MS-DOS、unix/linux）、图形界面（windows）、作业控制语言（批处理系统）组织工作流程，控制程序运行（C语言编写编译链接等） 程序接口：系统功能调用程序运行时，使用系统功能调用来请求操作系统的服务。3.3 系统功能调用及其实现技术 硬件支持：由用户态到管态 访管指令/自愿进管指令：svc n（功能号） 访管中断：正在运行的程序对于操作系统的某种需求。 系统功能调用：借助访管指令，取值n（特定功能），硬件进入，软件方法完成。 系统调用实现用户程序（svc i）、访管中断处理程序（按照i转移）、例行子程序入口地址表、例行自程序3.5 linux系统调用功能的实现 linux系统功能调用的进入 异常处理（系统调用通过异常类型实现）、软中断（int 0x80）、状态转换（从用户态到核心态，执行自陷处理程序（防管中断处理程序）） getuid系统调用过程 用户程序(getuid())-&gt;标准C库(内含int0x80)-&gt;系统调用处理程序-&gt;内核例程（系统服务例程） linux系统调用的进入和返回 软中断（自陷指令/访管指令）int 0x80 发生中断（自陷/访管中断） 处理机用户态-&gt;内核态（内核状态的改变） system_call()开始执行系统调用处理程序（系统功能调用的执行） 处理完毕后，iret返回到用户态 Linux系统功能调用的实现机制 硬件支持： 增加一个软中断指令、自陷 软件：系统调用号、系统调用表、系统服务例程、系统调用处理程序 增加一个新的系统调用 增加一个新的系统服务例程 增加一个新的系统调用号 在系统调用表中增加一项（新例程的地址） 将新的系统服务例程加入到系统中（系统重构） 系统调用号 linux中每个系统调用被赋予一个唯一的系统调用号格式：#define _NR_fork 2 系统调用表：记录了内核中所有已经注册过的系统调用、系统调用的函数指针（函数指针数组）（保存所有系统调用的函数指针） 系统调用的处理过程 宏SAVE_ALL保护现场 正确性检查 eax中包含系统调用号，调用对应的服务例程 服务流程结束时，RESTORE_ALL恢复寄存器 iret返回 第四章 进程及进程管理4.1 并发进程及其特点 程序的顺序执行：一个程序的一次执行过程称为一个计算，一个计算的若干操作必须按照严格的先后顺序来执行。 顺序性：按照严格顺序执行 封闭性：一旦开始执行，不受外界因素影响 可再现性：执行的结果与他的执行速度无关（时间无关），与初始条件有关。 并发程序 定义：若干个程序同时在系统中运行，程序在时间上时重叠的（一个没做完，另外一个已经开始） 并行语句记号cobegin S1，S2，S3…coend 并发程序的特点 失去了封闭性和可再现性一个程序的执行可以改变另一个程序的变量，后者的输出依赖于各程序执行的相对速度，失去了程序的封闭性的特点。 解决进程的同步问题（与时间有关的错误） 程序与计算不再一一对应：一个程序对应多个计算 程序并发执行的相互制约：间接的相互制约：资源共享、直接的相互制约：公共变量 4.2.1 进程定义 运行（获得cpu）-&gt;暂停（保留状态）-&gt;运行（获得cpu） 定义：在给定的活动空间和初始环境下，在一个处理机上的执行过程。 与程序的区别 程序静态（C语言代码不变）、进程动态（一次执行过程） 进程是一个独立运行的活动单位 竞争系统资源的基本单位（cpu，I/O） 一个程序可以对应多个进程，一个进程至少包含一个程序。4.2.2 进程状态及其变迁 进程的基本状态 运行状态（占用cpu）：已经获得运行所必须的资源，程序正在处理机上执行 （单cpu运行状态只能有一个） 等待状态（输入输出）：程序等待某一事件等待发生（等待外部传输完成等等）而暂时停止执行（这时即使给它cpu的控制权也无法执行） 就绪状态：进程已经获得除了CPU之外的运行所必须的资源，一旦获得了CPU控制权，就可以立即运行。 进程状态的变迁：（基本状态变迁只有前三个） 运行-&gt;等待：服务请求（I/O） 等待-&gt;就绪：（I/O是完成）服务完成，事件来到 就绪-&gt;运行：进程调度（CPU空出） 等待-&gt;运行：不可能 运行-&gt;就绪：时间片到了（分时系统中） 就绪-&gt;等待：有需求的系统提供（一般没有） linux系统状态变迁 新进程-&gt;就绪：创建 就绪-&gt;运行：进程调度 运行-&gt;就绪：被抢占 等待-&gt;就绪：等待的事情发生 运行-&gt;等待：等待某事件 运行-&gt;终止：进程完成 进程状态变迁的驱动及条件见作业习题4.2.3 进程控制块及进程队列 进程控制块：描述：1、进程与其他进程；2、系统资源的关系；以及3、进程在各个不同时期所处状态；的数据结构。称为进程控制块PCB。 程序与数据：描述进程“本身”所应该完成的功能 PCB：进程的动态特征，该进程与“其他进程”和“系统资源”的关系。 进程控制块（内容）： 进程标识符：进程符号或者内部id号 进程当前状态：本进程目前处于何种状态。 当前队列指针：登记了处于同一状态的“下一个进程的PCB地址”。 进程优先级：进程提要求CPU的紧迫程度。 通信信息：进程间通信记录的有关信息。 家族联系：本进程和家族的联系（子进程、父进程等等） 进程控制块的组织————进程队列结构 就绪状态队列：ready_q_start —— 一个或者（最多140个） 等待打印机队列：wait_lpt_q_start —— 多个（等待打印机、磁盘、键盘等） 运行指针：running ——一个 进程控制块的作用： 修改PCB表项 系统通过修改PCB表项的内容，‘动态记录’该进程‘当前的状态’和‘占有资源’的情况，以便实施有效的管理。 在进程队列中移动PCB结构 进程控制和进程调度的功能实现，是在相应的进程队列中移动相关的PCB结构。 4.3 进程控制 进程状态的变化 无 -（创建）- 有 -（撤销）- 消亡 运行 -（等待）- 等待 就绪 -（唤醒）- 等待 创建原语、撤销原语、等待原语、唤醒原语 （原语：原子操作（系统功能调用）） 进程创建 进程创建原语——create（fork） 进程创建原语的功能：创建一个具有指定标识符的过程，建立进程的PCB结构 进程创建原语的实现：PCB池 进程创建原语——create（fork） 申请一个空的PCB结构 无空位报错，有则将入口信息填入PCB的对应项。 将PCB入就绪队列。 返回进程pid（PCB池中的位置）。 进程撤销——kill/exit（退出自己）（一个，一组，自己） 运行指针获得当前进程的pid 释放本进程所占用的资源给父进程 释放PCB结构 转进程调度 进程等待原语——susp 保护CPU现场到PCB结构中 置该进程为“等待”状态 将其PCB结构插入到相应等待队列 转进程调度 进程唤醒原语——wakeup 找到该等待队列 将该结构移出等待队列 将该进程置为就绪状态，PCB插入就绪队列 返回刚刚被打断的进程 进程控制功能及其在进程队列上的操作4.4.2 进程互斥的概念 临界资源：系统中有多个进程，共享各种资源，然而有些资源一次只能为一个进程所用。 系统资源打印机，A、B共享一台打印机。若任意使用，两进程的输出结果交织在一起。解决方法：A使用之前先提出申请，然后独占，B只有在A释放之后系统才能分给B。 进程共享公共变量。 临界区： 互斥：操作系统中。某一进程正在访问某一存储区域时，就不允许其他进程“读出来”或者“修改”该存储区的内容。4.4.3 进程同步的概念 并发进程在一些关键点上可能需要相互等待与互通消息，这种相互制约的等待与互通消息称为进程同步 共享缓冲区的计算进程与打印进程的同步 计算进程cp和打印进程iop公用一个单缓冲 计算的速度快，输出的速度慢。丢失信息 计算的速度慢，输出的速度快。重复打印4.5 同步机构4.5.1 锁、上锁、开锁 每一个共享的临界资源：一个锁单位：0可用，1不可用。 上锁操作： 检测锁位的值（0or1） 若0变为1（占用） 若1（占用），返回第一步 开锁操作：使用完之后，锁位变为0。 上锁原语：保护cpu、当前进程变为等待，插入w的等待队列，转进程调度、w=1 开锁原语：移除等待队列的首元素，插入到就绪队列、该进程就绪、w=0上锁原语-&gt;临界区-&gt;开锁原语4.5.2 信号等的PV操作 2元组：(s.q)。 s&gt;0,表示有可用资源，进程执行，绿灯。 s&lt;=0，表示没有可用资源，停止执行，红灯。 P操作：P(s)；s减1（大于等于0返回，小于0（进程被阻）入信号灯等待队列，置为“等待状态”，转进程调度） V操作：V(s)：S加一。大于0返回，小于等于0唤醒（从信号灯的等待队列中取出首元素、入就绪队列、置“就绪状态”、返回）4.6 进程互斥与同步的实现4.6.1 用上锁原语和开锁原语实现进程互斥上锁原语-&gt;进入临界区cs-&gt;开锁原语 （main函数中设置w=1）4.6.2 用信号灯的P、V操作实现互斥 mutex:互斥信号灯 p(mutex)-&gt;临界区cs-&gt;v(mutex) 若有两个并发进程 mutex=1:没有程序进入临界区 mutex=0:有一个程序进入临界区 mutex=-1:一个程序进入临界区，另一个程序等待进入 若有n个并发进程，则可能有1,0,-1,…,-(n-1)取值 信号灯s为正值：挂起进程前还可以使用的P操作数，等于s还可以使用的物理资源数。 s为负值：在信号灯s队列中等待的进程个数。 P操作：请求一个资源/挂起进程，V操作：释放一个资源/唤醒进程。化验单-&gt;化验进程-》开始工作化验进程-》化验结果-》看病进程-》医疗方案。4.6.3 进程同步的实现 合作进程的执行次序 共享缓冲区的合作进程的同步的解法 考虑4.4.3节中提到的问题 sa表示缓冲区中是否有可供打印的计算结果，初值为0。 sb表示缓冲区有无空位置存放新的信息，其初值为1。 4.6.4 生产者和消费者 计算进程和打印进程 多个计算进程cp不断产生数据，生产者 多个打印进程iop不断打印数据，消费者 有多个缓冲区 通信问题 发消息进程send不断产生消息，生产者 受消息recieve不断接收消息，消费者 生产者和消费者的同步关系 生产者：有界缓冲区无空位，等待；放入物品，发消息 消费者：无物品，等待；取物品，发消息 信号灯的设置 两个同步信号灯 sb：缓冲区的数目，初值=n sa：信息数目，初值=0 一个互斥信号灯 mutex：有界缓冲区是否被占用，初值=1。 4.7 进程通信(IPC) 概念：进程之间直接以较高的效率传递较多数据的信息交互方式。也是两个不同的进程共享数据的方式。 实现：消息缓冲器、发送操作、接收操作 发送进程和接受进程的同步：发送等待、接受等待。4.7.2 进程通信的方式 消息缓冲通信 信息头：发送进程的标识符、接受进程的标识符、传送信息的字节数。 消息缓冲、发送原语、接受原语：每一次想要发送消息，形成一个消息缓冲区，消息原语将消息发出；接受进程在本进程主存空间形成一个接受区，接受原语接受消息。 信箱通信 定义信箱结构 消息发送模块、功能接受模块：提供发送原语和接受原语 所使用的信箱可以用于用户空间中（接受进程地址空间的一部分）、也可以用于操作系统空间中。 下面两个？？ sys V进程通信方式 信号量 共享内存 消息队列 posix进程间通信方式 共享内存 信号量4.8 线程的概念及特点 概念：比进程更小的活动单位，进程中的一个执行路径。 描述：进程中的一条执行路径、有自己私用的运行栈和处理机执行环境、与其他线程“共享”分配给进程的“内存和文件”、单个进程是创建的多个同时存在的线程中的一个。线程是一个动态概念。 线程调用实例4.9 操作系统的并发机制实例 创建进程及应用实例 创建线程及应用实例 等待进程、线程的终止及应用 信号量与使用方法 共享内存及应用实例4.10 进程调度 调度/分派结构：多个就绪状态的进程对处理机的竞争是由进程调度程序来协调的。 调度：就绪状态的进程排序。将一个进程插入到就绪队列，按照一定策略排序。 分派：调度时机，就绪队列第一个进程移出，建立其在处理机上执行环境，在处理机执行。 调度的功能 记录进程的状态变化 决定调度策略：1.优先调度、2.FIFO 实施处理机的分配和回收 调度时机 运行-》等待（阻塞） 运行-》就绪（时间片到） 等待-》就绪（唤醒） 任务完成，终止 异常出错 可剥夺调度，出现更高优先级的就绪进程。 调度方式：“重要而紧迫”的进程怎么处理 剥夺方式：暂停current，处理机给“重要而紧迫” 非剥夺方式：继续current，直到该进程完成或发生某事件到“完成”、“阻塞”，才给“重要而紧迫” 调度算法 进程优先数调度算法 优先数的分类和确定 静态优先数：根据所需资源来计算、基于程序运行时间估计、基于进程类型。 动态优先数：CPU超过一定时间降低、I/O增加，等待时间超过一定时间增加。 循环轮转调度算法 时间片的计算：q=t/n （t为用户能接受的响应时间，n为进入系统的进程数目） 时间片的选取：太小，系统切换很频繁（切换时间不可忽略），从系统角度来看，时间片取大比较好。太大，轮转一次的总时间增大，对进程的响应速度放慢了。 可变时间片轮转调度：根据系统当前的进程树来确定时间片的大小。 多级时间片循环调度 多个就绪队列 先进入高优先级队列，高优先级队列的时间片较小。 用完后，进入下一级队列，优先级降低，但时间片增大一倍。 这个算法，较小时间片处理完较短进程，避免较长进程被频繁中断。 时间片与优先级混合调度算法 I/O后进入因I/O而等待队列，完成后进入高优先就绪。 运行时间片到了，进入低优先就绪队列。 CPU空闲时，若高优先就绪队列非空，则从高优先就绪队列中选择一个进程运行，分配时间片100ms。 CPU空闲时，若高优先就绪队列为空，则从低优先就绪队列中选择一个程序运行，分配时间片为500ms。 照顾I/O量大的进程，适当照顾计算量大的进程，提高系统资源利用率。 第五章 资源分配与调度5.1 资源管理概述 资源管理的目的和任务 虚拟资源5.2 资源管理的机制和策略 资源分配机制 资源分配策略5.3 死锁 定义与示例 原因和必要条件 系统模型和死锁的处理 第六章 主存管理6.1 主存管理概述 主存分片共享 程序的逻辑组织（一维地址和二维地址）6.2 主存管理功能 虚拟存储器 地址映射 主存分配 存储保护6.3 分区存储管理 动态分区存储管理技术 分区分配机构/ 分区分配与安置策略（安置策略的算法首次适应、最佳适应、最坏适应） 碎片问题及拼接技术/6.4 页式存储管理 页式系统应解决的问题 页式系统的地址映射 请调策略 放置策略 淘汰策略 页式地址变换 请调页面的机制 淘汰机制与策略 几种置换算法（OPT、FIFO、LRU、）6.5 段式及段页式存储管理 段式地址结构 段式地址变换 扩充段表功能 段页式存储管理 第七章 设备管理（I/O管理）7.1 设备管理概述 设备管理的功能 设备的独立性 设备控制块7.2 缓冲技术 缓冲概述 常用的缓冲技术 UNIX系统的缓冲区管理7.3 设备分配（为计算机所有的用户程序、活动的进程分配它们所需的外部设备） 设备分配概述 独享分配 共享分配 虚拟分配7.4 输入/输出控制（软件控制硬件：端口、总线、控制器） 输入/输出硬件 输入/输出控制方式 输入/输出子系统 输入/输出控制的例子（以设备处理进程方式为例讨论I/O的控制过程） 第八章 文件系统8.1 文件系统概述 文件 文件系统 文件的组织8.2 文件的逻辑结构和存取方法 文件的逻辑结构 文件的存取方法8.3 文件的物理结构 连续文件 串联文件 索引文件 文件物理结构比较（连续、串联、索引）8.4 文件存储空间的管理 空闲文件目录 空闲块链 位示图 分配策略8.5 文件目录 文件目录及其内容 一级文件目录及缺点 多级文件目录8.6 共享与安全 文件共享与安全性的关系 存取权限的类型及其验证 用文件路径名加快文件的查找8.7 文件操作与文件备份 文件操作 文件备份8。8 UNIX文件系统的主要结构及实现 UNIX文件系统的特点 UNIX系统的索引文件结构 UNIX系统文件目录结构 UNIX系统的打开文件机构 文件存储器空闲块的管理 UNIX文件系统调用","categories":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}],"tags":[{"name":"System & Network","slug":"System-Network","permalink":"www.waylonding.cn/blog/tags/System-Network/"},{"name":"Operating System","slug":"Operating-System","permalink":"www.waylonding.cn/blog/tags/Operating-System/"}],"keywords":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}]},{"title":"ComputerNetwork Notes","slug":"ComputerNetwork-Review-Notes","date":"2019-11-19T08:13:01.000Z","updated":"2019-12-04T09:13:24.394Z","comments":true,"path":"2019/11/19/ComputerNetwork-Review-Notes/","link":"","permalink":"www.waylonding.cn/blog/2019/11/19/ComputerNetwork-Review-Notes/","excerpt":"","text":"计算机网络-自顶向下 学习笔记 &amp; 计算机通信与网络课程复习参考书目：计算机网络-自顶向下方法（原书第7版） 第1章 计算机网络和因特网1.1 什么是因特网 定义：互联、自治（无主从关系）的计算机集合 全球最大的互联网络：ISP网络互联的“网络之网络” 计算机设备集合：主机=端系统（运行各种网络运用） 通信链路：光纤、铜缆、无线电等等；传输速率=带宽 分组交换：转发分组（数据包）：路由器和交换机 端系统接入Internet靠服务提供商ISP，协议控制因特网中的信息接收和发送 因特网标准：RFC、IETF 因特网的服务视角 为网络应用提供通讯服务的通信基础设施：Web、VoIP、email等 为网络应用提供应用编程接口（API）：支持应用程序连接网络，提供类似邮政系统的数据传输服务1.2 网络边缘 网络结构的深入研究 网络边缘：主机、位于数据中心的服务器 网络核心：路由器、网络的网络 接入网、物理媒体：通信链路（有线或者无线的通信链路） 主机（端系统）：位于网络边缘、运行网络程序 通信模型：C/S模型和P2P （客户机和服务器） C/S：Web应用、文件传输FTP请求 P2P：QQ、Skype、BT 接入网络 将网络边缘接入网络核心（端系统连接到边缘路由器） 边缘路由器：端系统到任何其他远程系统路径上的第一台路由器1.3 网络核心 基本问题：数据如何通过网络传输 关键功能：路由（确定从源到目的）+转发（将分组从路由器的输入端口交换至正确的输出端口） 电路交换 过程：建立连接、交换数据（通信）、释放连接 特点：独占资源、确定链路、实时传输不会延迟 多路复用（共享信道） 方法：频分多路复用——FDM、时分多路复用——TDM、波分多路复用——WDM、码分多路复用——CDM CDM（码分多路复用）：广泛用于无线链路共享 每个用户分配一个唯一的m bit的码片序列（0用-1表示，1用+1表示） 编码=(码片序列*数据序列)_求和 解码=码片序列*编码信号/m 要点：接收哪个用户的数据，用哪个数据的码片序列。 存在的问题：网络有突发性、间歇性，不合适；不够灵活； 报文交换：源/应用发送整体信息（例如一个文件）给目的主机 分组交换（存储、转发） 报文分拆出来的一些列相对较小的数据包 分组交换需要报文的拆分和重组，需要额外开销（加头） 分组传输时间延迟：delay=L/R T=M/R+nL/R 分组交换VS电路交换 相同条件下：分组交换能够比电路交换支持更多的用户 若要连续传输大量数据（及传送时间远远大于呼叫建立时间），则采用电路交换） 应对突发数据、间接数据的时候，采用分组交换比较合适 网络核心分类： 电信网络：电路交换网络（FDM、TDM）、分子交换网络（虚电路网络、数据报网络） ISP和因特网主干 端系统-&gt;internet：接入ISP——家庭、公司、大学ISPs 接入ISP进一步互联：这样任任意两个主机才能互相发送分组 当前internet结构：十分复杂，无人能够给出准确描述 网络的网络 若所有的接入ISP直接互联O(N^2)!太大 可选方案1: 每个接入ISP连接到一个国家或全球ISP.(主干ISP) 商业角度会有竞争对手：会有多个ISP集群 但是这些ISP必须互联，产生：对等链路和IXP(internet exchange point) 可能出现区域网络（reginal net）连接接入ISP 内容提供商网络可以运行自己的网络，将服务、内容靠近最终用户。 最后结构为： 一级商业ISP：tier-1：提供国家或国际范围的覆盖 内容提供商网络（google）：私有网络，连接其数据中心与internet（绕过一级ISP和区域ISPs）1.4 分组交换网中的时延、丢包和吞吐量 k=10^3, M=10^6, G=10^9, T=10^12 时延 原因：分组到达速率&gt;输出链路容量、分组排队、等待输出链路可用 d_nodal = d_proc + d_queue + d_trans + d_prop d_proc: 节点处理延迟——差错检测，确定输出链路，通常&lt;毫秒 d_queue: 排队延迟——输出链路等待传输的时间，取决于路由器的拥塞程度 d_trans: 传输时延——L分组长度，R链路带宽，d_trans=L/R d_prop: 传播时延——d物理链路长度，s媒体中的传播速度，d_prop=d/s 在一个节点从前到后依次是：节点处理时延(d_proc)、排队时延(d_queue)、传输时延(d_trans)、传播时延(d_prop) 排队时延 链路带宽R，分组长度L，平均分组到达速率a。 流量强度=La/R La/R-&gt;0:平均排队时延很小，甚至为0 La/R&lt;1：时延较小，且会随着时间的推延而变小 La/R=1：时延不会变化，具体数值取决于当时队列长度 La/R&gt;1：平均时延较大，且随时间的推延而趋于无穷 分组丢失的原因和后果 缓存中队列的容量是有限的 分组到达队列已满，分组被丢弃 被前一个节点、源端系统重新传输，或者根本不会重传 时延带宽积=传播时延*带宽：比特单位的链路长度 丢包（分组丢失） 原因：分组到达已满队列，将被丢弃；丢弃分组可能由前序节点或者源重新发送（或者不发送） 丢包率=丢包数/已发送分组总数 吞吐量：表示在发送端与接受端之间传送数据的速率 即时吞吐量：给定时刻的速率 平均吞吐量：一段时间的平均速率 瓶颈链路：端到端路径上，限制选到端吞吐量的链路 internet场景 min(Rs,Rc,R/10): 10条链路共享1.5 协议层次及服务模型 计算机网络的体系结构 分层结构 每一层完成特定种类的服务/功能，每一层依赖底层提供的服务，通过层内的动作完成相应的功能 体系结构是计算机网络隔层及其协议的集合，是抽象的 分层结构的好处：关系清晰；有利于系统更新、维护；有利于标准化。 分层的参考模型（refernce model）可用于讨论 因特网的协议栈 应用层：支持网络应用 FTP、SMTP、HTTP 运输层：主机间的数据传输（端到端的传输） TCP、UDP 连接控制、流量控制、差错控制、分段与重组、SAP殉职（将完整报文提交给正确进程） 网络层：将数据报从源端重送到目的端 IP、路由协议 路由和分组转发、逻辑寻址、IP全局唯一 链路层：数据在网络相邻节点之间的传输 PPP、以太网、802.11 流量控制、差错控制、访问控制 node-to-node数据传输、组帧、物理寻址 物理层：在线路上传输比特流 接口特性、传输模式（单工、全/半双工）、比特同步、数据率、比特编码 基本概念 实体（entity）：任何可以发送和接收消息的“硬件”和“软件进程”，通常是一个特定的“软件模块”。 对等体（peer）：不同机器上包含对应层的实体称为对等体 协议（protocal） 语法：即数据与控制信息的结构或者格式 语义：何种控制消息，完成何种动作，做出何种应答 同步：事件实现顺序 服务（service）：保证上层对等体之间能互相通信，“下层向上层”提供的功能 服务原语：邻层交互交换的必要命令 注意：协议是同层，服务是邻层 协议数据单元（PDU）：对等层次上传输的数据但愿 服务数据单元（SDU）：层与层之间交换的数据单元 网络体系结构（Network Architrcture）：层和协议的集合 协议栈：特定的系统使用的一组协议（每层一个协议） 报文的封装 应用层：报文 运输层：报文段=报文+首部 网络层：数据报=报文段+首部 链路层：帧=数据报+首部+尾部 物理层：比特流 OSI参考模型（由国际标准化组织ISO提出） 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 表示层：应用程序解释数据的含义：加密、压缩、数据表示转化（转换为主机独立的编码） 会话层：数据交换、同步、定界、建立检查点、恢复能力（最薄一层） 实际internet没有表示层和会话层，全部交给了应用开发者，交给了应用层 TCP/IP模型 应用层（HTTP、SMTP）、运输层（TCP、UDP）、网际层（IP）、网络接口层（网络接口） 5层参考模型：综合TCP/IP模型和OSI模型第2章 应用层2.1 应用层协议原理2.2 Web和HTTP2.3 因特网中的电子邮件2.4 DNS：因特网的目录服务2.5 P2P文件分发 第3章 运输层3.1 概述和运输层服务 运输层：不同进程、逻辑通信（只考虑点到点，不考虑点和点之间的具体构造） 网络层：不同主机，逻辑通信 家庭通信的例子：进程=（要发信息的）孩子们，应用消息（报文）=信封，主机=房子，传输层协议=要送信给邮局的人，网络层协议=邮政服务 UDP数据报、TCP报文段 TCP差错检测、拥塞控制、可靠数据传输（连接建立）3.2 多路复用与多路分解 接收端进行多路分用：传输层依据头部信息，将收到的segement交给正确的socket 发送端进行多路复用：从多个socket接收数据，为每块数据封装上头部信息，生成segmennt，交给网络层。 数据报携带一个传输层的段（报文段）：每个段携带源端口号和目的端口号。 无连接的多路分用 UDP的Socket二元组表示：（目的IP，目的port） 携带源端口号，以便信息反馈 创建port：DatagramSocket mySocket1=new DatagramSocket(12345); 面向连接的分用 TCP Socket的四元组表示（源IP，源port，目的IP，目的port） 多线程的Web服务器：进程创建多线程，多TCP连接3.3 无连接运输：UDP 基于internet的IP协议：多路复用和分用、简单的错误校验 best effort服务，可能：丢失、非按顺序到达 优点：减少连接时延、实现和维护简单、首部开销小、无拥塞控制（更好地控制发送时间和速率） 流媒体、DNS、SNMP 应用层实现可靠传输 报文结构：源port（16）、目的port（16）、length（16）、checksum（16） checksum：段的内容视为16bit整数：取和，进位加在后面，按位求反。接收方计算校验和和校验字段进行比对：不等有错，相等不一定没错。3.4 可靠数据传输原理 可靠的定义：不错、不丢、不乱。 可靠数据传输协议：rdt。TOP-10问题！ 可靠数据传输协议的基本结构：接口 rdt_send():上层应用调用，将数据交给rdt以发送给对方 udt_send():被rdt调用，在不可靠信道上向接收方传输数据 rdt_rcv():分组到达接收方信道时被调用 diliver_data():被rdt调用，向上层应用交付数据 注意：分组在不可靠信道上传输是双向的，而上层接收和交付数据是单向的 packet=make_pkt(data):把数据打包变成分组 extract(packet,data):把分组提取变成数据 Rdt1.0:可靠信道上的可靠数据传输 不会发生错误、不会丢弃分组 FSM见PPT27面 Rdt2.0:产生位错误的信道（0反转位1，1反转为0） ARQ协议 一种重传机制的rdt协议 校验和检测错误 ACK/NAK: 显式地，正确接收/分组有错误 NAk: 重传分组 引入的新机制有：差错检测、接收方反馈控制消息ACK/NAK、重传 FSM 发送方：停-等协议 等状态：等待来自上层的调用 停状态：等待ACK或NAK 分组增加校验和：snd_pkt(data,checksum) 判断收到了NAK，重传分组：rdt_rcv(rcvpkt)&amp;&amp;isNAK(rcvpkt)-&gt;udt_send(sndpkt) 判断收到了ACK，回到等状态，action为空：rdt_rcv(rcvpkt)&amp;&amp;isACK(rcvpkt) 接收方 判断分组被损毁，返回NAK：rdt_rcv(rcvpkt)&amp;&amp;corrupt(rcvpkt)-&gt;udt_send(NAK) 判断分组正常，提取数据交付上层，返回ACK：rdt_rcv(rcvpkt)&amp;&amp;notcorrupt(rcvpkt)-&gt;extract(rcvpkt,data),diliver_data(data),udt_send(ACK) Rdt2.1&amp;&amp;Rdt2.2: 解决NAK、ACK错误的情况 Rdt2.1 如果错误，就重传。重传会产生重复分组，解决重复分组，添加序列号实现，接收方丢弃重复分组。两个序列号（0，1）即可 FSM： Rdt2.2: 无NAK的消息协议 发送方收到重复ACK之后，重传 FSM Rdt3.0: 处理分组丢失问题 发送方等待合理时间：如果没有ACK，重传 增加定时器 FSM见PPT 几种典型场景见PPT 没有丢失 丢失packet 丢失ACK 过早超时 Rdt3.0的性能分析：见PPT U_sender=(L/R)/(RTT+L/R) 性能很差 提高Rdt性能：流水线传输以及滑动窗口协议 等待过程中可以发送其他分组，N段流水性能提高N倍 窗口：允许使用的序列号范围，尺寸为N即最多有N个等待确认的消息 GBN * SR 3.5 面向连接的运输：TCP TCP将IP层的不可靠变为可靠 技术：流水线机制、累计确认、单一重传定时器 出发重传的事件：超时、收到重复的ACK 如何估计RTT SampleRTT：从段发出去到收到ACK的事件 SampleRTT的变化值：测量多个RTT求平均值（指数加权移动平均）EstimatedRTT=(1-alpha)EstimatedRTT+alphaSampleRTT (alpha=0.125) 测量RTT的变化值：SampleRTT和EstimatedRTT的差值DevRTT=(1-beta)DevRTT+beta|SampleRTT-EstimatedRTT| (beta=0.25) TimeoutInterval=EstimatedRTT+4*DevRTT 发送方 创建segment，序列号：segment第一个字节的编号。 开启计时器，设置超时时间TimeOutInterval 超时：重传引起超时的Segment，重起定时器 shoudaoACK：更新SendBase，若窗口中还有没有被确认的分组，重起定时器 快速重传机制 重复ACK检测分组丢失：如果sender收到对于同一个数据的3个ACK，即假定该数据之后的段已经丢失，在计时器超时之前即进行重传 超时间隔加倍：每一次TCP重传均将下一次超时间隔设置为先前值的两倍 流量控制 发送方数据过快过多，淹没接收方（buffer溢出） 窗口值的计算 接收方：LastByteRcvd – LastByteRead ≤ RcvBufferRcvWindows = RcvBuffer – [LastByteRcvd - LastByteRead] 发送方：LastByteSent – LastByteAcked ≤ RcvWindow 特殊情况：RcvWindow=0，无任何数据给发送方，发送方会向接收方发送只有一个字节数据的报文段，目的是试探 连接管理 初始化TCP变量 序列号、Buffer和流量控制信息 三次握手 客户发送SYN报文段：告知服务器序列号 服务器收到SYN报文段，回复SYNACK报文段：建立缓存区、回复序列号 客户端收到SYNACK，回复ACK报文段，可能包含数据 关闭请求：一般是客户机关闭 客户机向服务器发送TCP FIN报文段 服务器收到FIN，回复ACK，关闭连接，发送FIN 收到FIN，回复ACK；重复收到FIN，重发ACK 服务器收到ACK，真正关闭连接 TCP连接管理的状态序列：见PPT813.6 拥塞控制原理 拥塞的表现：分组丢失、分组延迟过大 拥塞控制和流量控制的区别：拥塞控制着眼于网络处理，流量控制着眼于接收方处理 场景一：两个发送方、两个接收方，一个具有无限大缓存的路由器，没有重传。假定带宽为C。PPT83 场景二：有限缓存的一个路由器 如果sender知道buffer信息，有buffer发数据，没有buffer就不发。lamdaIn=lamdaOut 丢失后才重发。lamdaIn‘&gt;lamdaIn&gt;=lamdaOut 定时器超时重传。lamdaIn‘&gt;&gt;lamdaIn=lamdaOut不必要的重传会占用链路带宽 场景三：四个发送方、多跳、超时/重传 另一个代价：分组被drop掉了，相当于浪费了上游的资源。 lamdaIn’过大，lamdaOut趋近于0，即所有资源都被浪费掉了 拥塞控制的方法 端到端的拥塞控制：TCP的方法。路由器不需要提供支持，观察丢失、时间延迟等网络行为判断是否拥塞。 网络辅助的拥塞控制：路由器向发送方显示地反馈网络拥塞信息。（阻塞分组的形式指示发送方应该采取何种速率） ATM ABR拥塞控制（网络辅助） RM cells：交换机设置RM cell位：NI bit——rate不允许增长，CI bit——拥塞指示。RM cell由接收方返回给发送方 RM cell的ER字段（两个字节）：显式的速率字段，发送方货值路径所能支持的最小速率 数据cell的EFCI位：拥塞的交换机将其设置为1，如果RM cell前面的data cell的EFCI为1，发送方在返回RM cell中置CI位。3.7 TCP拥塞控制 TCP的发送方限制外发流量的速率： 拥塞窗口：LastByteSent-LastByteAcked&lt;=CongWinrate=congWin/RTT bytes/sec 发送方感知拥塞的方式：发送超时、三个冗余ACK TCP 拥塞算法Reno： 加性增，乘性减 Additive Increase：每个RTT将CongWin增大一个MSS（防止拥塞窗口缓慢增大，过早出现拥塞） Multiplicative Decrease：发生丢包事件后，当前COngWin大小减半（大大减少注入到网络中的分组数） 慢启动SS： TCP建立连接时，CongWin=1 连接开始时，指数性增长。每个RTT时，CongWin翻倍（收到了ACK之后） 门限值ssThread 对超时事件的反应： 门限值设置为当前CingWin的一半 将CongWin设置为1个MSS大小 窗口以指数增大 达到门限值之后，线性增长。 对于重复收到3个ACK的反应——快速重传 门限值设置为但概念CongWin的一半，将CongWin减少为现在的门限值+3MSS 线性增大拥塞窗口 早起的Tahoe版本在这种情况下也将CongWin降为1。 Reno的改进：New Reno TCP的性能： 丢包发生时，窗口大小为W，吞吐量为W/RTT 丢包事件发生之后，窗口大小减小为W/2，吞吐量为W/2RTT 平均吞吐量为0.75W/RTT 吞吐量是丢包率L的函数：1.22MSS/(RTT*sqrt(L)) 公平性分析： 目标：如果K个TCP连接共享同一个带宽为R的瓶颈链路，每个连接的平均传输速率为R/K。 TCP是公平的吗：是的，P118 TCP和UDP一起，无公平性。UDP恒定速率发送，而TCP会被拥塞机制限制速率 只使用TCP也不存在公平性。某些应用可以并发产生TCP连接。例如：链路速率为R，已经有9个连接，那么： 新来的请求1个TCP，被分到R/10的速率，新来的请求11个TCP，被分到R/2的速率 传输层主要内容： 复用/解复用 可靠数据传输 流量控制 拥塞控制 UDP、TCP第4章 网络层：数据平面4.1 网络层概述 功能：实现主机到主机之间的通信 发送主机向接收主机传送数据段（segment）。 发送主机：将数据段封装到数据报（datagram）中。 接收主机：向传输层交付数据段 路由器检验所有穿越它的IP数据报的头部域 核心功能：转发和路由、连接建立 转发：从路由器的输入端口转移到合适的输出端口（转发表） 路由：确定分组从源到目的经过的路径（路由算法） 连接建立和传输层不同点：网络层是两个主机之间。路径上的路由器等网络设备都要参与其中。传输层是应用进程之间的连接，对中间网络设备透明 网络层服务模型 无连接服务：数据报网络 不事先为系列分组的传输确定传输路径。 每个分组独立确定传输路径，不同分组可能传输路径不同 连接服务：虚电路网络 首先为系列分组的传输确定从源到目的经过的路径 沿着该路径（连接）传输系列分组，系列分组的传输路径相同 传输结束后，拆除连接 虚电路网络 虚电路：源主机到目的主机类似于电路的逻辑连接 分组交换（与电路交换的区别）、每个分组的传输利用链路的全部带宽 源主机到目的主机的路径经过的网络层设备共同完成虚电路的功能 通信过程：呼叫建立-&gt;数据传输-&gt;拆除呼叫 建立的过程中会分配VCID 每个分组携带虚电路标识VCID，而不是目的主机地址 虚电路经过的每个网络设备（如路由器），都需要维护虚电路的状态 优点：继承了电路交换和分组交换的优点 链路、网络设备资源可以面向VC进行预分配（预分配资源=可预期服务性能） 占用全部带宽 VC的具体实现 源主机到目的主机一条路径 每一段链路有一个虚电路号VCID，沿这段链路传输的分组携带对应虚电路的VCID而不是目的地址。（因为每一段链路上的设备的能力是各不相同的） 路由器转发分组时，依据转发表改写/替换虚电路号 每一个路由器需要维护VC连接的状态信息：虚电路建立对应接入口的增加，拆除对应着删除 虚电路信令协议：用于VC的建立、维护和拆除（internet网络不采用） c启动呼叫、s呼叫到达、s接受呼叫、c呼叫连接、c数据流开始、s接收数据 数据报网络 网络层无连接，每个分组携带目的地址 路由器根据目的地址转发分组：根据路由协议和算法构造转发表，检索转发表，每一个分组独立选路。 转发表：目的地址、输出链路 目的地址（32为二进制）为地址范围，聚合转发表入口 地址范围为连续地址（前n比特有相同地址） 最长前缀匹配优先：遇到都可以匹配的时候，发送最长前缀对应的链路接口 数据报网络 VS VC网络 Internet（数据报网络）：简化网络，复杂“边缘”（意思是很多事情都在端系统完成） 没有严格的时间需求 链路众多，特点和性能各异，统一服务困难 ”智能“端系统：可以自适应、实现性能控制和差错恢复 ATM网络（VC网络）：简化“边缘”，复杂网络（意思是很多事情都在网络上完成） 电话网络演化而来，核心业务是实时对话：严格的时间、可靠性需求 ”哑“端系统（非智能）：电话机、传真机4.2 路由器工作原理 路由器的结构 路由选择和分组转发两个部分组成 路由选择：路由选择处理机=路由选择协议+路由表 交换结构：分组处理——转发表 线路端接：物理层位流级的接收 数据链路层处理（协议、拆封）：以太网等等 网络层处理（排队、查找、转发） 输入端口分散式交换: 给出“目的地址”，使用“路由选择表”（存储于输入端口的内存中），查找“输出端口” 目标：以“线路速度”完成输入端口的处理 排队：if 到达速度 &gt; 转发给结构的速度 线头阻塞：FIFO机制造成的，因为输入端的FIFO首先处理队列靠前的数据，队列后面的数据的缓存口可能已经空闲，但是因为得不到处理而等待。 交换结构 经内存交换 CPU控制完成 分组被拷贝到内存中，CPU控制下输出到输出端口 受限于内存的带宽（每个分组走两次总线） 经总线交换 输入端口经一根共享总线，直接传送到输出端口 受限于总线的带宽 32Gbps总线，Cisco 5600对于运行在接入网或者企业网的路由器，通过总线交换的转发速度是足够的 经内连网络 优点为：克服总线带宽限制 先进设计：将长度变化的IP分组，分片乘固定尺寸的“信元”，通过交换结构对“信元“进行转发 Banyan网络：过去在多处理机计算机体系结构中，用来互联多个处理器网络 60Gbps，Cisco 12000 输出端口 缓存管理：当“交换结构”将分组“交付给输出端口的速率”超过输出“链路的速率”时，输出端口缓存 调度原则：在“数据报队列”中，“选择数据报”进行传输 缓存区的设置 RFC3439: B=RTT*R 理论研究，N条TCP连接经过的链路而言：B=RTT*R/sqrt(N) 输出端口调度策略：先来先服务（FCFS）、加权公平排队（WFQ） 分组丢弃策略 弃尾策略 删除一个或者多个已排队的分组 主动队列管理——随即早期检测RED 每时每刻计算平均的队列长度avgth 最小阈值minth、醉倒阈值maxth avgth小雨minth，允许分组入列 avgth大于maxth，分组被标记或者丢弃 在两者之间，按照概率标记或者丢弃分组4.3 网际协议：IPv4、寻址、IPv6及其他 IP数据报结构：首部+数据 首部：固定部分+可变部分 固定部分： 版本号：4 bit：4-&gt;ipv4；6-&gt;ipv6 首部长度：4 bit：最大数是15（每一个单位对应4个字节/一行） 典型IP分组第一个字节为45 服务类型TOS（区分服务）：8 bit：只有在网络提供区分服务才有效，一般不可用，一般00H 总长度：16 bit：首部+数据的总长度：最大65535B。and最小的IP分组首部为20B。故IP分组可以封装的最大数据为：65535-20=65515B 生存时间（TTL）：8 bit：IP分组在网络中可以通过的路由器数，每转发一次分组TTL减1，如果TTL=0，丢弃该IP分组 协议：8 bit：指示是哪个数据报：实现复用/分用。eg. 6为TCP，17为UDP。 首部校验和：16 bit：计算校验和时该字段全0。 源地址、目的地址：32 bit：分别标识发送分组的源主机/路由器（网络接口）、接受分组的目的主机/路由器（网络接口）的IP地址。 可变部分 选项字段：1-40B：携带安全、源选路径、时间戳和路由记录等内容。实际上很少被使用。 填充：0-3B之间，补齐整个首部，符合32为对齐，保证首部长度是4字节的倍数。 IP分片 MTU（最大传输单元）：链路层数据帧可封装数据的上限 不同链路的MTU不一样 分片与重组 大IP分组向小MTU链路转发的时候，可以被“分片”。路由器只分不装，最后在目的主机组装 IP首部的相关字段用于“标识分片”以及确定分片的相关顺序（如果没有收全则全部丢弃） 标识ID：16 bit：一个计数器，每产生一个IP分组计数器加一，作为该IP分组的标识 标志位：3 bit： DF：是否能对大IP分组进行分片（1不行，0可以） MF：1代表不是独立的IP分组，是分片过后的，且不是最后一片；0代表最后一片（末分片） 片偏移 13 bit：一个IP分组“分片”封装“源IP分组”的数据“相对偏移量”。 如果没有被分片，这里一定是0 片偏移量以8字节为单位 分片过程：L为ip分组长度，M为待转发链路的MTU L&gt;M,DF=0可以分片 复制源IP分组的标识 除了最后一个分片，其他分片均分为MTU允许的最大分片 最大分片可封装的数据为：d=[(M-20)/8]_向下取整*8 需要总片数为：n=[(L-20)/d]_向上取整 每片的片偏移字段取值为：Fi=d/8*(i-1) 每一片总长度d+20，最后一片L-(n-1)*d MF的取值：前n-1片取1，最后一片取0 IP编址 IP分组：源地址、目的地址 接口：主机/路由器与物理链路的连接：实现网络层功能、路由器通常有多个接口、主机通常只有1到2个接口 IPv4: 32bit：编号标识主机、路由器接口 IP地址与每个接口关联 IP地址=网络号NetID+主机号HostID IP子网：相同网络号设备接口+不跨越路由器就可以彼此互联 有类编址： 50% A类：（0+7位）NetID+（24位）HostID（0.0.0.0-127.255.255.255） 25% B类：（10+14位）NetID+（16位）HostID (128.0.0.0-191.255.255.255) 12.5% C类：（110+21位）NetID+（8位）HostID (192.0.0.0-223.255.255.255) 6.25% D类：1110+28位（组播地址）(223.0.0.0-239.255.255.255) 6.25%：E类：1111+28位（研究保留）(240.0.0.0-255.255.255.255) 特殊IP地址：见PPT 私有IP地址 A：NETID：10 B：NETID：172.16-172.31 C：NETID：192.168.0-192.168.255 IP子网：NetID+SubID（原网络主机号的部分比特）+HostID 路由器将各个子网连接在一起 子网掩码：NetID和SubNetID全部取1，HostID全部取0 子网掩码的运用：目的IP与子网掩码按位与运算，提取子网地址 可分配地址范围：去掉主机域全0（子网地址）和主机域全1的（广播地址）。 IP地址扩展——构造超网 从网络号中借用一部分位数作为主机号 CIDR：无类域间路由 消除A、B、C类地址的界限，NetID+SubID=prefix可以任意长度 子网地址与子网掩码，方便子网划分 无类地址的格式：a.b.c.d/x (x为前缀长度，十进制) 优点 提高IPv4地址空间分配效率 提高路由效率：很多子网聚合成一个较大的子网，构造超网 路由聚合（减少路由表的表项）：满足最长前缀匹配优先 DHCP协议：主机如何获取IP地址 静态“硬编码”：IP、子网掩码、默认网关（路由器接口地址） 动态DHCP（port 67） 从服务器动态获取：IP、子网掩码、默认网关、DNS服务器名称与IP地址 即插即用型的协议，允许地址重用、支持在用地址的续租、支持移动用户加入网络 新主机获取本网IP过程： 主机，广播DHCP发现报文（DHCP discover） DHCP服务器响应，DHCP offer（DHCP提供报文） “DHCP request”（请求报文） “DHCP ack”（确定报文） 报文在传输层采用UDP 网络地址转换NAT：（私有地址在共有网络上的转换） NAT的动机： 本地IP变更，无需告诉外界 变更ISP时，无需修改内部网络的IP地址 内部网络设备对外界网络不可见，不能直接寻址，保证安全性 实现（NAT转换表） 替换：(源IP地址，源端口号)-&gt;(NAT IP地址，新端口号) 记录：(源IP地址，源端口号)和(NAT IP地址，新端口号)记录下来 替换：(源IP地址，源端口号)替换每个进入内网的IP数据报的(目的IP地址，目的端口号)，即(NAT IP地址，新端口号) NAT的主要争议：违反了端到端的原则，节点不应该介入修改IP地址和端口号；路由器仅应当处理高达第三层的分组；应当采用IPv6来解决IP地址短缺问题 NAT穿透问题（外部客户访问） 采用端口NAT，在路由器中静态的为服务器配置”一条记录“如(123.76.29.7,80) 总是指向(10.0.0.1,80) 通用即插即用UPnP IGD协议，了解公共IP地址 向路由器注册、移除映射记录（内部ip，内部port）-&gt; (公共ip，公共port) 内部程序向外部程序公开(公共ip，公共port) 适用于p2p 中继（skype）（有一个中继服务器） 10.0.0.1通过NAT与中继建立了连接 客户端与中继建立了连接 建立中继 IPv6 动机：32位IPv4分配殆尽、改变首部格式（快速处理、转发数据报；支持QoS） 格式：固定长度位40byte的首部、不允许分片（源主机分，目的主机组装） 流量类型：用于区分数据报类型 没有检查和，中间节点无需计算 流标签20 bit 原地址、目的地址：128bit IPv6地址的格式 一般地址——1080:0:FF:0:8:800:200C:417A 压缩形式——FF01:0:0:0:0:0:0:43=FF01::43 IPv4的嵌入形式：前80bit是0，然后16bit是1，剩下32bit是IPv4地址 使用前缀，不再使用掩码 URL中IP通常用中括号括起来 IPv4到IPv6的迁移 隧道技术：IPv6数据报作为IPv4数据报的载荷进行封装，穿越IPv4网络。 设置标志日，统一迁移（事实上，没有一个特定的日子去区分IPv4和IPv6网络，两者会长时间共存） 双栈技术： 新加入的设备支持IPv4/IPv6双协议栈。 链路上，如果源和目标均支持IPv6，则使用IPv6进行通信，任意一方不支持IPv6，则使用IPv4进行通信 可能会出现信息丢失 第5章 网络层：控制平面5.1 概述 默认路由器：一台主机“直接”连接到的路由器 源路由器：“源主机”的默认路由器 目的路由器：“目标主机”的默认路由器 选路算法的目的：找出连接“源路由器”到“目的路由器”的一条“好的”（费用最低）的路径5.2 路由选择算法 网络抽象——图 路由器：节点；链路：边 cost费用——c(x,x`)：根据需要进行设置（可以是1，带宽的倒数、拥塞程度） 描述路径好坏：路径费用越小越好 静态路由&amp;动态路由 静态路由：手工配置、路由更新慢、优先级高 动态路由：算法计算、更新快、定期更新、及时响应链路费用或拓扑变化 全局信息&amp;分散信息 全局信息算法：所有路由器掌握”完整的“网络拓扑和”链路费用信息“eg 链路状态路由算法（LS） 分散信息算法：路由器只掌握物理“相连的邻居”以及“链路费用”、邻居间的信息交换，运算的迭代过程eg 距离向量路由算法（DV） 负载敏感类型的分类 负载敏感算法：链路费用会动态地变化，反映出链路的当前状况 负载迟钝算法：链路费用不明显地反应链路的当前状况 LS Dijkstra 算出源到所有节点的最小路，最后通过跟踪节点，找到路径 c(x,y)=cost/无穷 D(v):从源到目的v的当前路径费用权值 p(v): 沿从源到v的当前路径，v的前序节点 N`：已经找到最小费用路径的节点集合 最短路径树和最终转发表： 最短路径树：构造dijkstra表的时候，构造出的树 目的、链路：路由器只反映第一跳 算法复杂型：O(n^2)，利用堆的复杂性为:O(mlogn)。 存在震荡的可能：假设链路费用是该链路承载的信息量。会产生刚路由到一个路由器，更新路由表，又路由回去的情况。 解决方案：强制链路费用不依赖于所承载的流量、确保所有的路由器不同时进行LS算法。 距离向量路由算法 Bellman-Ford dx(y):从x到y最短路径的费用。dx(y)=min{c(x,v)+dv(y)}。v为x的邻居 重点：节点获得最短路径的下一跳，用于信息转发表。（选择哪个v） Dx(y):x到y的最小费用估计。x维护距离向量(DV):Dx=[Dx(y):y属于N] 节点x维护自己的Dx，又已知c(x,v)，还要维护邻居的距离向量Dv 核心思想 每个节点不定时地维护自身的DV，发送给邻居 当x接收到邻居的新的DV估计时，即依据BF更新自身的距离向量估计Dx(y)=min{c(x,v)+Dv(y)}（y属于N） Dx(y)收敛与dx(y) 异步迭代：局部链路费用的改变、来自邻居的DV更新 分布式：每个节点只有当DV变化的时候，才通告给邻居，邻居在必要的时候，再通告给他们的邻居 链路状态传播的特点： 好消息传的块 坏消息传的慢 解决方案：毒性逆转如果z通过y选路到达目的地x，则z将通告y它到x的距离是无穷大。（没有解决无穷计数的问题） 解决方案：定义最大度量：定义一个最大的有效费用值，如15跳步，16跳步表示无穷。 LS vs DV 报文复杂度 LS：n个节点，E条链路，需要发送O(nE) DV：只在直连的邻居间交换报文 收敛速度 LS：是一个要求O(nE)个报文的O(n^2)算法，可能有震荡（链路边为信息流量） DV：收敛事件不确定，可能会遇到选路环路，可能遇到无穷问题 健壮性 LS：节点能够向其连接的链路广播”不正确的费用“，每个节点只计算自己的转发表 DV：一个节点可以向任意或所有的节点通告其“不正确的最低费用路径”，每个节点的计算都会传递给它的邻居（错误经过网络传播） 5.3 因特网中自治系统内部的路由选择：OSPF5.4 ISP之间的路由选择：BGP5.6 ICMP：因特网控制报文协议 用于主机、路由器、网关之间交换网络层信息 差错报告：例如有主机、网络、端口、协议不可达等等 网络探寻/回声请求、回答（ping 应用程序） 有两类ICMP报文： 差错报告报文：目的不可达、源抑制、超时/超期、参数问题、重定向 网络探寻报文：回声请求及应答报文、时间戳请求与应答报文 不发送ICMP差错报文的特殊情况 如果ICMP差错报告报文出现了错误，不再对此发送ICMP差错报告报文 除了第一个IP数据报分片之外，对所有后续分片均不发送ICMP差错报告报文 广播IP数据报，不发送ICMP差错报告报文 对具有特殊地址（127.0.0.1或0.0.0.0）的IP数据报不发送ICMP差错报告报文 几种ICMP报文不再使用 信息请求与应答 子网掩码请求和应答 路由器询问和通告 ICMP报文格式（封装到IP数据报传输 前4字节：类型 8 bit、代码 8 bit、校验和 16 bit 4-8字节：取决于ICMP报文的类型（差错报告报文和ICMP询问报文） ICMP的数据部分（长度取决于类型） ICMP的差错报文数据封装 首先我们找到出差错的IP数据报=IP数据报首部+8字节 ICMP差错报告报文=ICMP的前8字节+IP数据报首部+8字节 装入ICMP报文的IP数据报=首部+ICMP差错报告报文第6章 链路层和局域网6.1 链路层概述6.2 差错检测和纠正技术6.3 多路访问链路协议6.4 交换局域网6.7 回顾：Web页面请求的历程 第7章 无线网络和移动网络7.1 概述 元素：无线主机、无线链路（连接无限主机和基站）、基站 基础设施模式：固定基础设施、自组网络 切换：移动主机的移动-&gt;改变与之关联的基站 概念7.2 无线链路和网络特征 基站=访问点AP 基本服务集BBS，也称单元。 基础设施网络模式=无线主机+AP（BBS之间通过集线器、交换机、路由器进行连接） 自主网模式（ad hoc）=主机 AP： 802.11b在2.4-2.485g被划分成11个不同频率的信道 每一个AP选择一个信道 存在干扰的可能（相邻的AP选择相同的信道） 主机：必须与每一个AP关联 扫描信道，监听包含AP名称（SSID）和MAC地址的信标帧 选择一个AP进行关联 可能要进行身份验证 典型情景：DHCP获取IP地址 扫描方式 被动扫描（AP主动提供）：AP发送信标帧、主机发送关联请求帧、AP向主机提供关联响应帧 主动扫描（主机自己广播）：主机广播探测请求帧、AP发送探测响应帧、主机选择一个AP发送关联请求帧、AP向主机发送关联响应帧 多路访问控制：避免2+节点的同时冲突 802.11:CSMA——发送数据前监听信道（避免与正在进行传输的其他节点发生冲突） 802.11:不能像CSMA/CD那样，边发送边检测冲突 无限信道很难实现 无法侦听到所有可能冲突：PPT上的两个例子（隐藏站、信号衰落） 目标：避免冲突（collision avoidance）——CSMA/CA CSMA/CA DIFS时间：如果监听信道空闲了DIFS时间，则发送整个帧，同时检测无冲突CD SIFS时间：如果接收方正确接收了帧，延迟SIFS时间之后，向发送端发送ACK 如果监听到了信道忙，开始退避计时。信道空闲的时候，计时器倒计时，计时器超时的时候，发送帧。如果没有收到ACK，增加随机退避间隔时间，重复这一步。 协议的内容 基本思想：允许发送端”预约“信道，而不是随机发送数据帧，从而边面长数据帧传输的冲突（利用很小的预约帧，避免大的冲突） sender利用CSMA向基站发送一个很短的RTS(request to send) BS广播一个CTS(clear to send)帧作为对RTS的响应 CTS帧可以被所有节点接收：消除了隐藏站的影响，发送端可以发送数据帧、其他节点推迟发送 注意到，发送ACK的时候，也会向所有节点发送ACK，告诉其他节点现在可以发送了，推迟发送时间恰好是CTS到ACK的时间 802.11 MAC帧7.3 WiFi：802.11无线LAN 均使用CDMA/CA多路访问控制协议、均有基础设施（基站）访问模式和特定网（自主网）网络模式 802.11b： 2.4g-2.5g免费频段，最高速率11mbps（所有主机使用相同的码片序列）（便宜、数据率低、信号最远、不易受阻） 802.11a：5-6g频段，最高速率54mbps（受阻，较短、贵） 802.11g：2.4-2.5g频段，最高速率54mbps（信号传播远、不易受阻，比11b贵） 802.11n：多天线（MIMO）：2.4-2.5g频段，最高速率600mbps（多个发射和接收天线更高数据率传输，双倍带宽时速率可达600Mbps）","categories":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}],"tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"www.waylonding.cn/blog/tags/Computer-Network/"},{"name":"System & Network","slug":"System-Network","permalink":"www.waylonding.cn/blog/tags/System-Network/"}],"keywords":[{"name":"CS Courses","slug":"CS-Courses","permalink":"www.waylonding.cn/blog/categories/CS-Courses/"}]},{"title":"QT creator的使用与TCP传输试验","slug":"QT creator的使用与TCP传输试验","date":"2019-11-18T12:52:39.000Z","updated":"2019-11-19T11:33:18.532Z","comments":true,"path":"2019/11/18/QT creator的使用与TCP传输试验/","link":"","permalink":"www.waylonding.cn/blog/2019/11/18/QT%20creator%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8ETCP%E4%BC%A0%E8%BE%93%E8%AF%95%E9%AA%8C/","excerpt":"","text":"使用QT creater实现图形化界面1 QT creater的安装 安装的时候注意一点即可，QT5.9之后的安装包不再分VS版本和WINGW版本，而是都整合到了一个安装包中，请根据需要下载 下载地址可以参考：QT的安装 安装过程可以参考以下博客：https://blog.csdn.net/qq_23473839/article/details/80523318 2 用QT实现C++图形界面2.1 生成简单的窗口并输出文字 关于在qt图形化界面上生成文字（英文），可参照以下博客：https://blog.csdn.net/larger5/article/details/78587076 要注意一点，你的文件路径不能出现中文，不然会报错，就像这样：Error while building/deploying project qt (kit: Desktop Qt 5.11.0 MinGW 32bit) When executing step &quot;qmake&quot; 关于解决中文路径的方法，推荐以下博客：https://blog.csdn.net/m0_37906001/article/details/76672634 建议还是尽量全部使用用英文路径，以免以后遇到不必要的麻烦。2.2 UI探索","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"www.waylonding.cn/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"www.waylonding.cn/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"www.waylonding.cn/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Build My Personal Blog with Github and Hexo","slug":"hexo博客安装与利用hexo写文章","date":"2019-11-18T12:52:39.000Z","updated":"2019-11-19T11:32:38.761Z","comments":true,"path":"2019/11/18/hexo博客安装与利用hexo写文章/","link":"","permalink":"www.waylonding.cn/blog/2019/11/18/hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%A9%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0/","excerpt":"","text":"搭建hexo博客并用hexo写文章文中对所有的参考博客都给出了链接，感谢这些博客给予的帮助。 1 利用github和hexo搭建博客1.1 搭建步骤概述 本地安装（命令行安装）git、nodejs、hexo。创建本地blog文件夹，执行hexo init。 注册github账号（如果没有注册）、github创建新项目，用于保存你的hexo博客。（若还没在本地配置账号信息和ssh，也需要创建） 在本地文件夹，修改_config.yml的一些配置，首先要指向你的github仓库，然后生成博客。可以利用.io域名访问 如果要绑定个人域名，添加一条DNS记录即可。 然后可以配置主题，主题官网在hexo主题配置 可以修改和安装一些设置 1.2 可供参考的安装和配置hexo的博文 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://www.cnblogs.com/visugar/p/6821777.html 2 把hexo博客搭载到域名子目录 主要参考的是以下的博客：https://www.jianshu.com/p/18356b0a7494直接看：三、操作步骤 修改即可（前提是你上一步的搭建过程该有的配置已经完成） 3 用hexo编写和发布文章3.1 markdown文件的书写hexo主要是用markdown进行书写，下面归纳整理了一些markdown书写过程中的一些常用功能的查找手册以及问题的解决方法： 关于markdown的整体格式和页面书写书写可以参考以下教程：markdown教程 markdown公式大全参考：https://www.jianshu.com/p/25f0139637b7 为md文件生成toc目录，这里我们以在VScode上编写markdown文本为例：https://www.jianshu.com/p/4721ddd27027 VScode自动生成目录时有可能遇到换行不对的问题，参考以下网址解决即可：https://jingyan.baidu.com/article/6b97984df62b501ca3b0bf7a.html 本地md生成了toc目录之后，传到github上之后，该md文件也能正常显示目录，不用再下载任何插件。（由于网上有些人说github上面不支持toc目录，这里澄清一下，并不用额外安装插件，只用在本地安装toc支持并能正常显示目录，在github上面也能正常显示） hexo支持toc自动生成目录，可以参考以下博文配置：https://www.jianshu.com/p/87a885fef1a6 3.2 关于用hexo发布博客 文章发布见如下步骤： 在主目录下，输入hexo new post &quot;文章名&quot;或者hexo new “文章名”,都会在source/_posts/中多出一个.md文件（命令行也会提示你这里多出来一个.md文件），编写这个md文件即可。 打开这个md文件，你会看到要你填写title、date、tags。其中title和date已经自动生成好了(你也可以改)，你只需要填写tag（标签）即可。当然你可也以自己添加其他属性，比如comment（是否可以评论）、toc（是否显示文章目录）、categories（文章分类）。给出一个完整的文章接本设置的代码如下： 12345678910---title: 你的文章的titledate: yy-mm-dd hh:mm:sscomments: true #是否可评论toc: true #是否显示文章目录categories: gexo博客搭建 #分类tags: #标签 - tag1 - tag2--- 编写好文件之后，用hexo clean；hexo g；hexo d 这三条命令，将你所编写的文件放到你的博客上 4 hexo的个性化布局4.1 hexo的页面设置 hexo有几个官方的页面，但是需要自己生成：标签、分类、归档和关于，下面简单介绍一下： 标签页面，创建方式hexo new page tags，然后再在主题配置文件_config.yml中添加：12menu: tags: /tags 在文章中添加tags的方法就是：123456---title: 你的文章的titletags: #标签 - tag1 - tag2--- 添加分类页面；创建方式hexo new page categories，然后在主题配置文件中添加：12menu: categories: /categories 在文章中添加分类的方法为：123456---title: 你的文章的titlecategories: #分类 - hexo - skills--- 同理，根据以上的步骤，还可以添加主页面home、归档archives、关于about。主题配置文件_config.yml中添加如下：123456menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于 我们也可以自己定义一个页面，比如myself页面，创建方式还是hexo new page myself,在主题配置文件_config.yml中添加如下（这里显示我们所有的页面配置）： 123456menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于","categories":[{"name":"hexo搭建属于自己的博客","slug":"hexo搭建属于自己的博客","permalink":"www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"name":"hexo技术","slug":"hexo搭建属于自己的博客/hexo技术","permalink":"www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/hexo%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo相关技术","slug":"hexo相关技术","permalink":"www.waylonding.cn/blog/tags/hexo%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"markdown的使用","slug":"markdown的使用","permalink":"www.waylonding.cn/blog/tags/markdown%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"keywords":[{"name":"hexo搭建属于自己的博客","slug":"hexo搭建属于自己的博客","permalink":"www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"name":"hexo技术","slug":"hexo搭建属于自己的博客/hexo技术","permalink":"www.waylonding.cn/blog/categories/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/hexo%E6%8A%80%E6%9C%AF/"}]}]}